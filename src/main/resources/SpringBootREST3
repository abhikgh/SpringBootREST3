
SpringBoot3 changes
===========================================================

1. 	<version>3.2.7</version>
	<java.version>21</java.version>
	<spring-cloud.version>2022.0.4</spring-cloud.version>
	<openapi.version>2.2.0</openapi.version>

2. <!--Lombok-->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.30</version>
    <scope>provided</scope>
</dependency>

3. javax.persistence -> jakarta.persistence

4. JSONB ->  @Type(JsonBinaryType.class)

5. Security ->


@Configuration
@EnableWebSecurity
public class SecurityConfig {

   @Value("${application.spring.endpoints.exclude}")
   private String[] applicationApisToBeExcluded;

    @Value("${service.endpoints.exclude:}")
    private String[] serviceApisToBeExcluded;

    private String[] allApisToBeExcluded(){
        return Stream.of(applicationApisToBeExcluded, serviceApisToBeExcluded)
                .flatMap(Stream::of)
                .toArray(String[]::new);
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {
        return httpSecurity
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(requests -> requests.requestMatchers(allApisToBeExcluded()).permitAll()
                        .anyRequest().authenticated())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .build();
    }
}

6. Observability -> 
	See details below

7. jaxb-api -> 

	    <groupId>javax.xml.bind</groupId>
            <artifactId>jaxb-api</artifactId>			is replaced with
            
	    <groupId>jakarta.xml.bind</groupId>
            <artifactId>jakarta.xml.bind-api</artifactId>

8. Swagger -> 

	<dependency>
            <groupId>org.springdoc</groupId>
            	<artifactId>springdoc-openapi-webmvc-core</artifactId>
            <artifactId>springdoc-openapi-starter-webmvc-api</artifactId>
            <version>${openapi.version}</version>
        </dependency>

9. Tests -> 	@MockBean 		is replaced with 

		        @Mock

ApplicationConfig
========================
@Configuration
public class ApplicationConfig {

    //Tomcat Protocol Handler is responsible for handling incoming requests in a Spring Boot application
    //TomcatProtocolHandlerCustomizer configures the Executor
    //Executor is responsible for executing tasks, like handling incoming requests.
    @Bean
    TomcatProtocolHandlerCustomizer<?> tomcatProtocolHandlerCustomizer() {
        return protocolHandler -> {
            protocolHandler.setExecutor(Executors.newVirtualThreadPerTaskExecutor());
        };
    }
}

SecurityConfig
=======================

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private static final String[] AUTH_WHITELIST = {
            "/v3/rest/hello", "/v3/rest/helloPost", "/v3/rest/home"
    };

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {
        return httpSecurity
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(auth -> auth.requestMatchers(AUTH_WHITELIST).permitAll()
                        .anyRequest().authenticated())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .build();
    }
}

Gatling
======================

Gatling : Load testing tool that can be used to simulate user behavior and test the performance of Spring Boot applications under different loads
Compared to JMeter : Gatling is faster, lightweight, and provides more detailed and colorful reports

simulation service :: E:\Softwares\gatling-charts-highcharts-bundle-3.9.5\user-files\simulations\GatlingSimulation.java

Run gatling :: E:\Softwares\gatling-charts-highcharts-bundle-3.9.5\bin\gatling.bat

Results :: E:\Softwares\gatling-charts-highcharts-bundle-3.9.5\results

<dependency>
    <groupId>io.gatling</groupId>
    <artifactId>gatling-core</artifactId>
    <version>3.9.3</version>
</dependency>
<!-- https://mvnrepository.com/artifact/io.gatling.highcharts/gatling-charts-highcharts -->
<dependency>
    <groupId>io.gatling.highcharts</groupId>
    <artifactId>gatling-charts-highcharts</artifactId>
    <version>3.9.3</version>
</dependency>
<!-- https://mvnrepository.com/artifact/io.gatling/gatling-maven-plugin -->
<dependency>
    <groupId>io.gatling</groupId>
    <artifactId>gatling-maven-plugin</artifactId>
    <version>4.3.1</version>
</dependency>


Class Data Sharing (CDS)
==============================
JVM optimization technique

Creates a snapshot of the application classes and then storing them in a shared archived file
During startup, JVM can reference this archive, dramatically speeding up the class loading process.

spring.context.exit-on-refresh=true
-XX:ArchiveClassesAtExit=app-cds.jsa
# On the JVM you plan to deploy to:
java -Xshare:on -XX:SharedArchiveFile=app-cds.jsa -jar myapp.jar

GraalVM native image 
========================
Compiles the Java code into a standalone executable, eliminating the need for a JVM at runtime.


Micrometer
======================

<!-- Micrometer-core -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-core</artifactId>
    <scope>runtime</scope>
</dependency>
<!-- Micrometer-prometheus -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
    <scope>runtime</scope>
</dependency>
	This module enables Prometheus to scrape Micrometer logs
	define our own metrics using Micrometer
	gather them using Prometheus
	display them on a Grafana dashboard

		      (exposes Metrics)  (Tracing + metrics collector and shipment)  (scrape the Metrics)     (query Prometheus)
SpringBoot ------> Actuator  ---->   Micrometer   --------------->             Prometheus     ------>    Grafana (observability backend)
									(monitoring backend : monitoring and alerting toolkit)
                                                                                                      - OpenTelemetry, Jaeger, Zipkin
application.yaml
------------------------------
management:
  server:
    port: 9101
  endpoints:
    web:
      exposure:
        include: health, prometheus
      base-path: "/"
      path-mapping:
        prometheus: "metrics"
  metrics:
    tags:
      application: transfer-service

promotheus.yaml
--------------------------
global:
  scrape_interval: 15s # By default, scrape targets every 15 seconds.
# A scrape configuration containing exactly one endpoint to scrape:
# Here it's Prometheus itself.
scrape_configs:
  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.
  - job_name: 'prometheus'
    # Override the global default and scrape targets from this job every 5 seconds.
    scrape_interval: 5s
    static_configs:
      - targets: [ 'localhost:9090' ]
  - job_name: 'transfer-service'
    # Override the global default and scrape targets from this job every 5 seconds.
    scrape_interval: 2s
    metrics_path: /metrics
    static_configs:
      - targets: [ 'host.docker.internal:9101' ]

Metric type                             Description
------------------                  ----------------------------------------
default
--------
Thread utilization
CPU Usage
Cache utilization
Connection pool

@Autowired
private MeterRegistry meterRegistry;

// http://localhost:9050/orders/v1/getMoviesByDirectorAndGenre/Satyajit Ray/Family
@GetMapping(value = "/getMoviesByDirectorAndGenre/{director}/{genre}", produces = MediaType.APPLICATION_JSON_VALUE)
public ResponseEntity<List<Movie>> getMoviesByDirectorAndGenre(
        @PathVariable("director") String director,
        @PathVariable("genre") String genre) {

    //Counter metric
    Counter counter = Counter.builder("getMoviesByDirectorAndGenre")
            .description("a number of requests to /getMoviesByDirectorAndGenre endpoint")
            .register(meterRegistry);
    counter.increment();

    //Gauge metric
    Gauge.builder("users_count", userService::countUsers)
            .description("A current number of users in the system")
            .register(meterRegistry);

    //Timer metric
    Timer.Sample timer = Timer.start(meterRegistry);

    List<Movie> movies = movieService.getMoviesByDirectorAndGenre(director, genre);

    timer.stop(Timer.builder("getMoviesByDirectorAndGenre_Timer").register(meterRegistry));
    return ResponseEntity.ok(movies);
}

----------------------------------------------------------------------------------------------------------------------

Spring Observability (builds on Micrometer, formerly Spring Cloud Sleuth)
===============================================================================
Observability is the ability to measure the internal state of a system only by checking its outputs (logs, traces, metrics)
OpenTelemetry :: vendor-neutral Observability framework which provides a standard way to collect observability data (Logs,Traces and Metrics) and export them
		OpenTelemetry replaces OpenTracing

		      (exposes Metrics)     (custom Metrics + Traces)           (scrape(gather) the Metrics, monitoring and alerting toolkit)     (query Prometheus)
SpringBoot ------> Actuator  ---->   Micrometer   --------------->             Prometheus     -------------->                          Grafana (observability backend)
									            micrometer-registry-prometheus

define our own metrics using Micrometer
gather them using Prometheus
display them on a Grafana dashboard

<!-- Web -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<!-- Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<!-- Micrometer-prometheus -->
<!-- This module enables Prometheus to scrape Micrometer logs and Micrometer metrics at a configured interval and display them in a Grafana dashboard-->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
    <scope>runtime</scope>
</dependency>

<!-- AOP, for custom timer -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
<!--OpenTelemetry Tracer: Bridges the Micrometer Observation API to OpenTelemetry-->
<dependency>
  <groupId>io.micrometer</groupId>
  <artifactId>micrometer-tracing-bridge-otel</artifactId>
</dependency>
<!--Zipkin with OpenTelemetry: Reports traces to Zipkin-->
<dependency>
  <groupId>io.opentelemetry</groupId>
  <artifactId>opentelemetry-exporter-zipkin</artifactId>
</dependency>

Actuator
===========================
Actuator exposes management endpoints
These endpoints can be used to collect data on a variety of metrics, such as CPU usage, memory usage, request rate, error rate

/health
/info
/env
/loggers
/httptrace
/sessions
/startup
/shutdown

management:
  endpoints:
    web:
      exposure:
        include: health, prometheus, metrics, info
  endpoint:
    health:
      show-details: always
    metrics:
      enabled: true
    prometheus:
      enabled: true // Exposes metrics in a format that can be scraped by a Prometheus server.
    info:
      java:
        enabled: true
      env:
        enabled: true

Micrometer
====================
vendor-neutral application Metrics facade which replaces Spring Cloud Sleuth

Micrometer metrics::
-----------------------
Timer                                 measuring short-duration latencies, and the frequency of such events.
Counter				                  count
Gauge	                              current value
DistributionSummary	                  total amount of all recorded events
Micrometer Observation API            lightweight library for application metrics

@Configuration
public class ApplicationConfig {

	  // Monitoring beans
	  @Bean
	  ObservationRegistry observationRegistry() {
	    return ObservationRegistry.create();
	  }
	
	  // To have the @Observed support we need to register this aspect
	  @Bean
	  ObservedAspect observedAspect(ObservationRegistry observationRegistry) {
	    return new ObservedAspect(observationRegistry);
	  }
}

@GetMapping(value = "/hello", produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE)
public ResponseEntity<String> hello() {

    //Counter metric
    Counter counter = Counter.builder("hello")
            .description("gets number of requests to /hello endpoint")
            .register(meterRegistry);
    counter.increment();

    return ResponseEntity.status(HttpStatus.OK)
            .body("Hello World");
}

Prometheus
=====================================
Monitoring and Alerting toolkit
Prometheus needs an endpoint(metrics_path) to scrape Micrometer logs and Micrometer metrics at a configured interval and display them in a Grafana dashboard

prometheus.yml
------------------
scrape_configs:
  - job_name: 'SpringBootREST3'
    metrics_path: '/actuator/prometheus'
    scrape_interval: 5s
    static_configs:
      - targets: ['host.docker.internal:9050']
        labels:
          application: 'SpringBootREST3'


Hit the request
    http://localhost:9100/v3/rest/hello
    and then check

Check in Prometheus ::
            http://localhost:9090/
                - prometheus_http_requests_total
                - process_uptime_seconds gauge


management:
  tracing:
    sampling:
      probability: 1.0

How does Prometheus that is running on Docker connect to SpringBoot app that is running on localhost?
---------------------------------------------------------------------------------------------------------------
- targets: ['host.docker.internal:9050']
  host.docker.internal is a host-gateway which is a daemon process routing requests to localhost

Behind the scenes, an observation has been created for the HTTP request, which in turn gets bridged to OpenTelemetry, which reports a new trace to Zipkin.

http://localhost:9090/
- Check Status -> Targets

#TYPE http_server_requests_seconds_count
#TYPE getMoviesOfDirector_time_seconds_max gauge
#TYPE getMoviesOfDirector_time_seconds_count :: gives count of calls

Grafana
======================
Data Visualization service -  create dashboards to visualize and analyze data
Ensure to add Prometheus as a Data Source in Grafana.
query Prometheus(datasources)
     depends_on:
          - prometheus

datasources.yml
----------------------
apiVersion: 1
datasources:
  - name: Prometheus
    type: prometheus
    access: proxy
    url: http://prometheus:9090
    isDefault: true

docker-compose-yml
--------------------------
version: '3.7'

services:
  prometheus:
    image: prom/prometheus:v2.44.0
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus.yml

  grafana:
    image: grafana/grafana:9.5.2
    container_name: grafana
    ports:
      - "3000:3000"
    restart: unless-stopped
    volumes:
      - ./datasources.yml:/etc/datasources.yml
    depends_on:
      - prometheus

http://localhost:3000/ (admin/welcome@1a)

Connect to Prometheus from Grafana
-----------------------------------------
Get Prometheus container id
docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' daca98a3c836
- 172.22.0.2
Prometheus IP in Grafana :: http://172.22.0.2:9090


Running all on Docker
-------------------------
Start the application
Start Docker Desktop
Run docker-compose.yml :: D:\workspace2\SpringBootREST3\src\main\resources>docker-compose up --build
Once done, check in Docker Desktop that prometheus and grafana images are present
Open Gitbash ::
            docker images (prometheus and grafana images)
            docker ps (All running containers, containers with prometheus and grafana images)
Hit http://localhost:9100/v3/rest/hello a few times
Check in Prometheus ::
            http://localhost:9090/
                - prometheus_http_requests_total
                - process_uptime_seconds gauge
Check in Grafana ::
            http://localhost:3000/ (admin/welcome@1a)


----------------------------------------------------------------------------------------------------------------------

OpenTelemetry
================================================
vendor-agnostic tools, APIs, and SDKs for observability by collecting Logs, Traces and Metrics
OpenTelemetry replaces OpenTracing
OpenTelemetry provides a collector known as an Otel collector that processes and exports the telemetry data to any observability backends like Jaeger, 

micrometer collector in the actuator dependency to collect the traces and then use the OpenTelemetry dependency to export the traces.

		      (exposes Metrics)  (Metrics  + Tracing + Logs)                    (LTM  :: collection and shipment)
SpringBoot ------> Actuator  ---->   Micrometer    ----------------------->           Otel Collector       ------->           Jaeger (Observability Backend)
                                                   micrometer-tracing-bridge-otel                             opentelemetry-exporter-otlp

pom.xml
-----------

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.2.7</version>
		<relativePath/>
	</parent>
	<groupId>com.example</groupId>
	<artifactId>SpringBootREST3</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>SpringBootREST3</name>
	<description>Demo project for Spring Boot</description>
	<properties>
		<java.version>21</java.version>
	</properties>
	<dependencies>
	    <!-- Web -->
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-web</artifactId>
                </dependency>
                <!-- Actuator -->
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-actuator</artifactId>
                </dependency>
                <!-- Micrometer-core -->
                <dependency>
                    <groupId>io.micrometer</groupId>
                    <artifactId>micrometer-core</artifactId>
                    <version>1.11.6</version>
                </dependency>
                <!-- Micrometer-prometheus -->
                <dependency>
                    <groupId>io.micrometer</groupId>
                    <artifactId>micrometer-registry-prometheus</artifactId>
                    <scope>runtime</scope>
                </dependency>
                <!--Bridges the Micrometer Observation API to OpenTelemetry-->
                <dependency>
                    <groupId>io.micrometer</groupId>
                    <artifactId>micrometer-tracing-bridge-otel</artifactId>
                </dependency>
                <!--OpenTelemetry exporter-->
                <dependency>
                    <groupId>io.opentelemetry</groupId>
                    <artifactId>opentelemetry-exporter-otlp</artifactId>
                </dependency>
                <!--Jaeger-->
                <dependency>
                    <groupId>io.opentracing.contrib</groupId>
                    <artifactId>opentracing-spring-jaeger-web-starter</artifactId>
                    <version>3.3.1</version>
                </dependency>
                <!--Jaeger-remote-sampler-->
                <dependency>
                    <groupId>io.opentelemetry</groupId>
                    <artifactId>opentelemetry-sdk-extension-jaeger-remote-sampler</artifactId>
                </dependency>

	</dependencies>

	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>2021.0.8</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

otel-config.yml
------------------

receivers:
  otlp:
    protocols:
      grpc:
      http:

processors:
  batch:

exporters:
  logging:
    loglevel: debug
  jaeger:
    endpoint: jaeger-service:14250
    tls:
      insecure: true

service:
  pipelines:
    traces:
      receivers:  [ otlp ]
      processors: [ batch ]
      exporters:  [ logging, jaeger ]

docker-compose.yaml
--------------------------
version: '3.7'

services:
  collector:
    image: otel/opentelemetry-collector:0.72.0
    command: [ "--config=/etc/otel-collector-config.yml" ]
    volumes:
      - ./otel-config.yml:/etc/otel-collector-config.yml
    ports:
      - "4317:4317"
    depends_on:
      - jaeger-service

  jaeger-service:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686"
      - "14250:14250"
      - "5775:5775/udp"
      - "6831:6831/udp"
      - "6832:6832/udp"

application.yaml
----------------------------

spring:
  application:
    name: SpringBootREST3
  datasource:
    url: jdbc:postgresql://localhost:5432/springbootdb
    username: postgres
    password: tiger
    driver-class-name: org.postgresql.Driver
    hikari:
      connection-timeout: 5000
      maximum-pool-size: 5
  jpa:
    show-sql: true
    properties:
      hibernate:
        format-sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
  main:
    allow-bean-definition-overriding: true
  spring:
    sleuth:
      otel:
        config:
          trace-id-ratio-based: 1.0
      exporter:
        otlp:
          endpoint: http://collector:4317


logging:
  level:
    org:
      springframework:
        security: DEBUG
  pattern:
    level: '%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]'

server:
  port: 9100

management:
  endpoints:
    web:
      exposure:
        include: ["health","prometheus","metrics","info"]
  endpoint:
    health:
      show-details: always
    metrics:
      enabled: true
    prometheus:
      enabled: true
  info:
    java:
      enabled: true
    env:
      enabled: true
  tracing:
    sampling:
      probability: 1.0

application:
  spring:
    endpoints:
      exclude: /v3/rest/hello, /v3/rest/helloPost, /v3/rest/home, /actuator/**, /v3/rest/getMoviesOfDirector/**, /v3/rest/getMoviesByDirectorAndGenre/**


opentracing:
  jaeger:
    enabled: true


Jaeger
--------------------------
@Configuration
@ConditionalOnProperty(value = "opentracing.jaeger.enabled", havingValue = "true")
public class JaegerConfig {

    @Bean
    public JaegerTracer jaegerTracer() {

        return new io.jaegertracing.Configuration("SpringBootRest2")
                .withSampler(new io.jaegertracing.Configuration.SamplerConfiguration().withType(ConstSampler.TYPE).withParam(1))
                .withReporter(new io.jaegertracing.Configuration.ReporterConfiguration().withLogSpans(true))
                .getTracer();
    }

}


@RestController
@RequestMapping("/v3/rest")
public class NavController {

    @Autowired
    private HomeService homeService;

    @Autowired
    private MovieService movieService;

    @Autowired
    private MeterRegistry meterRegistry;

    @Autowired
    private JaegerTracer jaegerTracer;

    Logger log = LoggerFactory.getLogger(NavController.class);

    // http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray
    @GetMapping(value = "/getMoviesOfDirector/{director}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<List<Movie>> getMoviesOfDirector(
            @PathVariable("director") String director) {
        Span span = jaegerTracer.buildSpan("getMoviesOfDirector").start();
        log.info("Inside getMoviesOfDirector controller... ");

        //Counter metric
        Counter counter = Counter.builder("getMoviesOfDirector")
                .description("a number of requests to /getMoviesOfDirector endpoint")
                .register(meterRegistry);
        counter.increment();

        //Timer metric
        Timer.Sample timer = Timer.start(meterRegistry);
        Span getHeroDetailsSpan = jaegerTracer.buildSpan("getMoviesOfDirector-Service").asChildOf(span).start();
        List<Movie> movies = movieService.getMoviesOfDirector(director);
        getHeroDetailsSpan.finish();
        span.finish();
        timer.stop(Timer.builder("getMoviesOfDirector_Timer").register(meterRegistry));
        return ResponseEntity.ok(movies);
    }

    // http://localhost:9100/v3/rest/getMoviesByDirectorAndGenre/Satyajit Ray/Comedy
    @GetMapping(value = "/getMoviesByDirectorAndGenre/{director}/{genre}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<List<Movie>> getMoviesByDirectorAndGenre(
            @PathVariable("director") String director,
            @PathVariable("genre") String genre) {

        //Counter metric
        Counter counter = Counter.builder("getMoviesByDirectorAndGenre")
                .description("a number of requests to /getMoviesByDirectorAndGenre endpoint")
                .register(meterRegistry);
        counter.increment();

        //Gauge metric
        Gauge.builder("users_count", movieService::countUsers)
                .description("A current number of users in the system")
                .register(meterRegistry);

        //Timer metric
        Timer.Sample timer = Timer.start(meterRegistry);

        List<Movie> movies = movieService.findByDirectorAndGenre(director, genre);

        timer.stop(Timer.builder("getMoviesByDirectorAndGenre_Timer").register(meterRegistry));
        return ResponseEntity.ok(movies);
    }
}


Running all on Docker
-------------------------
Start the application
Start Docker Desktop
Run docker-compose.yml :: D:\workspace2\SpringBootREST3\src\main\resources>docker-compose up --build
Once done, check in Docker Desktop that Otel Collector and Jaeger images are present
Open Gitbash ::
            docker images (Otel Collector and Jaeger images)
            docker ps (All running containers, containers with Otel Collector and Jaeger image)
Hit http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray a few times
Check in Jaeger ::
           http://localhost:16686/search


-------------------------------------------------------------------------------------------------

Opentelemetry                            vs                                     Prometheus
===============================================================================================
Logs, Traces and Metrics                                                        Metrics
More scalable
calculates delta                                                               calculates cumulative measurements as a total
Consolidated API for LTM and transform them into a single language

-------------------------------------------------------------------------------------------------
