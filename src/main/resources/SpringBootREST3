SpringBoot
================
1. Java-based Spring-framework to build Spring application
   Eliminates a lot of boiler-plate code required for setting up a Spring application

2. AutoConfiguration ::  Automatically configures beans
    @SpringBootApplication = @Configuration +  @EnableAutoConfiguration  + @ComponentScan
    @Configuration : source for @Bean
    @EnableAutoConfiguration : Spring configures the application based on dependencies and libraries and sets the properties value
    @ComponentScan : Spring searches for Spring beans annotated with @Configuration, @Controller, @Component, @Service, @Repository in the package and the sub-packages and puts them in ApplicationContext
    @Bean - registering your bean in Spring Application Context
    @Autowired - Spring Application Context injects the bean as a Spring Managed Bean(SMB) dependency in another object
	    SMB - Lifecycle management , No new objects, Loose Coupling,  Easier to test
    @RestController = @Controller + @ResponseBody(return value of the method will be serialized into HTTP ResponseBody)
    @Entity - Mapping between the class and the Database table as ORM
    @Transactional - Spring intercepts the method and starts a Transaction before the method - after the method is executed - Commit/Rollback .
        The database transaction happens inside the scope of  Persistence Context.

3. Embedded Tomcat server
4. Spring datasource
    spring:
      datasource:
        url: jdbc:postgresql://localhost:5432/springbootdb
        driver-class-name: org.postgresql.Driver
        username: postgres
        password: ENC(fr05KZkgIQviKiJr2CE6kF042eGwt6QvEFjcccT3ZzU8iM4xforSPVNcul2bKApE)

5. spring-boot starer dependencies
        -makes development much easier and faster, no need to remember dependency versions
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-web</artifactId>
                </dependency>
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-data-jpa</artifactId>
                </dependency>
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-actuator</artifactId>
                </dependency>
		<dependency>
		    <groupId>org.springframework.boot</groupId>
		    <artifactId>spring-boot-starter-security</artifactId>
		</dependency>
5. Plugins
        <artifactId>spring-boot-maven-plugin</artifactId>
        <artifactId>maven-jaxb2-plugin</artifactId>
        <artifactId>jacoco-maven-plugin</artifactId>
6. Actuator

-------------------------------------------------------------------------------------------------

SpringBoot Architectures
=================================
1.  Microservices API driven architecture - is a software development approach that breaks down an application into a collection of independent services
                              - independently developed, deployed, scaled, managed
2.  Microservices Event driven architecture
3.  Spring security architecture

-------------------------------------------------------------------------------------------------

1. Microservices API driven architecture
==================================================

OAuth2.0
----------
OAuth 2.0 is an Open Authorization Protocol that gives Clients limited access to user accounts on an HTTP service without exposing user credentials and get access to Resource

Delegating the user authentication to a AUTHENTICATION SERVER that hosts user credentials
On successful authentication AUTHENTICATION SERVER returns a JWTToken
Client takes this token to RESOURCE SERVER and after validation of the token for authentication and authorization access is granted
OAuth2.0 SSL is required for all the communications required to generate the token

	     AUTHENTICATION SERVER		  (Authentication)
	 {username, password, clientId, clientSecret, grantType, audience, scope}	   (U2M : Resource Owner Password flow)
	 {clientId, clientSecret, grantType, audience, scope}     			           (M2M : Client Credential flow)
		     |
      	 	 | {JWTToken}
      		 |		                httpHeaders.set("Authorization", "Bearer JWTToken");
User/Machine    -------> CLIENT  -------------------------------------------------------->       CLOUD DNS             ------------>         RESOURCE SERVER
			                                                                         |
			                                                                AKAMAI (CDN) (IP whitelisting)                   -> validates JWTToken
			                                                                         |                                       -> validates Role from the JWTToken
			                                                                      KONG (Api Gateway)                         -> returns the secure resource to the client
			                                                                         |
			                                                                  CLOUD ARMOUR (firewall)     <---------- CLOUD FUNCTION (policies to support that CA only accepts IPs passed through Akamai)
			                                                                         |
			                                                                    INGRESS (Load Balancer)
			                                                                        |
			                                                                    WORKLOADS (services)

			     AUTHENTICATION SERVER (private key, signature) ----------------> RESOURCE SERVER (public key, verify signature)
                                    -private key : AUTHENTICATION SERVER uses the private key to sign the JWT
                                    -public key  : RESOURCE SERVER uses the public key to verify the signature of the JWTToken (shared widely)


 Benefits :
1. CLIENT does not know user credentials - has only the JWTToken
2. Granular access to CLIENT

2. Microservices Event driven architecture
========================================================
1. Spring's event-driven architecture

//create Event
public class OrderPlacedEvent extends ApplicationEvent {
    private final Order order;

    public OrderPlacedEvent(Object source, Order order) {
        super(source);
        this.order = order;
    }

    public Order getOrder() {
        return order;
    }
}

//publish Event
@Service
public class OrderService {

    @Autowired
    private ApplicationEventPublisher applicationEventPublisher;

    public void placeOrder(Order order) {
        // Logic to place the order


        // Publish the order placed event
        applicationEventPublisher.publishEvent(new OrderPlacedEvent(this, order));
    }
}

//Event listener
@Component
public class OrderConfirmationListener {

    @EventListener
    public void handleOrderPlacedEvent(OrderPlacedEvent event) {

        //Logic to manage inventory
        Order order = event.getOrder();

        // Logic to send order confirmation email
        Order order = event.getOrder();

        // Logic to process payment
        Order order = event.getOrder();

        // Process payment for the order
        System.out.println("Payment processed for order: " + order.getId());

        // Send email to the customer confirming the order
        System.out.println("Order confirmation email sent for order: " + order.getId());
    }
}

2. Kafka (See SpringBootKafka)

3. Spring Security Architecture
=======================================================

                UsernamePasswordAuthenticationToken (token)
                     2  ↑                       |3
                        |                       |
             1          |                       ↓
httpRequest ------> UsernamePasswordAuthenticationFilter ---->  AuthenticationManager ------> AuthenticationProvider ------> UserDetailsService (I)   >>>>>>  UserDetails
                                                                (authenticate(token))                                      (loadUserByUserName(userId))
    .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)                                                     |
                                                                                                                                | JWT Token
                                                                                                                                |
                                                                                                                                ↓
                                                                                                                        SecurityContext      -----------> returns JWT Token
                                                                                                                            (JWT Token)

AuthenticationFilter
-----------------------

<filter>
    <filter-name>springSecurityFilterChain</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>
<filter-mapping>
    <filter-name>springSecurityFilterChain</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>

        Servlet                                          ApplicationContext                         SpringSecurityFilterChains
   ----------------------                             ---------------------------------        -------------------------------------

    <filter-name>                                       <filter-name>                               SpringSecurityFilterChains 1
        springSecurityFilterChain                            springSecurityFilterChain                  -SpringSecurityFilter11
    </filter-name>                                      </filter-name>                                  -SpringSecurityFilter12
    <filter-class>                  ----------->        <filter-class>        --------->            SpringSecurityFilterChains 2
        DelegatingFilterProxy                               FilterChainProxy                            -SpringSecurityFilter21
    </filter-class>                                     </filter-class>                                 -SpringSecurityFilter22

@Bean FilterChainProxy :: is created by Spring automatically.
This FilterChainProxy contains a number of SecurityFilterChains and these SecurityFilterChains contain a number of filters.
Every request goes through this SecurityFilterChains.

 .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)


AuthenticationManager
-----------------------
authenticate(UsernamePasswordAuthenticationToken token) - delegates the request to a list of AuthenticationProviders which on successful login returns an Authentication object which is passed to the SecurityContext

UserDetailsService
-----------------------
Interface to retrieve the user’s authentication and authorization information
1 method - UserDetails loadUserByUserName(String userId);

UserDetails
-----------------------
Core class representing user details like principals, credentials, authorities

SecurityContext
-----------------------
Authentication and Authorization information of the user currently accessing the application.

SecurityContextHolder
-----------------------
Core class which holds the SecurityContext
SecurityContextHolder uses “ThreadLocal” variables to store the principal details.

ResponseEntity
-----------------------

return ResponseEntity
                    .status(HttpStatus.OK)
					.header("Custom-header", "value")
					.body(accountMaster);

return ResponseEntity
                .status(HttpStatus.OK)
				.cacheControl(CacheControl.maxAge(getCacheDuration()).noTransform().mustRevalidate())
				.header("test","test")
				.body(orderResponse);

/*
    must-revalidate :
        - Once the cache expires, get new response
        - If a response is cacheable for 10 seconds, then must-revalidate starts after 10 seconds

    no-cache :

 */

----------------------------------------------------------------------------------------------------------------------

Spring Boot Design Patterns
=======================================

1. REST (Synchronous Communication)
----------------------------------------
URI-based
Lightweight (rely on HTTP(s) which means it is format-agonistic, JSON ,XML, html can be used as the messaging format)
Stateless
Cacheable


2. API Gateway
-----------------------------------------
- Authentication
- Authorization
- Single Point of Entry
- Transformation
- Logging
- Caching
- Encryption
- Load Balancing
- Rate-limiting (DDoS Protection) (Distributed Denial-of-Service)

Problems
- Single point of failure - so put multiple APIGWs and a LoadBalancer in front
- Slower

Example : Orchis APIGW , Kong GW

APIGW has different subscription plans for each consumer that dictates the allowed RPS(Request per second) and the BL (Burst Load).

3. Load Balancing
---------------------------------------
Distributes incoming requests across multiple servers to improve performance, reliability, and availability

4. Service Discovery
-----------------------------
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {

	//Eureka server :: http://localhost:8761/
	public static void main(String[] args) {
		SpringApplication.run(EurekaServerApplication.class, args);
	}
}

eureka:
  client:
    registerWithEureka: true
@SpringBootApplication
@EnableDiscoveryClient
public class SpringConversionFactorApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringConversionFactorApplication.class, args);
	}

}

@Configuration
class WebClientConfig {

    @Bean
    WebClient.Builder webClientBuilder() {
        return WebClient.builder();
    }

}

//call this Eureka client from another service
 return webClientBuilder
                .build()
                .get()
                .uri("http://conversion-factor/eureka/v1/getConversionFactor/" + countryCode)
                .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToMono(String.class);

5. Client-side Load Balancing
----------------------------------
SpringCloud LoadBalancer :: calling EurekaClient in a Load-Balanced manner

@Configuration
public class ServiceInstanceConfig {

    @Bean
    public ServiceInstanceListSupplier serviceInstanceListSupplier(){
        return new ServiceInstanceSupplier("conversion-factor");
    }
}

@LoadBalancerClient(name = "conversion-factor", configuration = ServiceInstanceConfig.class)
@Configuration
class WebClientConfig {

    @LoadBalanced
    @Bean
    WebClient.Builder webClientBuilder() {
        return WebClient.builder();
    }

}

@RestController
public class NavigationController {

    @Autowired
    private WebClient.Builder webClientBuilder;

    //http://localhost:8071/getConversionFactorClient/AUD
    @GetMapping(value = "/getConversionFactorClient/{countryCode}", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<String> convertCurrency(@PathVariable("countryCode") String countryCode) {

    //call the Eureka client from another service in a load-balanced manner
        return webClientBuilder
                .build()
                .get()
                .uri("http://conversion-factor/eureka/v1/getConversionFactor/" + countryCode)
                .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToMono(String.class);


    }

}

6. Pub/Sub (Asynchronous Communication)
-----------------------------------------
Decouples message producers and consumers, improves scalability and flexibility.


7. Dependency Injection
-------------------------------
        - Objects define their dependencies through
          (IoC :: a generic term where framework calls library implementation instead of application)

        1.Field Injection:

            @Component
            public class MyService {

                @Autowired
                private MyRepository repository;  //does not allow final
            }

        2. Constructor Injection:

            @Component
            public class MyService {
                private final MyRepository repository;

                @Autowired
                public MyService(MyRepository repository) {
                    this.repository = repository;   //preferred :: All dependencies are provided at compile-time, improved testing
                }
            }

        3. Setter Injection :

            @Component
            public class MyService {
                private MyRepository repository;

                @Autowired
                public void setRepository(MyRepository repository) {
                    this.repository = repository;
                }
            }


8. Singleton
------------------
        -  1 instance in the ApplicationContext
        -  Spring-Managed-Beans are singleton by default
        -  Lifecycle managed by container

public class SingletonEx {

	private static volatile SingletonEx singletonEx = null;

	// prevent Object creation by Constructor
	private SingletonEx() {
		//do nothing
	}

	// prevent Object creation by Cloning
	@Override
	protected Object clone() throws CloneNotSupportedException {
		throw new CloneNotSupportedException();
	}

	// get Object instance by Double-check locking
	public static SingletonEx getInstance() {
		if (Objects.isNull(singletonEx)) {
			synchronized (SingletonEx.class) {
				if (Objects.isNull(singletonEx)) {
					singletonEx = new SingletonEx();
				}
			}
		}
		return singletonEx;
	}
}

9. Factory
---------------------------------------
 Factory will have all the objects whichever is needed at runtime will be provided

        public interface PaymentProvider {
            void acceptPayment();
        }


        @Service("GPayPayment") //service value
        public class GPayPayment implements PaymentProvider{

            @Override
            public void acceptPayment() {
                System.out.println("GPay payment...");
            }
        }

        @Service("WhatsAppPayment") //service value
        public class WhatsAppPayment implements PaymentProvider{

            @Override
            public void acceptPayment() {
                System.out.println("WhatsApp payment...");
            }
        }


        @Service
        @AllArgsConstructor
        public class PaymentFactory {
            public Map<String, PaymentProvider> paymentProviderMap;

            public PaymentProvider getPayment(String paymentProviderType) {
                return paymentProviderMap.get(paymentProviderType);
            }

        }

        @SpringBootApplication
        public class SpringBootRest2Application implements CommandLineRunner {

            @Autowired
            private PaymentFactory paymentFactory;

            public static void main(String[] args) {
                SpringApplication.run(SpringBootRest2Application.class, args);
            }

            @Override
            public void run(String... args) throws Exception {
                WhatsAppPayment whatsAppPayment = (WhatsAppPayment) paymentFactory.getPayment("WhatsAppPayment");
                whatsAppPayment.acceptPayment();    //WhatsApp payment...
                GPayPayment gPayPayment = (GPayPayment) paymentFactory.getPayment("GPayPayment");
                gPayPayment.acceptPayment();         //GPay payment...
            }
        }



10. Builder Design pattern
-------------------------------
        - @Builder
        User user = User.builder()
                        .username("john_doe")
                        .email("john@example.com")
                        .age(30)
                        .build();

11. Proxy Design pattern (Sidecar)
-----------------------------
        - AOP framework to apply cross-cutting concerns to components without modifying their core logic

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>

Aspect :: module for cross-cutting-concerns
          This allows to centralize cross-cutting logic in one place and keep your custom components focused on their specific business logic
Advice :: action taken by an Aspect at a particular Joinpoint ("before", "after", "around")
Pointcut :: expression that selects one or more JoinPoints where Advice is executed.
JoinPoint :: method where Aspect gets plugged-in


12. Backend for Frontend
--------------------------------------------
Separate APIGWs for separate types of client

    Clients                 BFF                 Services
    ---------           -----------             ------------

    Web                   Web API GW             Authentication / Authorization

    Mobile                Mobile API GW          Service A

    Other clients         Other API GW           Service B

-optimised
-scalable

13. Command Query Responsibility Segregation (CQRS)
---------------------------------------------------------------------------

Separates Commands(write to Database) from Queries(reading from Database) into separate services
-auditing
-scalable


14. Circuit Breaker
---------------------------------------------------------------------------


                                    Count-based / Time-based          Count-based / Time-based
                    CLOSED     ------------------>     HALF-OPEN      ------------------>       OPEN
                 (success)                                             ( fallback )
                            <-----------------------------------------------------------
                                            (reset breaker)
<!-- Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

<!-- AOP -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>

<!-- Resilience -->
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot3</artifactId>
    <version>2.0.2</version>
</dependency>


resilience4j:
  circuitbreaker:
    instances:
      getMoviesOfDirector_CB:
        register-health-indicator: true
        sliding-window-type: count_based
        sliding-window-size: 10
        failure-rate-threshold: 70 #Circuitbreaker will open if 70% of the last 10 calls failed
        slow-call-rate-threshold: 40
        slow-call-duration-threshold: 2s
        permitted-number-of-calls-in-half-open-state: 1
        max-wait-duration-in-half-open-state: 10s
        wait-duration-in-open-state: 10s
        writable-stack-trace-enabled: true
        automatic-transition-from-open-to-half-open-enabled: true

@GetMapping(value = "/getMoviesOfDirector", produces = MediaType.APPLICATION_JSON_VALUE)
@SneakyThrows
@Logging
@CircuitBreaker(name = "getMoviesOfDirector_CB",fallbackMethod = "getDummyValue")
@RateLimiter(name = "basic")
@Bulkhead(name = "serviceA", fallbackMethod = "getDummyValue")
public List<Movie> getMoviesOfDirector(
        @RequestParam(value = "director") String director) {
    director = director.replaceAll(" ", "%20");

    //Endpoint
    String endpoint = "http://localhost:9050/orders/v1/getMoviesOfDirector/" + director;
    URI uri = new URI(endpoint);

    return restClientService.getMoviesOfDirector(uri, director);
}

public List<Movie> getDummyValue(Exception exception){
    List<Movie> list = new ArrayList<>();
    Movie movie = new Movie();
    movie.setMovieId(100);
    movie.setMovieName("someName");
    list.add(movie);
    return list;
}

15. Rate-limiter
---------------------------------------------------------------------------

resilience4j:
  ratelimiter:
      instances:
        basic:
          limitForPeriod: 2
          limitRefreshPeriod: 1s # 2RPS
          timeoutDuration: 10s     #time to acquire permission from RateLimiter before erroring out.

@GetMapping(value = "/getMoviesOfDirector", produces = MediaType.APPLICATION_JSON_VALUE)
@SneakyThrows
@Logging
@CircuitBreaker(name = "getMoviesOfDirector_CB",fallbackMethod = "getDummyValue")
@RateLimiter(name = "basic")
@Bulkhead(name = "serviceA", fallbackMethod = "getDummyValue")
public List<Movie> getMoviesOfDirector(
        @RequestParam(value = "director") String director) {
    director = director.replaceAll(" ", "%20");

    //Endpoint
    String endpoint = "http://localhost:9050/orders/v1/getMoviesOfDirector/" + director;
    URI uri = new URI(endpoint);

    return restClientService.getMoviesOfDirector(uri, director);
}

16. Bulkhead
---------------------------------------------------------------------------
Latency in one service should not migrate to the whole system

resilience4j:
   bulkhead:
     instances:
       serviceA:
         maxConcurrentCalls: 1

@GetMapping(value = "/getMoviesOfDirector", produces = MediaType.APPLICATION_JSON_VALUE)
@SneakyThrows
@Logging
@CircuitBreaker(name = "getMoviesOfDirector_CB",fallbackMethod = "getDummyValue")
@RateLimiter(name = "basic")
@Bulkhead(name = "serviceA", fallbackMethod = "getDummyValue")
public List<Movie> getMoviesOfDirector(
        @RequestParam(value = "director") String director) {
    director = director.replaceAll(" ", "%20");

    //Endpoint
    String endpoint = "http://localhost:9050/orders/v1/getMoviesOfDirector/" + director;
    URI uri = new URI(endpoint);

    return restClientService.getMoviesOfDirector(uri, director);
}

public List<Movie> getDummyValue(Exception exception){
    List<Movie> list = new ArrayList<>();
    Movie movie = new Movie();
    movie.setMovieId(100);
    movie.setMovieName("someName");
    list.add(movie);
    return list;
}

17. Event Sourcing
---------------------------------------------------------------------------
Event logs
- auditing
- analytics


18. Strangler pattern
---------------------------------------------------------------------------
Design pattern that incrementally transforms the monolithic application to microservice by replacing a particular functionality with a new service.
Once the new functionality is ready, the old component is decommissioned.
Candidate for Test-Driven Development


19. 2-phase commit (2PC)
-----------------------------------------------
Immediate Transactions
Commit or rollback entire transaction

Phase1 : Prepare
                                   Service 1
                                    | C?  |
                                    |      | Y/N        C?
          Client   --------------> Controller   ----------->        Service 2
                                    |     |     <-----------
                                 C? |     | Y/N            Y/N
                                  Service 3

Phase2 : Commit

                         Service 1
                                  | C/R  |
                                  |      | +/-        C/R
        Client   --------------> Controller   ----------->        Service 2
                                  |     |     <-----------
                               C/R|     | +/-           +/-
                                Service 3


20. Saga
---------------------------------------------------------------------------
Distributed Transactions
Every transaction has a Rollback action
-more scalable than 2PC


CHOREOGRAPHY
----------------------

    Order service ----------> Payment service -------> Catering service  ---------> Delivery service
                <--------------------->
                <--------------------------------------------->
                <-------------------------------------------------------------------------->


ORCHESTRATION
----------------------

        Order service               Payment service       Catering service      Delivery service
            \   \ (4)           /         /               /               /       /           /
             \   \           /         /            /               /       /           /
              \   \         /         /         /           /           /           /
               Orchestrator


-------------------------------------------------------------------------------------------------

Anti-Patterns
===========================================

1. Choose Constructor Injection
2. Avoid 1 Controller if too many endpoints
3. Constant Interface

---------------------------------------------------------------------------------------------------------------------------

Spring Boot Optimizations
=============================

Identifying Bottlenecks :: Latency, CPU Usage, DB Usage

1. Asynchronous
2. Caching (Caffeine -> Redis -> DB)

	( JPA Optimizations )
3. Table Indexing
	@Entity
        @Table(name = "BOOK", indexes = {@Index(name = "book_index", columnList = "book_id")})

	CREATE INDEX idx_data_field ON data_table (field_name);

4. JPA Query

5. Batch Processing
        saveAll(list)
        deleteInBatch(list)

6. Lazy Loading
        @OneToMany(cascade = CascadeType.MERGE, mappedBy = "author" , fetch = FetchType.LAZY)
        private List<Book> bookList;

        @ManyToOne(cascade = CascadeType.MERGE, fetch = FetchType.EAGER)
        @JoinColumn(name = "author_id")
        private Author author;
7. @Transactional
8. DTO projection
9. N+1
10. Hikari Connection Pool
11. Streaming

12. JSON Schema validation
13. GZIP large request
14. Resilience4J : Circuit Breaker and Rate Limiter

15. Kafka
16. Sharding with MongoDB or Cassandra
	- Each shard holds a portion of the data
	- Horizontal Scaling


-------------------------------------------------------------------------------------------------

SpringBoot3 changes
===========================================================

1. 	<version>3.2.7</version>
	<java.version>21</java.version>
	<spring-cloud.version>2023.0.0</spring-cloud.version>
	<openapi.version>2.2.0</openapi.version>

2. <!--Lombok-->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.30</version>
    <scope>provided</scope>
</dependency>

3. javax.persistence -> jakarta.persistence

4. JSONB ->  @Type(JsonBinaryType.class)

5. Security ->

6. Observability -> 

7. jaxb-api -> 

	    <groupId>javax.xml.bind</groupId>
            <artifactId>jaxb-api</artifactId>			is replaced with
            
	    <groupId>jakarta.xml.bind</groupId>
            <artifactId>jakarta.xml.bind-api</artifactId>

8. Swagger -> 

	    <dependency>
            <groupId>org.springdoc</groupId>
            	<artifactId>springdoc-openapi-webmvc-core</artifactId>
            <artifactId>springdoc-openapi-starter-webmvc-api</artifactId>
            <version>${openapi.version}</version>
        </dependency>

9. Tests -> 	@MockBean 		is replaced with 

		        @Mock

ApplicationConfig
========================

@Configuration
public class ApplicationConfig {

    //TomcatProtocolHandler is responsible for handling incoming requests in a Spring Boot application
    //TomcatProtocolHandlerCustomizer configures the Executor
    //Executor is responsible for executing tasks, like handling incoming requests
    //Virtual Threads
    @Bean
    TomcatProtocolHandlerCustomizer<?> tomcatProtocolHandlerCustomizer() {
        return tomcatProtocolHandlerCustomizer -> {
            tomcatProtocolHandlerCustomizer.setExecutor(Executors.newVirtualThreadPerTaskExecutor()); //executor service that creates a new Virtual Thread for each task submitted to it
        };
    }

    // Monitoring beans
    @Bean
    ObservationRegistry observationRegistry() {
        return ObservationRegistry.create();
    }

    // To have the @Observed support we need to register this aspect
    @Bean
    ObservedAspect observedAspect(ObservationRegistry observationRegistry) {
        return new ObservedAspect(observationRegistry);
    }
}
---------------------------------------------------------------------------------------------------------
Spring Boot 3 Secured Endpoint
---------------------------------
1. pom
<!-- Web -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!-- Spring Security -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<!-- JWT -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>

<!-- jaxb -->
<dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>
    <version>2.3.0</version>
</dependency>

//2. Secured endpoint
// http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray
// Authorization
// Type     -> Bearer Token
// Token    -> eyJhbGciOiJIUzUxMiJ9...
// JWT Token is in the form of Bearer Token
@GetMapping(value = "/getMoviesOfDirector/{director}", produces = MediaType.APPLICATION_JSON_VALUE)
public ResponseEntity<List<Movie>> getMoviesOfDirector(
        @PathVariable("director") String director) {
    Span span = jaegerTracer.buildSpan("getMoviesOfDirector").start();
    log.info("Inside getMoviesOfDirector controller... ");

    //Counter metric
    Counter counter = Counter.builder("getMoviesOfDirector")
            .description("a number of requests to /getMoviesOfDirector endpoint")
            .register(meterRegistry);
    counter.increment();

    //Timer metric
    Timer.Sample timer = Timer.start(meterRegistry);
    Span getHeroDetailsSpan = jaegerTracer.buildSpan("getMoviesOfDirector-Service").asChildOf(span).start();
    List<Movie> movies = movieService.getMoviesOfDirector(director);
    getHeroDetailsSpan.finish();
    span.finish();
    timer.stop(Timer.builder("getMoviesOfDirector_Timer").register(meterRegistry));

    //Observation API
    Observation.createNotStarted("getMoviesOfDirector_Count", observationRegistry)
            .lowCardinalityKeyValue("request-uid", String.valueOf(new Random().nextInt(100)))
            .observe(() -> {
                List<Movie> movies2 = movieService.getMoviesOfDirector(director);
                log.debug("Counting getMoviesOfDirector");
            });

    return ResponseEntity.ok(movies);
}

So to hit this endpoint from Postman, first get the JWT Token from the Auth-Server and pass the JWT token as Bearer token in the endpoint

3. Authentication endpoint
================================
//http://localhost:9100/v3/rest/authenticate
/*
    {
    "userId":"eyabhikg",
    "password":"12345"
    }
 */
//var jsonData = JSON.parse(responseBody);
//pm.environment.set("SB3_BEARER_TOKEN", jsonData['jwt']);
@PostMapping("/authenticate")
public AuthenticationResponse authenticate(@RequestBody Map<String, Object> claims){

    try {
        log.info("In authenticate method...");
        authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(claims.get("userId"), claims.get("password")));
    } catch (Exception e) {
        log.error("Authentication Error.......");
        throw new OrderException("101", "Invalid username or password", HttpStatus.BAD_REQUEST);
    }

    UserDetails userDetails = userService.loadUserByUsername(String.valueOf(claims.get("userId")));
    String jwt = jwtTokenUtil.generateToken(userDetails);
    return ResponseEntity
            .status(HttpStatus.OK)
            .body(new AuthenticationResponse(userDetails.getUsername(), userDetails.getAuthorities().stream().map(String::valueOf).toList().getFirst(), jwt))
            .getBody();

}


4. JWTTokenUtil
----------------------
// generate JWT token for user
public String generateToken(UserDetails userDetails) {
    Map<String, Object> claims = new HashMap<>();

    claims.put("client_id",userDetails.getUsername());
    claims.put("client_secret","3333");
    claims.put("subject","devtest");
    claims.put("scope","user");
    claims.put("issuer","application");

    return Jwts.builder()
            .setClaims(claims)
            .setSubject(userDetails.getUsername())
            .setIssuedAt(new Date(System.currentTimeMillis()))
            .setExpiration(new Date(System.currentTimeMillis()  + expirationInMillis))
            .signWith(SignatureAlgorithm.HS512, secret)
        .compact();
}

5. SecurityConfig
----------------------

@Configuration
@EnableWebSecurity
public class SecurityConfig {

   @Value("${application.spring.endpoints.exclude}")
   private String[] applicationApisToBeExcluded;

    @Value("${service.endpoints.exclude:}")
    private String[] serviceApisToBeExcluded;

    @Autowired
    private UserService userService;

    @Autowired
    private JWTFilter jwtFilter;

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userService);
        authProvider.setPasswordEncoder(new BCryptPasswordEncoder());
        return authProvider;
    }

    private String[] allApisToBeExcluded(){
        return applicationApisToBeExcluded;

        /* return Stream.of(applicationApisToBeExcluded, serviceApisToBeExcluded)
                .flatMap(Stream::of)
                .toArray(String[]::new);*/
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {
        return httpSecurity
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(requests -> requests.requestMatchers(allApisToBeExcluded()).permitAll().anyRequest().authenticated())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }
}


6. JWT Filter
-----------------------

@Component
public class JWTFilter extends OncePerRequestFilter {

    @Autowired
    private JWTTokenUtil jwtTokenUtil;

    @Autowired
    private UserService userService;

    // Intercept each request ,extract the JWT from the Request header ,validate and put the JWT in the SecurityContext
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        try {
            //gets the Authorization header
            String bearerToken = request.getHeader("Authorization");
            if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {

                // JWT Token is in the form of Bearer Token
                // Authorization  :: Bearer dkdllslsl
                String jwtToken = bearerToken.substring(7);
                String username = jwtTokenUtil.getUsernameFromToken(jwtToken);

                if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {

                    UserDetails userDetails = userService.loadUserByUsername(username);
                    if (jwtTokenUtil.validateToken(jwtToken, userDetails)) {

                        //UsernamePasswordAuthenticationToken(Object principal, Object credentials, Collection<? extends GrantedAuthority> authorities)
                        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(
                                userDetails, null, userDetails.getAuthorities());
                        usernamePasswordAuthenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                        SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);
                    }
                }

            }
        }catch (ExpiredJwtException ex){

        }
        filterChain.doFilter(request, response);
    }


}


7. Service  (implementing UserDetailsService)
----------------------------------------------

@Service
public class UserService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private AccountRepository accountRepository;

    @Override
    public UserDetails loadUserByUsername(String userId) throws UsernameNotFoundException {
        UserMaster userMaster = userRepository.findByUserId(userId);

        if (userMaster == null) {
            System.out.println("User not found");
            throw new UsernameNotFoundException("User not found");
        }

        return
                User
                    .builder()
                    .username(userMaster.getUserId())
                    .password(userMaster.getPassword())
                    .roles(userMaster.getRoleCode())
                    .build();

    }

}

----------------------------------------------------------------------------------------------------------------------
Spring Boot 3 Secured Endpoint client
-------------------------------------------

@Configuration
public class RestClientConfig {

    @Bean(name = "restClient1")
    public RestClient restClient() {
        return RestClient
                .builder()
                .baseUrl("http://localhost:9100/v3/rest")
                .defaultHeader(HttpHeaders.CONTENT_ENCODING,"gzip")
                .defaultHeader(HttpHeaders.ACCEPT_ENCODING,"gzip")
                .build();
    }

}

@Autowired
@Qualifier("restClient1")
private RestClient restClient;

public List<Movie> getMoviesOfDirectorClient(String director) {
    HttpHeaders httpHeaders = new HttpHeaders();
    httpHeaders.set("Authorization","Bearer " + getJWTToken());
    return
            restClient
                .get()
                .uri("/getMoviesOfDirector/" + director)
                .headers(headers -> headers.addAll(httpHeaders))
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .body(new ParameterizedTypeReference<>() {});
}

private String getJWTToken() {
    Map<String, Object> claims = new HashMap<>();
    claims.put("userId","eyabhikg");
    claims.put("password", "12345");

    String jwt =
            Objects.requireNonNull(restClient
                                    .post()
                                    .uri("/authenticate")
                                    .contentType(MediaType.APPLICATION_JSON)
                                    .accept(MediaType.APPLICATION_JSON)
                                    .body(claims)
                                    .retrieve()
                                    .body(AuthenticationResponse.class))
                    .getJwt();

    System.out.println("jwt - " + jwt);
    return
            jwt;
}

--------------------------------------------------------------------------------------------------------

ASync client
-------------------------------------------

@EnableAsync
@Configuration
public class ASyncConfig {

    @Bean
    public ThreadPoolTaskExecutor threadPoolTaskExecutor(){
        ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();
        threadPoolTaskExecutor.setMaxPoolSize(100);
        threadPoolTaskExecutor.setThreadNamePrefix("ASync-1");
        threadPoolTaskExecutor.initialize();
        return threadPoolTaskExecutor;
    }
}

@SneakyThrows
public HeroDetailsResponse getHeroDetailsASync(HeroDetailsRequest heroDetailsRequest) {
    HeroDetailsResponse heroDetailsResponse = new HeroDetailsResponse();
    List<Hero> heroList = new ArrayList<>();
    List<CompletableFuture<Hero>> cfs = heroDetailsRequest.getHeroNames().stream().map(this::getHeroDetails).toList();
    //join all the CFs
    CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0])).join();
    //get the results from each of the CF
    for(CompletableFuture<Hero> completableFuture : cfs){
        if(completableFuture.isDone()){
            heroList.add(completableFuture.get());
        }
    }
    heroDetailsResponse.setHeroList(heroList);
    return heroDetailsResponse;
}

@Async(value = "threadPoolTaskExecutor")
private CompletableFuture<Hero> getHeroDetails(String heroName) {
    System.out.println("ASync Thread :: " + Thread.currentThread().getName());
    Hero hero = restClient2
                .get()
                .uri("/getHeroDetails/"+heroName)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .body(Hero.class);
    return CompletableFuture.completedFuture(hero);
}

External services but may experience intermittent failures or downtime
------------------------------------------------------------------------------

Retry / Circuit-Breaker

Retry is when the failure is expected to be short-lived
Circuit-Breaker is when the failure is expected to be long-lived as the connection will be broken

Spring Retry
----------------

<!-- Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<!-- AOP -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
<!-- spring-retry -->
<dependency>
    <groupId>org.springframework.retry</groupId>
    <artifactId>spring-retry</artifactId>
    <version>1.3.2</version>
</dependency>


@EnableRetry

@SneakyThrows
@Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 3))
public HeroDetailsResponse getHeroDetailsASync(HeroDetailsRequest heroDetailsRequest) {
    HeroDetailsResponse heroDetailsResponse = new HeroDetailsResponse();
    List<Hero> heroList = new ArrayList<>();
    List<CompletableFuture<Hero>> cfs = heroDetailsRequest.getHeroNames().stream().map(this::getHeroDetails).toList();
    //join all the CFs
    CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0])).join();
    //get the results from each of the CF
    for(CompletableFuture<Hero> completableFuture : cfs){
        if(completableFuture.isDone()){
            heroList.add(completableFuture.get());
        }
    }
    heroDetailsResponse.setHeroList(heroList);
    return heroDetailsResponse;
}

@Async(value = "threadPoolTaskExecutor")
private CompletableFuture<Hero> getHeroDetails(String heroName) {
    if (Objects.nonNull(RetrySynchronizationManager.getContext()) && RetrySynchronizationManager.getContext().getRetryCount() > 0) {
        System.out.println(String.format("Retry count %d for service %s", RetrySynchronizationManager.getContext().getRetryCount(), "getHeroDetails"));
    }
    Hero hero = restClient2
                .get()
                .uri("/getHeroDetails/"+heroName)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .body(Hero.class);
    return CompletableFuture.completedFuture(hero);
}

@Recover
public HeroDetailsResponse defaultGetHeroDetails(Exception exception){
    return new HeroDetailsResponse();
}

Circuit-Breaker
--------------------

<!-- Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<!-- AOP -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
<!-- Resilience -->
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot3</artifactId>
    <version>2.0.2</version>
</dependency>


resilience4j:
  circuitbreaker:
    instances:
      getHeroDetails_CB:
        register-health-indicator: true
        sliding-window-type: count_based
        sliding-window-size: 10
        failure-rate-threshold: 70 #Circuitbreaker will open if 70% of the last 10 calls failed
        slow-call-rate-threshold: 40
        slow-call-duration-threshold: 2s
        permitted-number-of-calls-in-half-open-state: 1
        max-wait-duration-in-half-open-state: 10s
        wait-duration-in-open-state: 10s
        writable-stack-trace-enabled: true
        automatic-transition-from-open-to-half-open-enabled: true


@SneakyThrows
//@Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 3))
@CircuitBreaker(name = "getHeroDetails_CB", fallbackMethod = "getDummyMethod")
public HeroDetailsResponse getHeroDetailsASync(HeroDetailsRequest heroDetailsRequest) {
    HeroDetailsResponse heroDetailsResponse = new HeroDetailsResponse();
    List<Hero> heroList = new ArrayList<>();
    List<CompletableFuture<Hero>> cfs = heroDetailsRequest.getHeroNames().stream().map(this::getHeroDetails).toList();
    //join all the CFs
    CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0])).join();
    //get the results from each of the CF
    for(CompletableFuture<Hero> completableFuture : cfs){
        if(completableFuture.isDone()){
            heroList.add(completableFuture.get());
        }
    }
    heroDetailsResponse.setHeroList(heroList);
    return heroDetailsResponse;
}

@Recover
public HeroDetailsResponse defaultGetHeroDetails(Exception exception){
    return new HeroDetailsResponse();
}

public HeroDetailsResponse getDummyMethod(Exception exception){
    System.out.println("In circuit-breaker fallback...");
    return new HeroDetailsResponse();
}

management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: always
  health:
    circuitbreakers:
      enabled: true

http://localhost:9101/actuator/health

--------------------------------------------------------------------------------------------------------
Exception Handler
---------------------

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(OrderException.class)
    public ResponseEntity<ErrorResponse> handleOrderException(OrderException oe) {
        ErrorResponse errorResponse = new ErrorResponse(oe.getErrorCode(), oe.getErrorMessage(), oe.getHttpStatus());
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(errorResponse);
    }

    @ExceptionHandler(SPEException.class)
    public ResponseEntity<ErrorCodeProperties> handleSPEException(SPEException speException) {
        ErrorCodeProperties errorCodeProperties = new ErrorCodeProperties(speException.getGroup(),
                                                                          speException.getType(),
                                                                          speException.getMessage(),
                                                                          speException.getInfoMessage(),
                                                                          speException.getHttpStatus());
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(errorCodeProperties);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleMethodArgumentNotValidException(MethodArgumentNotValidException me) {
        String errorMessage = "Error in object '%s', error in field '%s', error is '%s'";
        FieldError fieldError = me.getBindingResult().getFieldError();
        errorMessage = String.format(errorMessage, fieldError.getObjectName(), fieldError.getField(), fieldError.getDefaultMessage());
        ErrorResponse errorResponse = new ErrorResponse("101", errorMessage, HttpStatus.BAD_REQUEST);
        return ResponseEntity
                .badRequest()
                .body(errorResponse);
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorResponse> handleDataIntegrityViolationException(DataIntegrityViolationException de){
        String errorMessage  = de.getMostSpecificCause().getMessage();
        ErrorResponse errorResponse = new ErrorResponse("401", errorMessage, HttpStatus.BAD_REQUEST);
        return ResponseEntity
                .badRequest()
                .body(errorResponse);
    }

}

@SpringBootApplication
@EncryptablePropertySource("classpath:errorMessages_en.properties")
public class SpringBootRest3Application {

	public static void main(String[] args) {
		SpringApplication.run(SpringBootRest3Application.class, args);
	}

}

error.message.validation.itemMismatch = Item does not match
error.message.validation.itemTypeMismatch = Item Type does not match
error.message.dataConnection.itemAndItemTypeMismatch = Item and Item type mismatch

error.infomessage.validation.itemMismatch = Item does not match for %1s
error.infomessage.validation.itemTypeMismatch = Item Type does not match for %1s
error.infomessage.dataConnection.itemAndItemTypeMismatch = Item and Item type mismatch for %1s:%2s



@Configuration
@ConfigurationProperties(prefix = "error.message")
@Data
@Validated
public class ErrorMessageProperties {

    @Valid
    private final ErrorMessageProperties.Validation validation = new ErrorMessageProperties.Validation();

    @Valid
    private final ErrorMessageProperties.DataConnection dataConnection = new ErrorMessageProperties.DataConnection();

    @Data
    public static class Validation {
        @NotNull
        private String itemMismatch;
        @NotNull
        private String itemTypeMismatch;
    }

    @Data
    public static class DataConnection {
        @NotNull
        private String itemAndItemTypeMismatch;

    }
}


@Configuration
@ConfigurationProperties(prefix = "error.infomessage")
@Data
public class ErrorInfoMessageProperties {

    @Valid
    private final ErrorInfoMessageProperties.Validation validation = new ErrorInfoMessageProperties.Validation();

    @Valid
    private final ErrorInfoMessageProperties.DataConnection dataConnection = new ErrorInfoMessageProperties.DataConnection();

    @Data
    public static class Validation {
        @NotNull
        private String itemMismatch;
        @NotNull
        private String itemTypeMismatch;
    }

    @Data
    public static class DataConnection {
        @NotNull
        private String itemAndItemTypeMismatch;
    }
}



@Component
public class ErrorProperties {

    private final Map<ErrorCode, ErrorCodeProperties> errorPropertiesMap;

    public ErrorProperties(ErrorMessageProperties errorMessageProperties,
                           ErrorInfoMessageProperties errorInfoMessageProperties) {

        errorPropertiesMap = new EnumMap<>(ErrorCode.class);

        errorPropertiesMap.put(ErrorCode.INVALID_ITEM,
                new ErrorCodeProperties(Group.CONFIGURATION_ERROR,
                        Type.CART_VALIDATION_ERROR,
                        errorMessageProperties.getValidation().getItemMismatch(),
                        errorInfoMessageProperties.getValidation().getItemMismatch(),
                        HttpStatus.BAD_REQUEST));

        errorPropertiesMap.put(ErrorCode.INVALID_ITEM_TYPE,
                new ErrorCodeProperties(Group.CONFIGURATION_ERROR,
                        Type.CART_VALIDATION_ERROR,
                        errorMessageProperties.getValidation().getItemTypeMismatch(),
                        errorInfoMessageProperties.getValidation().getItemTypeMismatch(),
                        HttpStatus.BAD_REQUEST));

        errorPropertiesMap.put(ErrorCode.INVALID_ITEM_ITEM_TYPE_MISMATCH,
                new ErrorCodeProperties(Group.CONFIGURATION_ERROR,
                        Type.CART_VALIDATION_ERROR,
                        errorMessageProperties.getDataConnection().getItemAndItemTypeMismatch(),
                        errorInfoMessageProperties.getDataConnection().getItemAndItemTypeMismatch(),
                        HttpStatus.BAD_REQUEST));
    }

    public enum ErrorCode {
        INVALID_ITEM,
        INVALID_ITEM_TYPE,
        INVALID_ITEM_ITEM_TYPE_MISMATCH
    }

    public enum Group {
        CONFIGURATION_ERROR
    }

    public enum Type {
        CART_VALIDATION_ERROR
    }

    public void throwSPEException(ErrorProperties.ErrorCode errorCode, List<String> errorInfo) {
        ErrorCodeProperties errorCodeProperties = errorPropertiesMap.get(errorCode);
        throw new SPEException(errorCodeProperties.getGroup(),
                            errorCodeProperties.getType(),
                            errorCodeProperties.getMessage(),
                            CollectionUtils.isEmpty(errorInfo)? errorCodeProperties.getInfoMessage(): String.format(errorCodeProperties.getInfoMessage(), errorInfo),
                            errorCodeProperties.getHttpStatus());
    }

}

if(!orderServiceUtil.allowedItems.contains(item)) {
    errorProperties.throwSPEException(ErrorProperties.ErrorCode.INVALID_ITEM, List.of(item));
}

--------------------------------------------------------------------------------------------------------


Rate-limiter
------------------

resilience4j:
  ratelimiter:
      instances:
        getHeroDetails_RL:
          limitForPeriod: 2
          limitRefreshPeriod: 1s # 2RPS
          timeoutDuration: 10s     #time to acquire permission from RateLimiter before erroring out.

@SneakyThrows
//@Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 3))
@CircuitBreaker(name = "getHeroDetails_CB", fallbackMethod = "getDummyMethod")
@RateLimiter(name = "getHeroDetails_RL")
public HeroDetailsResponse getHeroDetailsASync(HeroDetailsRequest heroDetailsRequest) {
    HeroDetailsResponse heroDetailsResponse = new HeroDetailsResponse();
    List<Hero> heroList = new ArrayList<>();
    List<CompletableFuture<Hero>> cfs = heroDetailsRequest.getHeroNames().stream().map(this::getHeroDetails).toList();
    //join all the CFs
    CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0])).join();
    //get the results from each of the CF
    for(CompletableFuture<Hero> completableFuture : cfs){
        if(completableFuture.isDone()){
            heroList.add(completableFuture.get());
        }
    }
    heroDetailsResponse.setHeroList(heroList);
    return heroDetailsResponse;
}

//429 Too Many Requests response
//Throttling allows to prioritize certain requests or users, ensuring a smoother experience for critical operations. 
   Rate limiting enforces uniform limits across all requests

--------------------------------------------------------------------------------------------------------

Latency in one service should not migrate to the whole system - check max concurrent calls
----------------------------------------------------------------------------------------------

Bulkhead pattern
---------------

resilience4j:
 bulkhead:
   instances:
     getHeroDetails_BH:
       maxConcurrentCalls: 1

@SneakyThrows
//@Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 3))
@CircuitBreaker(name = "getHeroDetails_CB", fallbackMethod = "getDummyMethod")
@RateLimiter(name = "getHeroDetails_RL")
@Bulkhead(name = "getHeroDetails_BH", fallbackMethod = "getDummyMethod")
public HeroDetailsResponse getHeroDetailsASync(HeroDetailsRequest heroDetailsRequest) {
    HeroDetailsResponse heroDetailsResponse = new HeroDetailsResponse();
    List<Hero> heroList = new ArrayList<>();
    List<CompletableFuture<Hero>> cfs = heroDetailsRequest.getHeroNames().stream().map(this::getHeroDetails).toList();
    //join all the CFs
    CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0])).join();
    //get the results from each of the CF
    for(CompletableFuture<Hero> completableFuture : cfs){
        if(completableFuture.isDone()){
            heroList.add(completableFuture.get());
        }
    }
    heroDetailsResponse.setHeroList(heroList);
    return heroDetailsResponse;
}

--------------------------------------------------------------------------------------------------------

Class Data Sharing (CDS)
==============================
Reduce startup time and memory consumption

1.Stores snapshot of the application classes in a archived file
2.Startup, JVM can refer this archive and get the class file, improving the class-loading time

spring.context.exit-on-refresh=true

-XX:ArchiveClassesAtExit=app-cds.jsa
# On the JVM you plan to deploy to:
java -Xshare:on -XX:SharedArchiveFile=app-cds.jsa -jar myapp.jar

GraalVM native image 
========================
Compiles the Java code into a standalone executable, eliminating the need for a JVM at runtime.

----------------------------------------------------------------------------------------------------------------------

Spring Observability
===============================================================================
Observability is the ability to measure the internal state of a system only by checking its outputs (logs, traces, metrics)
define our own metrics using Micrometer
gather them using Prometheus
display them on a Grafana dashboard


		    (exposes Metrics)    (collects + makes + ships Metrics)   (scrape Metrics)         (query Prometheus)
SpringBoot ------> Actuator  ---->   Micrometer   --------------->     Prometheus     ------>    Grafana
									  (Monitoring tool)         (Observability backend)

                                 (Prometheus to scrape Micrometer logs and Micrometer metrics at a configured interval from and endpoint and display them in a Grafana dashboard)


<!-- Web -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<!-- Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<!-- Micrometer-core -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-core</artifactId>
    <scope>runtime</scope>
</dependency>
<!-- Micrometer-prometheus -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
    <scope>runtime</scope>
</dependency>
<!-- AOP, for custom timer -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>

Actuator
===========================
Exposes metrics by exposing management endpoints - CPU usage, memory usage, request rate, error rate

http://localhost:9100/actuator
//health and info are auto-enabled

/health
/info
/env
/loggers
/httptrace
/sessions
/startup
/shutdown

management:
  endpoints:
    web:
      exposure:
        include: health, prometheus, metrics, info
  endpoint:
    health:
      show-details: always
    metrics:
      enabled: true
    prometheus:
      enabled: true // Exposes metrics in a format that can be scraped by a Prometheus server.
    info:
      java:
        enabled: true
      env:
        enabled: true
  tracing:
      sampling:
        probability: 1.0


Micrometer (replaces Spring Cloud Sleuth)
========================================================
collects metrics + own metrics + exports Metrics 
configures Spring Boot applications to expose metrics in a format that Prometheus can scrape and store.

Micrometer metrics::
-----------------------
Timer                                 measuring short-duration latencies, and the frequency of such events.
Counter				                  count
Gauge	                              current value
DistributionSummary	                  total amount of all recorded events
Micrometer Observation API            lightweight library for application metrics

//Counter metric
Counter counter = Counter.builder("getMoviesOfDirector")
                        .description("a number of requests to /getMoviesOfDirector endpoint")
                        .register(meterRegistry);
counter.increment();


Prometheus
=====================================
Monitoring tool
Prometheus needs an endpoint(metrics_path) to scrape Micrometer logs and Micrometer metrics at a configured interval and display them in a Grafana dashboard

prometheus.yml
------------------
scrape_configs:
  - job_name: 'SpringBootREST3'
    metrics_path: '/actuator/prometheus'
    scrape_interval: 5s
    static_configs:
      - targets: ['host.docker.internal:9100']
        labels:
          application: 'SpringBootREST3'

Hit http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray a few times

Check in Prometheus ::
            http://localhost:9100/actuator/prometheus

            # TYPE getMoviesOfDirector_total counter
            getMoviesOfDirector_total 7.0

General check in Prometheus UI:
    http://localhost:9090/ -> prometheus_http_requests_total

How does Prometheus that is running on Docker connect to SpringBoot app that is running on localhost?
---------------------------------------------------------------------------------------------------------------
- targets: ['host.docker.internal:9050']
  host.docker.internal is a host-gateway which is a daemon process routing requests to localhost

Behind the scenes, an observation has been created for the HTTP request, which in turn gets bridged to OpenTelemetry, which reports a new trace to Zipkin.

http://localhost:9090/
- Check Status -> Targets


Grafana
======================
Observability backend
Data Visualization service -  create dashboards to visualize and analyze data

http://localhost:3000/ (admin/Kolkata@123a)

Add your first datasource
Select Prometheus
Connect to Prometheus from Grafana :
    Get Prometheus container id
    Get Prometheus IP :
        docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' cd7c5f0de3ac
    - 172.22.0.2
    Prometheus URL in Grafana :: http://172.22.0.2:9090
    - Save and test
Add new Dashboard
    Datasource - Prometheus-1
    prometheus_http_requests_total

datasources.yml
----------------------
apiVersion: 1
datasources:
  - name: Prometheus
    type: prometheus
    access: proxy
    url: http://prometheus:9090
    isDefault: true

docker-compose-yml
--------------------------
version: '3.7'

services:
  prometheus:
    image: prom/prometheus:v2.44.0
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus.yml

  grafana:
    image: grafana/grafana:9.5.2
    container_name: grafana
    ports:
      - "3000:3000"
    restart: unless-stopped
    volumes:
      - ./datasources.yml:/etc/datasources.yml
    depends_on:
      - prometheus


Running all on Docker
-------------------------
Start the application
Start Docker Desktop (starts the Docker daemon)
Update docker-compose.yml with PR-GR
Run docker-compose.yml in Git bash :: cd  D:/workspace2/SpringBootREST3/src/main/resources
                                      docker-compose up --build
Open Gitbash another window::
            docker images //prometheus and grafana images
            docker ps     // All running containers

            docker stop $(docker ps -a -q) //Stop all running containers
            docker rm -f $(docker ps -a -q) //Docker remove all containers
            docker rmi -f $(docker images -q) //Docker remove all images

Hit http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray a few times

Check in Prometheus ::
            http://localhost:9100/actuator/prometheus

            # TYPE getMoviesOfDirector_total counter
            getMoviesOfDirector_total 7.0

Check in Grafana ::
            - see above

----------------------------------------------------------------------------------------------------------------------

Spring OpenTelemetry (replaces OpenTracing)
================================================
Observability framework for application monitoring by collecting Logs, Traces and Metrics 
vendor-agnostic

OTLP
-------
OpenTelemetry Protocol is a telemetry data transfer protocol that we can leverage to export the telemetry data to an observability backend.

        		  (exposes Metrics)  (collects + makes + ships Metrics)  (LTM  :: collection and shipment)
SpringBoot ------> Actuator  ---->   Micrometer    ----------------------->   OTel Collector       ------->           Jaeger (Observability Backend)
                                    (Monitoring tool)               micrometer-tracing-bridge-otel                  opentelemetry-exporter-otlp
pom.xml
-----------
<artifactId>spring-boot-starter-parent</artifactId>
<version>3.2.7</version>

<java.version>21</java.version>
		
<dependencies>
	    <!-- Web -->
	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-starter-web</artifactId>
	</dependency>
	<!-- Actuator -->
	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-starter-actuator</artifactId>
	</dependency>
	<!-- AOP, for custom timer -->
	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-starter-aop</artifactId>
	</dependency>
	<!-- Micrometer-core -->
	<dependency>
	    <groupId>io.micrometer</groupId>
	    <artifactId>micrometer-core</artifactId>
	    <version>1.11.6</version>
	</dependency>
	<!--Micrometer-OpenTelemetry bridge-->
	<dependency>
	    <groupId>io.micrometer</groupId>
	    <artifactId>micrometer-tracing-bridge-otel</artifactId>
	</dependency>
	<!--OpenTelemetry exporter-->
	<dependency>
	    <groupId>io.opentelemetry</groupId>
	    <artifactId>opentelemetry-exporter-otlp</artifactId>
	</dependency>
	<!--Jaeger-->
	<dependency>
	    <groupId>io.opentracing.contrib</groupId>
	    <artifactId>opentracing-spring-jaeger-web-starter</artifactId>
	    <version>3.3.1</version>
	</dependency>
	<!--Jaeger-remote-sampler-->
	<dependency>
	    <groupId>io.opentelemetry</groupId>
	    <artifactId>opentelemetry-sdk-extension-jaeger-remote-sampler</artifactId>
	</dependency>
</dependencies>
<dependencyManagement>
	<dependencies>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-dependencies</artifactId>
			<version>2023.0.0</version>
			<type>pom</type>
			<scope>import</scope>
		</dependency>
	</dependencies>
</dependencyManagement>

otel-config.yml
------------------

receivers:
  otlp:
    protocols:
      grpc:
      http:

processors:
  batch:

exporters:
  logging:
    loglevel: debug
  jaeger:
    endpoint: jaeger-service:14250
    tls:
      insecure: true

service:
  pipelines:
    traces:
      receivers:  [ otlp ]
      processors: [ batch ]
      exporters:  [ logging, jaeger ]

docker-compose.yaml
--------------------------
version: '3.7'

services:
  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686" # the jaeger UI
      - "4318:4318" # the OpenTelemetry collector http
    environment:
      - COLLECTOR_OTLP_ENABLED=true


application.yaml
----------------------------
spring:
  application:
    name: SpringBootREST3
  datasource:
    url: jdbc:postgresql://localhost:5432/springbootdb
    username: postgres
    password: tiger
    driver-class-name: org.postgresql.Driver
    hikari:
      connection-timeout: 5000
      maximum-pool-size: 5
  jpa:
    show-sql: true
    properties:
      hibernate:
        format-sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
  main:
    allow-bean-definition-overriding: true


logging:
  level:
    org:
      springframework:
        security: DEBUG
  pattern:
    level: '%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]'

server:
  port: 9100

management:
  endpoints:
    web:
      exposure:
        include: ["health","prometheus","metrics","info"]
  endpoint:
    health:
      show-details: always
    metrics:
      enabled: true
    prometheus:
      enabled: true
  info:
    java:
      enabled: true
    env:
      enabled: true
  tracing:
    sampling:
      probability: 1.0
  otlp:
    tracing:
      endpoint: http://localhost:4318/v1/traces

application:
  spring:
    endpoints:
      exclude: /v3/rest/hello, /v3/rest/helloPost, /v3/rest/home, /actuator/**, /v3/rest/getMoviesOfDirector/**, /v3/rest/getMoviesByDirectorAndGenre/**


opentracing:
  jaeger:
    enabled: true

Jaeger
--------------------------

@Configuration
@ConditionalOnProperty(value = "opentracing.jaeger.enabled", havingValue = "true")
public class JaegerConfig {

    @Bean
    public JaegerTracer jaegerTracer() {
        return new io.jaegertracing.Configuration("SpringBootREST3")
                .withSampler(new io.jaegertracing.Configuration.SamplerConfiguration().withType(ConstSampler.TYPE).withParam(1))
                .withReporter(new io.jaegertracing.Configuration.ReporterConfiguration().withLogSpans(true))
                .getTracer();
    }



}

@RestController
@RequestMapping("/v3/rest")
public class NavController {

    @Autowired
    private HomeService homeService;

    @Autowired
    private MovieService movieService;

    @Autowired
    private MeterRegistry meterRegistry;

    @Autowired
    private JaegerTracer jaegerTracer;

    Logger log = LoggerFactory.getLogger(NavController.class);

    // http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray
    @GetMapping(value = "/getMoviesOfDirector/{director}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<List<Movie>> getMoviesOfDirector(
            @PathVariable("director") String director) {
        Span span = jaegerTracer.buildSpan("getMoviesOfDirector").start();
        log.info("Inside getMoviesOfDirector controller... ");

        //Counter metric
        Counter counter = Counter.builder("getMoviesOfDirector")
                                .description("a number of requests to /getMoviesOfDirector endpoint")
                                .register(meterRegistry);
        counter.increment();

        //Timer metric
        Timer.Sample timer = Timer.start(meterRegistry);
        Span getHeroDetailsSpan = jaegerTracer.buildSpan("getMoviesOfDirector-Service").asChildOf(span).start();
        List<Movie> movies = movieService.getMoviesOfDirector(director);
        getHeroDetailsSpan.finish();
        span.finish();
        timer.stop(Timer.builder("getMoviesOfDirector_Timer").register(meterRegistry));

        //Observation API
        Observation.createNotStarted("getMoviesOfDirector_Count", observationRegistry)
                .lowCardinalityKeyValue("request-uid", String.valueOf(new Random().nextInt(100)))
                .observe(() -> {
                    List<Movie> movies2 = movieService.getMoviesOfDirector(director);
                    log.debug("Counting getMoviesOfDirector");
                });
        return ResponseEntity.ok(movies);
    }

}

logback.xml
---------------------
<?xml version="1.0" encoding="UTF-8"?>
<configuration>

    <property name="APP_LOG" value="logs/app.log"/>
    <property name="logging.file.name" value="info-log" />
    <property name="logging.file.path" value="./"/>
    <property name="logging.error.file.name" value="error-log" />
    <property name="logging.error.file.path" value="./"/>

    <!-- console log appender -->
    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="INFO">
        <appender-ref ref="console"/>
    </root>

</configuration>


Running all on Docker
-------------------------
Start the application
Start Docker Desktop
Update docker-compose.yml with OT-JG
Run docker-compose.yml in Git bash :: cd  D:/workspace2/SpringBootREST3/src/main/resources
                                      docker-compose up --build
Open Gitbash another window::
            docker images //otel and jaeger images
            docker ps     // All running containers

            docker stop $(docker ps -a -q) //Stop all running containers
            docker rm -f $(docker ps -a -q) //Docker remove all containers
            docker rmi -f $(docker images -q) //Docker remove all images

Hit http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray a few times

Check in Jaeger ::
           http://localhost:16686/search


-------------------------------------------------------------------------------------------------

OpenTelemetry                            vs                                     Prometheus
===================================================================================================
Logs, Traces and Metrics                                                        Metrics
More scalable
calculates delta                                                               calculates cumulative measurements as a total
Observation API for LTM and transform them into a single language

-------------------------------------------------------------------------------------------------

Jaeger
========================================
Observability backend
Components:
            Collector—collects trace data, validates and passes to storage service  (port :16686)
            Storage —Cassandra, ElasticSearch
            Web UI— view the trace data
            Search — on trace data

           [TraceId:SpanId:ParentSpanId:Flags]

Span reported: 4c5f29d379ea625e:3d177b55c210dffb:4c5f29d379ea625e:1 - PARENT

Span reported: 4c5f29d379ea625e:c1b1e7351ce66ca9:1d134091d2c206e7:1 - getHeroDetails            - CHILD
Span reported: 4c5f29d379ea625e:1d134091d2c206e7:7c1877ceb2c65cfa:1 - getMoviesOfHero
Span reported: 4c5f29d379ea625e:7c1877ceb2c65cfa:3d177b55c210dffb:1 - getMoviesOfHero   (PARENT SPAN ID = SPAN ID OF CALLER SERVICE)


Jaeger              vs                                Grafana                       vs              Zipkin
-------------------------------------------------------------------------------------------------------------------
Performance, Scalability, Reliability
part of the CNCF(Cloud Native Computing Foundation), so deployed in Kubernetes.
can be deployed in parts
Storage - ElasticSearch, Cassandra,Kafka            Local storage

------------------------------------------------------------------------------------------------------------------------------

OpenAPI Specification (OAS) { previously Swagger specification)
===========================================================================
REST API documentation specification for SpringBoot projects

<!--spring-boot-starter-validation -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
<!--Open API -->
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.2.0</version>
</dependency>
(Remove springfox-swagger2 and springfox-swagger-ui dependencies)

@AllArgsConstructor
@Getter
@Setter
@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonIgnoreProperties(ignoreUnknown = true)
public class Person {

    @JsonProperty
    @NotBlank
    @Size(min = 5, message = "First name must have at-least 5 chars")
    @Schema(description = "First name", example = "John")
    private String firstName;

    @JsonProperty
    @Schema(description = "Last name", example = "Doe")
    private String lastName;
}

@PostMapping(value = "/helloPost", produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE)
@ApiResponses({
        @ApiResponse(responseCode = "200", description = "Ok", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Person.class))),
        @ApiResponse(responseCode = "400", description = "Bad Request", content = @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class)))
})
public ResponseEntity<String> helloPost(@Valid @RequestBody Person person) {
    return ResponseEntity.status(HttpStatus.OK)
            .body(person.getFirstName().concat("----").concat(person.getLastName()));
}

http://localhost:9100/v3/api-docs (JSON)
http://localhost:9100/v3/api-docs.yaml (YAML)
Paste the yaml in Swagger Editor

@RestControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    @ExceptionHandler(OrderException.class)
    public ResponseEntity<ErrorResponse> handleOrderException(OrderException oe){
        ErrorResponse errorResponse = new ErrorResponse(oe.getErrorCode(), oe.getErrorMessage(), oe.getHttpStatus());
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(errorResponse);
    }

    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException exception, HttpHeaders headers, HttpStatusCode status, WebRequest request) {

        String errorMessage = "Error in object '%s', error in field '%s', error is '%s'";
        FieldError fieldError = exception.getBindingResult().getFieldError();
        errorMessage = String.format(errorMessage, fieldError.getObjectName(), fieldError.getField(), fieldError.getDefaultMessage());
        ErrorResponse errorResponse = new ErrorResponse("101", errorMessage, HttpStatus.BAD_REQUEST);
        return ResponseEntity
                .badRequest()
                .body(errorResponse);
    }
}

@Getter
@Setter
@AllArgsConstructor
public class ErrorResponse {

	@Schema(example = "101")
	private String errorCode;
	@Schema(example = "Error in object 'person', error in field 'firstName', error is 'First name must have at-least 5 chars'")
	private String errorMessage;
	@Schema(example = "BAD_REQUEST")
	private HttpStatus httpStatus;

}

------------------------------------------------------------------------------------------------------------------------------

Inserting data with ModelMapper
--------------------------------

<dependency>
    <groupId>org.modelmapper.extensions</groupId>
    <artifactId>modelmapper-spring</artifactId>
    <version>3.0.0</version>
</dependency>

CREATE TABLE MOVIE_NEW (
    movie_id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    movie_name VARCHAR(250) NOT NULL unique,
    director VARCHAR(250) NOT NULL,
    genre VARCHAR(250) NOT NULL,
	hero VARCHAR(250) NOT NULL,
	year VARCHAR(250) NOT NULL,
	national_award boolean NOT NULL
);


@Entity
@Table(name = "MOVIE_NEW")
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class MovieNew {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "movie_Id")
    private Integer movieId;

    @Column(name = "movie_Name")
    private String movieName;

}

@Repository
public interface MovieNewRepository extends JpaRepository<MovieNew, Integer> {
}

// http://localhost:9100/v3/rest/addMovie
@PostMapping(value = "/addMovie", produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE)
public MovieNew addMovie(@RequestBody MovieModel movieModel){
    ModelMapper modelMapper = new ModelMapper();
    modelMapper.getConfiguration().setDeepCopyEnabled(Boolean.TRUE);
    modelMapper.getConfiguration().setAmbiguityIgnored(Boolean.TRUE);
    modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT);

    MovieNew movieNew = modelMapper.map(movieModel, MovieNew.class);
    return movieService.addMovie(movieNew);

}


@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(OrderException.class)
    public ResponseEntity<ErrorResponse> handleOrderException(OrderException oe) {
        ErrorResponse errorResponse = new ErrorResponse(oe.getErrorCode(), oe.getErrorMessage(), oe.getHttpStatus());
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(errorResponse);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleMethodArgumentNotValidException(MethodArgumentNotValidException me) {
        String errorMessage = "Error in object '%s', error in field '%s', error is '%s'";
        FieldError fieldError = me.getBindingResult().getFieldError();
        errorMessage = String.format(errorMessage, fieldError.getObjectName(), fieldError.getField(), fieldError.getDefaultMessage());
        ErrorResponse errorResponse = new ErrorResponse("101", errorMessage, HttpStatus.BAD_REQUEST);
        return ResponseEntity
                .badRequest()
                .body(errorResponse);
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorResponse> handleDataIntegrityViolationException(DataIntegrityViolationException de){
        String errorMessage  = de.getMostSpecificCause().getMessage();
        ErrorResponse errorResponse = new ErrorResponse("401", errorMessage, HttpStatus.BAD_REQUEST);
        return ResponseEntity
                .badRequest()
                .body(errorResponse);
    }

}

//http://localhost:9100/v3/rest/addMovie
{
    "movieName": "Choto Boro boro 2",
    "director": "HAtim Tai",
    "genre": "HeheHaha",
    "hero": "Faltu",
    "year": "1999",
    "nationalAward": false
}

------------------------------------------------------------------------------------------------------------------------------

HTTP Headers
===============

Headers in HTTP Requests
------------------------------
Host : Server host and port to which the request is sent (80-http, 443-https)
User-Agent :  string that lets servers identify the application, operating system, vendor, and/or version of the requesting client
Accept : Client tells server the type of content client expects
Content-type : Client tell Server the request content type
Accept-Language : language settings for a user
Accept-Encoding : encoding algorithm
Cookie :: The main purpose of Session and Cookie is to make up for the stateless nature of HTTP.
          The server can use Session to store some operation records of the client during the same session.
          Session is stored on the server side, and sessionId will be stored in the Cookie of the client.
          How to determine whether it is the same session? Server sends Set-Cookie: JSESSIONID=XXX
                                                           Client further calls the Server with the same Cookie and session-id
          Disadvantage of Session : Server Load balancing will invalidate the session
          Session                                           vs                                  Token
          ------------------------------------------------------------------------------------------------------
          Connected to the machine(browser)                                         Connected to the user
                                                                                    Less space - no need to save session information
                                                                                    3rd party integration to send only Tokens

Referer : referring pages / where resources are kept
Authorization :
    // Bearer
    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

    // Basic
    Authorization: Basic base64(username:password)

    // API Key
    Authorization: ApiKey your-api-key

Headers in HTTP Response
---------------------------
Cache Control : (Cache-Control: max-age=3600, public)
Content-type : Server tell Client the response content type
Content Disposition : attachment , inline / download
Content-Length
Location : redirection
Set-Cookie : cookie gets set in Browser (Set-Cookie: sessionId=38afes7a8)

------------------------------------------------------------------------------------------------------------------------------

Caffeine
=====================
- 1st-level caching / In-memory caching (Data is stored in a single machine)

<!--Caffeine cache-->
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-cache</artifactId>
</dependency>

<dependency>
	<groupId>com.github.ben-manes.caffeine</groupId>
	<artifactId>caffeine</artifactId>
</dependency>

@Configuration
@EnableCaching
public class CaffeineConfig {

    public static final String HELLO_WORLD_CACHE = "helloWorldCache";
     public static final String BU_CACHE = "buCache";

    @Bean(name = "caffeine")
    public @NonNull Caffeine<Object, Object> caffeine(){
        return Caffeine
                .newBuilder()
                .initialCapacity(100)
                .maximumSize(2000)
                .expireAfterWrite(1, TimeUnit.HOURS);
    }

    @Bean
    public CaffeineCacheManager caffeineCacheManager(@Qualifier("caffeine") Caffeine caffeine) {
        CaffeineCacheManager caffeineCacheManager = new CaffeineCacheManager();
        caffeineCacheManager.setCaffeine(caffeine);
        caffeineCacheManager.setAllowNullValues(false);
        caffeineCacheManager.setCacheNames(List.of(HELLO_WORLD_CACHE, BU_CACHE));
        return caffeineCacheManager;
    }

}

Service
------------------
@Cacheable(key = "#buCode.concat('-').concat(#buType).concat('-').concat(#countryCode)", cacheManager = "caffeineCacheManager", cacheNames = CaffeineConfig.BU_CACHE, unless = "#result==null")
public Bucode getBuCode(String buCode, String buType, String countryCode) {
    //This method call will by default try to retrieve from the Caffeine cache based on the key, if not found will go into the method and will set by default
    System.out.println("Checking in Redis...");
    String key = buCode.concat("-").concat(buType).concat("-").concat(countryCode);
    Bucode bucode = (Bucode) buCodeRedisTemplate.opsForValue().get(key);
    System.out.println("Value in Redis :: " + bucode);
    if (Objects.isNull(bucode)) {
        System.out.println("Going to DB...");
        bucode = buRepository.findByBuCodeAndBuTypeAndCountryCode(buCode, buType, countryCode);

        //set in Redis
        buCodeRedisTemplate.opsForValue().set(key, bucode);
    }
    return bucode;
}

Service (Option 2)
---------------------

@Autowired
private CaffeineCacheManager caffeineCacheManager;

Cache.ValueWrapper valueWrapper = caffeineCacheManager.getCache(CaffeineConfig.HELLO_WORLD_CACHE).get(redisKey);
List<Movie> movies = (List<Movie>) Optional.ofNullable(valueWrapper).map(Cache.ValueWrapper::get).orElse(null);

---------------------------------------------------------------------------------------------



Redis
===============

- Distributed caching (Data is stored across multiple machines - for faster access and more data -
                    A distributed caching system combines the RAM of multiple computers into a single data store)
- High Availability

<!--Redis-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

<!--Apache commons, for Redis -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>

Run Redis
================
Run RedisServer.bat -> start "" E:\Softwares\Redis-x64-3.2.100\redis-server.exe
RedisInsight

monitor Cache Metrics
=============================
/actuator/metrics/cache.gets
/actuator/metrics/cache.puts
/actuator/metrics/cache.evictions
/actuator/metrics/cache.removals

spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=
spring.redis.timeout=60000
spring.redis.lettuce.pool.max-active=8
spring.redis.lettuce.pool.max-idle=8
spring.redis.lettuce.pool.max-wait=-1
spring.redis.lettuce.pool.min-idle=0

@Configuration
@EnableCaching
@EnableConfigurationProperties(RedisProperties.class)
public class RedisConfig {

    @Bean(name = "moviesCachedRedisTemplate")
    public RedisTemplate moviesCachedRedisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<String, Object>();
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }

}


Service
----------

@Autowired
@Qualifier("moviesCachedRedisTemplate")
private RedisTemplate redisTemplate;


// check in 1st Level cache (Caffeine), else check in 2nd Level cache (Redis)
// if not found hit service and put in cache
Cache.ValueWrapper valueWrapper = caffeineCacheManager.getCache(CaffeineConfig.HELLO_WORLD_CACHE).get(redisKey);
List<Movie> movies = (List<Movie>) Optional.ofNullable(valueWrapper).map(Cache.ValueWrapper::get).orElse(null);

if (CollectionUtils.isEmpty(movies)) {
    movies = (List<Movie>) redisTemplate.opsForValue().get(redisKey);
    log.info("Redis :: {}, transactionId  {} , movies {} ", "getMovieDetails", MDC.get("transactionId"), movies);

    if (CollectionUtils.isEmpty(movies)) {
        movies = restTemplate.exchange(uri, HttpMethod.GET, null, new ParameterizedTypeReference<List<Movie>>() {
        }).getBody();

        log.info("Service :: {}, transactionId  {} , movies {} ", "getMovieDetails", MDC.get("transactionId"), movies);

        //put in Caffeine - 1st level Cache
        caffeineCacheManager.getCache(CaffeineConfig.HELLO_WORLD_CACHE).put(redisKey, movies);

        //put in Redis - 2nd level Cache
        redisTemplate.opsForValue().set(redisKey, movies, Duration.ofMinutes(cacheItemExpireInMinutes));

	    //multiGet
	    //List<String> cacheKeys = getCacheKeys();
        //List<String> responseItems = redisTemplate.multiGet(cacheKeys);


    } else {
        caffeineCacheManager.getCache(CaffeineConfig.HELLO_WORLD_CACHE).put(redisKey, movies);
    }

}

---------------------------------------------------------------------------------------------

Redis
===============

- Distributed caching (Data is stored across multiple machines - for faster access and more data)

<!--Redis-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

<!--Apache commons, for Redis -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>

Run Redis
================
Run RedisServer.bat -> start "" E:\Softwares\Redis-x64-3.2.100\redis-server.exe
RedisInsight

monitor Cache Metrics
=============================
/actuator/metrics/cache.gets
/actuator/metrics/cache.puts
/actuator/metrics/cache.evictions
/actuator/metrics/cache.removals

spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=
spring.redis.timeout=60000
spring.redis.lettuce.pool.max-active=8
spring.redis.lettuce.pool.max-idle=8
spring.redis.lettuce.pool.max-wait=-1
spring.redis.lettuce.pool.min-idle=0

@Configuration
@EnableCaching
@EnableConfigurationProperties(RedisProperties.class)
public class RedisConfig {

    @Bean(name = "moviesCachedRedisTemplate")
    public RedisTemplate moviesCachedRedisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<String, Object>();
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }

}


Service
----------

@Autowired
@Qualifier("moviesCachedRedisTemplate")
private RedisTemplate redisTemplate;


// check in 1st Level cache (Caffeine), else check in 2nd Level cache (Redis)
// if not found hit service and put in cache
Cache.ValueWrapper valueWrapper = caffeineCacheManager.getCache(CaffeineConfig.HELLO_WORLD_CACHE).get(redisKey);
List<Movie> movies = (List<Movie>) Optional.ofNullable(valueWrapper).map(Cache.ValueWrapper::get).orElse(null);

if (CollectionUtils.isEmpty(movies)) {
    movies = (List<Movie>) redisTemplate.opsForValue().get(redisKey);
    log.info("Redis :: {}, transactionId  {} , movies {} ", "getMovieDetails", MDC.get("transactionId"), movies);

    if (CollectionUtils.isEmpty(movies)) {
        movies = restTemplate.exchange(uri, HttpMethod.GET, null, new ParameterizedTypeReference<List<Movie>>() {
        }).getBody();

        log.info("Service :: {}, transactionId  {} , movies {} ", "getMovieDetails", MDC.get("transactionId"), movies);

        //put in Caffeine - 1st level Cache
        caffeineCacheManager.getCache(CaffeineConfig.HELLO_WORLD_CACHE).put(redisKey, movies);

        //put in Redis - 2nd level Cache
        redisTemplate.opsForValue().set(redisKey, movies, Duration.ofMinutes(cacheItemExpireInMinutes));

	    //multiGet
	    //List<String> cacheKeys = getCacheKeys();
        //List<String> responseItems = redisTemplate.multiGet(cacheKeys);


    } else {
        caffeineCacheManager.getCache(CaffeineConfig.HELLO_WORLD_CACHE).put(redisKey, movies);
    }

}

---------------------------------------------------------------------------------------------

Handling Duplicate Requests
------------------------------
Idempotent keys in header
Token-Based Request Validation

---------------------------------------------------------------------------------------------


MDC (Mapped Diagnostic Context)
====================================
- To transfer value within service

JSON logging
====================
JSON logging is enabled through LogstashEncoder

<!-- JSON Logging -->
<dependency>
    <groupId>net.logstash.logback</groupId>
    <artifactId>logstash-logback-encoder</artifactId>
    <version>5.2</version>
</dependency>

logback.xml
---------------
<?xml version="1.0" encoding="UTF-8"?>
<configuration>

      <!-- console log appender -->
       <appender name="jsonConsole" class="ch.qos.logback.core.ConsoleAppender">
           <encoder class ="net.logstash.logback.encoder.LogstashEncoder">
               <!-- append fields into logstash log by MDC-->
               <includeMdcKeyName>x-flow-id</includeMdcKeyName>
               <includeMdcKeyName>month</includeMdcKeyName>
               <includeMdcKeyName>parmRequestSource</includeMdcKeyName>
           </encoder>
       </appender>

    <root level="INFO">
        <appender-ref ref="jsonConsole"/>
    </root>

</configuration>

private final Logger logger = LoggerFactory.getLogger(NavigationController.class);

String requestJSON = objectMapper.writeValueAsString(orderRequestForm);
MDC.put("month", month);
MDC.put("parmRequestSource", parmRequestSource);
MDC.put("x-flow-id", UUID.randomUUID().toString());
logger.info(requestJSON);

{
	"@timestamp": "2024-09-21T11:49:09.875+05:30",
	"@version": "1",
	"message": "{\r\n  \"orderId\" : 100,\r\n  \"location\" : \"Kolkata\",\r\n  \"invoiceType\" : 2,\r\n  \"orderItems\" : [ {\r\n    \"itemId\" : 1001,\r\n    \"itemName\" : \"iPhoneX\",\r\n    \"quantity\" : 2\r\n  }, {\r\n    \"itemId\" : 1002,\r\n    \"itemName\" : \"iPad\",\r\n    \"quantity\" : 2\r\n  }, {\r\n    \"itemId\" : 1003,\r\n    \"itemName\" : \"LED TV\",\r\n    \"quantity\" : 2\r\n  } ]\r\n}",
	"logger_name": "com.example.SpringBootREST2.controller.NavigationController",
	"thread_name": "http-nio-9050-exec-3",
	"level": "INFO",
	"level_value": 20000,
	"month": "Feb",
	"parmRequestSource": "web",
	"x-flow-id": "8f73e973-c37a-4236-855d-ad25dcb5c1a1"
}

----------------------------------------------------------------------------------------------------------------------

CORS (Cross-Origin Resource Sharing)
========================================
@CrossOrigin
Allows API to share resources with Browser


CSRF (Cross-Site Request Forgery)
===================================================================
If a user is logged into a website (e.g., a banking site), an attacker can create a malicious page
that tricks the user’s browser into sending requests to that site.

CSRF protection - CSRF token to be shared between client and server

httpSecurity
        .csrf().disable() //disable for APIs as it is stateless or JWT authentication

XSS (Cross-Site Scripting)
===============================
Implement malicious code in user's website
When the malicious code is processed, it can fetch any data.
Javascript-based
more dangerous

---------------------------------------------------------------------------------------------------------------------------

mvcMatcher vs antMatcher
================================

mvcMatcher is more secure than an antMatcher. As an example:

.antMatchers(HttpMethod.POST, "/orders/v1/getOrder2").permitAll()
.mvcMatchers(HttpMethod.POST, "/orders/v1/getOrder2/**").permitAll()

Secured Spring Application
===============================

Object :  @Autowired /  @Bean
Variable :  No global variable
Jaxb2Marshaller
DataSource and Hikari
JWT
APIGW

@AllArgsConstructor                                   vs                                  @RequiredArgsConstructor
============================================================================================================================
constructor for all fields                                                               constructor for final fields


Import java class into Spring container
===========================================

public class A {
}

@Import(A.class)
@Configuration
public class TestConfiguration {

}

class {

    @Autowired
    private A a;
}

Encoding vs Encryption
===========================================

Encoding    :: Text + algorithm = Cipher-Text
Encryption  :: Text + key + algorithm = Cipher-Text

Symmetric Encryption                                            vs                                      Asymmetric Encryption
---------------------------------------------------------------------------------------------------------------------------------------
Single key is used for encryption and decryption                                    Two different keys are used — Private Key and Public Key
- AES (Advanced Encryption Standard) , DES (Data Encryption Standard)               -RSA


Pen test
==============
API penetration testing is a security testing method that simulates hacker attacks to evaluate the security of an API
- BurpSuite

GHAS / SonarQube
=====================
Static code analysis tool

Disaster recovery
========================
Terraform - IaaC -> define your infrastructure, so it can be recreated quickly in case of disaster
Auto-Scaling
Failover
Multi-region

        Hot Failover: Backup systems run simultaneously with the primary systems. Failover happens automatically and almost instantaneously.
        Cold Failover: Backup systems remain offline and only come online when a failure occurs. The recovery process takes time as services and systems need to be started manually.
        Warm Failover: Backup systems are running with minimal services enabled, and they are prepared to take over quickly with some manual intervention.

Performance Testing
====================
Gatling / JMeter


A/B Testing
==================
compares 2 versions to check which version is more performant/appeals more

Trivy
======
Image Scanning for vulnerabilities

Blackduck
==========
BlackDuck -> Image Scanning for vulnerabilities + compliance +  code-quality


---------------------------------------------------------------------------------------------------------------------------------------

Gatling
======================

Gatling : Performance test by simulation
Compared to JMeter : Gatling is faster, lightweight, and provides more detailed and colorful reports

simulation service :: E:\Softwares\gatling-charts-highcharts-bundle-3.9.5\user-files\simulations\GatlingSimulations.java

Run gatling :: E:\Softwares\gatling-charts-highcharts-bundle-3.9.5\bin\gatling.bat

Results :: E:\Softwares\gatling-charts-highcharts-bundle-3.9.5\results

<dependency>
    <groupId>io.gatling</groupId>
    <artifactId>gatling-core</artifactId>
    <version>3.9.3</version>
</dependency>
<!-- https://mvnrepository.com/artifact/io.gatling.highcharts/gatling-charts-highcharts -->
<dependency>
    <groupId>io.gatling.highcharts</groupId>
    <artifactId>gatling-charts-highcharts</artifactId>
    <version>3.9.3</version>
</dependency>
<!-- https://mvnrepository.com/artifact/io.gatling/gatling-maven-plugin -->
<dependency>
    <groupId>io.gatling</groupId>
    <artifactId>gatling-maven-plugin</artifactId>
    <version>4.3.1</version>
</dependency>

Gatling Simulation
------------------------------

package com.example.SpringBootREST2.service;

import static io.gatling.javaapi.core.CoreDsl.*;
import static io.gatling.javaapi.http.HttpDsl.*;

import io.gatling.javaapi.core.*;
import io.gatling.javaapi.http.*;

public class GatlingSimulation extends Simulation {

    HttpProtocolBuilder httpProtocol =
        http.baseUrl("http://localhost:9050")
            .acceptHeader("text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
            .acceptLanguageHeader("en-US,en;q=0.5")
            .acceptEncodingHeader("gzip, deflate")
            .userAgentHeader(
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:16.0) Gecko/20100101 Firefox/16.0"
            );

    ChainBuilder read = exec(http("Read Spring Rest Controller").get("/orders/v1/getMoviesOfDirector/Satyajit Ray"));
    ScenarioBuilder users = scenario("Users Read").exec(read);

    {
        setUp(
            users.injectOpen(
                atOnceUsers(1),
                nothingFor(2),
                atOnceUsers(4),
                rampUsers(50).during(10),
                constantUsersPerSec(20.0).during(20),
                constantUsersPerSec(30.0).during(30)
            )
        ).protocols(httpProtocol);
    }
}

----------------------------------------------------------------------------------------------------------------------

SonarQube
==============

Static code analysis tool
 - Code quality
 - Code complexity
 - Code duplications
 - Code coverage
 - Code smells
 - Detects bugs and vulnerabilities

 - Project status - passed / failed
 Can integrate with build tools like Maven, Gradle and with CI Tools like Jenkins, Github Actions

<!-- JaCoCo -->
<dependency>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.8</version>
</dependency>

 JaCoCo allows you to configure rules that can be verified during the build process, stopping it if these rules are not met.
 JaCoCo will give the unit test coverage

Run Sonar
------------------
E:\Softwares\sonarqube-10.2.1.78527\conf\sonar.properties
        sonar.jdbc.username=postgres
        sonar.jdbc.password=postgres

E:\Softwares\sonarqube-10.2.1.78527\bin\windows-x86-64\StartSonar.bat
http://localhost:9000

D:\workspace2\SpringBootREST2 >
mvn clean verify sonar:sonar -Dsonar.projectKey=SpringBootREST2 -Dsonar.projectName='SpringBootREST2' -Dsonar.host.url=http://localhost:9000 -Dsonar.token=sqp_5b83985ddb470a1350f16fc2363daefbde691605

----------------------------------------------------------------------------------------------------------------------

GitHub Advanced Security
============================

Code scanning
Secret scanning
Dependency review


----------------------------------------------------------------------------------------------------------------------

@Conditional
--------------------------
1.@ConditionalOnProperty

@Configuration
@ConditionalOnProperty(value = "opentracing.jaeger.enabled", havingValue = "true", matchIfMissing = true)
public class JaegerConfig {
}
//matchIfMissing : Specify if the condition should match if the property is not set
//so if opentracing.jaeger.enabled is not present then it will not match

2.@ConditionalOnBean

@Bean
@ConditionalOnBean(DataSource.class)
public ExampleService exampleService(DataSource dataSource) {
    return new ExampleService(dataSource);
}

3.@ConditionalOnMissingBean

@Bean
@ConditionalOnMissingBean(ExampleService.class)
public ExampleService defaultExampleService() {
    return new DefaultExampleService();
}

4.@Conditional

@Component
@Conditional(SomeCondition.class)
public class MyComponent {
  // ... your component code here
}

public class SomeCondition implements Condition {

  @Override
  public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    //return true/false
  }
}

----------------------------------------------------------------------------------------------------------------------

RestTemplate                            vs                      WebClient                           vs                          RestClient              vs                   FeignClient
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Synchronous HTTP call                                        ASynchronous HTTP call                                           Synchronous HTTP call                         Synchronous HTTP call
                                                             Fluid API                                                        Fluid API                                     Interface with @FeignClient
Servlet Stack                                                Reactive Stack                                                   Servlet Stack



Client-side Load Balancing                  vs                                         Server-side Load-balancing
----------------------------------------------------------------------------------------------------------------------
Spring Cloud Load Balancer	                                                             Single point of failure
EurekaServer                                                                             INGRESS




Forward Proxy                                      vs                               Reverse Proxy
-------------------------------------------------------------------------------------------------------------

Client -> Forward Proxy -> Internet -> Server
        - IP masking (Client anonimity)
        - Logging
        - Caching
        - Encryption
        - Load Balancing

                                                                        Client -> Internet  -> Reverse Proxy -> Server
                                                                                - IP masking (Server anonimity)
                                                                                - Logging
                                                                                - Caching
                                                                                - Encryption
                                                                                - Load Balancing
                                                                                - Rate-limiting (DDoS Protection) (Distributed Denial-of-Service)


---------------------------------------------------------------------------------------------------------------------------

DDos (Distributed Denial of Service) attack
------------------------------------------------------

A distributed denial-of-service (DDoS) attack is a malicious attempt to disrupt the normal traffic of a targeted server, service or network
by overwhelming the target or its surrounding infrastructure with a flood of Internet traffic.

Spring Bean scopes
--------------------------
1. singleton ::    1 instance in SpringApplicationContext
2. prototype ::    1 instance in every call
3. request ::      1 instance in request
4. session ::      1 instance in session
5. application ::  1 instance in appliocation(ServletContext)
6. websocket ::    1 instance in WebSocket

---------------------------------------------------------------------------------------------------------------------------