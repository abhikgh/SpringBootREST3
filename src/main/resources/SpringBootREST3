SpringBoot3 changes
===========================================================

1. 	<version>3.2.7</version>
	<java.version>21</java.version>
	<spring-cloud.version>2023.0.0</spring-cloud.version>
	<openapi.version>2.2.0</openapi.version>

2. <!--Lombok-->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.30</version>
    <scope>provided</scope>
</dependency>

3. javax.persistence -> jakarta.persistence

4. JSONB ->  @Type(JsonBinaryType.class)

5. Security ->

6. Observability -> 

7. jaxb-api -> 

	    <groupId>javax.xml.bind</groupId>
            <artifactId>jaxb-api</artifactId>			is replaced with
            
	    <groupId>jakarta.xml.bind</groupId>
            <artifactId>jakarta.xml.bind-api</artifactId>

8. Swagger -> 

	    <dependency>
            <groupId>org.springdoc</groupId>
            	<artifactId>springdoc-openapi-webmvc-core</artifactId>
            <artifactId>springdoc-openapi-starter-webmvc-api</artifactId>
            <version>${openapi.version}</version>
        </dependency>

9. Tests -> 	@MockBean 		is replaced with 

		        @Mock

ApplicationConfig
========================

@Configuration
public class ApplicationConfig {

    //TomcatProtocolHandler is responsible for handling incoming requests in a Spring Boot application
    //TomcatProtocolHandlerCustomizer configures the Executor
    //Executor is responsible for executing tasks, like handling incoming requests
    //Virtual Threads
    @Bean
    TomcatProtocolHandlerCustomizer<?> tomcatProtocolHandlerCustomizer() {
        return tomcatProtocolHandlerCustomizer -> {
            tomcatProtocolHandlerCustomizer.setExecutor(Executors.newVirtualThreadPerTaskExecutor()); //executor service that creates a new Virtual Thread for each task submitted to it
        };
    }

    // Monitoring beans
    @Bean
    ObservationRegistry observationRegistry() {
        return ObservationRegistry.create();
    }

    // To have the @Observed support we need to register this aspect
    @Bean
    ObservedAspect observedAspect(ObservationRegistry observationRegistry) {
        return new ObservedAspect(observationRegistry);
    }
}
---------------------------------------------------------------------------------------------------------
Spring Boot 3 Secured Endpoint
---------------------------------
1. pom
<!-- Web -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!-- Spring Security -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<!-- JWT -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>

<!-- jaxb -->
<dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>
    <version>2.3.0</version>
</dependency>

//2. Secured endpoint
// http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray
// Authorization
// Type     -> Bearer Token
// Token    -> eyJhbGciOiJIUzUxMiJ9...
// JWT Token is in the form of Bearer Token
@GetMapping(value = "/getMoviesOfDirector/{director}", produces = MediaType.APPLICATION_JSON_VALUE)
public ResponseEntity<List<Movie>> getMoviesOfDirector(
        @PathVariable("director") String director) {
    Span span = jaegerTracer.buildSpan("getMoviesOfDirector").start();
    log.info("Inside getMoviesOfDirector controller... ");

    //Counter metric
    Counter counter = Counter.builder("getMoviesOfDirector")
            .description("a number of requests to /getMoviesOfDirector endpoint")
            .register(meterRegistry);
    counter.increment();

    //Timer metric
    Timer.Sample timer = Timer.start(meterRegistry);
    Span getHeroDetailsSpan = jaegerTracer.buildSpan("getMoviesOfDirector-Service").asChildOf(span).start();
    List<Movie> movies = movieService.getMoviesOfDirector(director);
    getHeroDetailsSpan.finish();
    span.finish();
    timer.stop(Timer.builder("getMoviesOfDirector_Timer").register(meterRegistry));

    //Observation API
    Observation.createNotStarted("getMoviesOfDirector_Count", observationRegistry)
            .lowCardinalityKeyValue("request-uid", String.valueOf(new Random().nextInt(100)))
            .observe(() -> {
                List<Movie> movies2 = movieService.getMoviesOfDirector(director);
                log.debug("Counting getMoviesOfDirector");
            });

    return ResponseEntity.ok(movies);
}

So to hit this endpoint from Postman, first get the JWT Token from the Auth-Server and pass the JWT token as Bearer token in the endpoint

3. Authentication endpoint
================================
//http://localhost:9100/v3/rest/authenticate
/*
    {
    "userId":"eyabhikg",
    "password":"12345"
    }
 */
//var jsonData = JSON.parse(responseBody);
//pm.environment.set("SB3_BEARER_TOKEN", jsonData['jwt']);
@PostMapping("/authenticate")
public AuthenticationResponse authenticate(@RequestBody Map<String, Object> claims){

    try {
        log.info("In authenticate method...");
        authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(claims.get("userId"), claims.get("password")));
    } catch (Exception e) {
        log.error("Authentication Error.......");
        throw e;
    }

    UserDetails userDetails = userService.loadUserByUsername(String.valueOf(claims.get("userId")));
    String jwt = jwtTokenUtil.generateToken(userDetails);
    return ResponseEntity
            .status(HttpStatus.OK)
            .body(new AuthenticationResponse(userDetails.getUsername(), userDetails.getAuthorities().stream().map(String::valueOf).toList().getFirst(), jwt))
            .getBody();

}


4. JWTTokenUtil
----------------------
// generate JWT token for user
public String generateToken(UserDetails userDetails) {
    Map<String, Object> claims = new HashMap<>();

    claims.put("client_id",userDetails.getUsername());
    claims.put("client_secret","3333");
    claims.put("subject","devtest");
    claims.put("scope","user");
    claims.put("issuer","application");

    return Jwts.builder()
            .setClaims(claims)
            .setSubject(userDetails.getUsername())
            .setIssuedAt(new Date(System.currentTimeMillis()))
            .setExpiration(new Date(System.currentTimeMillis()  + expirationInMillis))
            .signWith(SignatureAlgorithm.HS512, secret)
        .compact();
}

5. SecurityConfig
----------------------

@Configuration
@EnableWebSecurity
public class SecurityConfig {

   @Value("${application.spring.endpoints.exclude}")
   private String[] applicationApisToBeExcluded;

    @Value("${service.endpoints.exclude:}")
    private String[] serviceApisToBeExcluded;

    @Autowired
    private UserService userService;

    @Autowired
    private JWTFilter jwtFilter;

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userService);
        authProvider.setPasswordEncoder(new BCryptPasswordEncoder());
        return authProvider;
    }

    private String[] allApisToBeExcluded(){
        return applicationApisToBeExcluded;

        /* return Stream.of(applicationApisToBeExcluded, serviceApisToBeExcluded)
                .flatMap(Stream::of)
                .toArray(String[]::new);*/
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {
        return httpSecurity
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(requests -> requests.requestMatchers(allApisToBeExcluded()).permitAll().anyRequest().authenticated())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }
}


6. JWT Filter
-----------------------

@Component
public class JWTFilter extends OncePerRequestFilter {

    @Autowired
    private JWTTokenUtil jwtTokenUtil;

    @Autowired
    private UserService userService;

    // Intercept each request ,extract the JWT from the Request header ,validate and put the JWT in the SecurityContext
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        try {
            //gets the Authorization header
            String bearerToken = request.getHeader("Authorization");
            if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {

                // JWT Token is in the form of Bearer Token
                // Authorization  :: Bearer dkdllslsl
                String jwtToken = bearerToken.substring(7);
                String username = jwtTokenUtil.getUsernameFromToken(jwtToken);

                if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {

                    UserDetails userDetails = userService.loadUserByUsername(username);
                    if (jwtTokenUtil.validateToken(jwtToken, userDetails)) {

                        //UsernamePasswordAuthenticationToken(Object principal, Object credentials, Collection<? extends GrantedAuthority> authorities)
                        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(
                                userDetails, null, userDetails.getAuthorities());
                        usernamePasswordAuthenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                        SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);
                    }
                }

            }
        }catch (ExpiredJwtException ex){

        }
        filterChain.doFilter(request, response);
    }


}


7. Service  (implementing UserDetailsService)
----------------------------------------------

@Service
public class UserService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private AccountRepository accountRepository;

    @Override
    public UserDetails loadUserByUsername(String userId) throws UsernameNotFoundException {
        UserMaster userMaster = userRepository.findByUserId(userId);

        if (userMaster == null) {
            System.out.println("User not found");
            throw new UsernameNotFoundException("User not found");
        }

        return
                User
                    .builder()
                    .username(userMaster.getUserId())
                    .password(userMaster.getPassword())
                    .roles(userMaster.getRoleCode())
                    .build();

    }

}

----------------------------------------------------------------------------------------------------------------------
Spring Boot 3 Secured Endpoint client
-------------------------------------------

@Configuration
public class RestClientConfig {

    @Bean(name = "restClient1")
    public RestClient restClient() {
        return RestClient
                .builder()
                .baseUrl("http://localhost:9100/v3/rest")
                .defaultHeader(HttpHeaders.CONTENT_ENCODING,"gzip")
                .defaultHeader(HttpHeaders.ACCEPT_ENCODING,"gzip")
                .build();
    }

}

@Autowired
@Qualifier("restClient1")
private RestClient restClient;

public List<Movie> getMoviesOfDirectorClient(String director) {
    HttpHeaders httpHeaders = new HttpHeaders();
    httpHeaders.set("Authorization","Bearer " + getJWTToken());
    return
            restClient
                .get()
                .uri("/getMoviesOfDirector/" + director)
                .headers(headers -> headers.addAll(httpHeaders))
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .body(new ParameterizedTypeReference<>() {});
}

private String getJWTToken() {
    Map<String, Object> claims = new HashMap<>();
    claims.put("userId","eyabhikg");
    claims.put("password", "12345");

    String jwt =
            Objects.requireNonNull(restClient
                                    .post()
                                    .uri("/authenticate")
                                    .contentType(MediaType.APPLICATION_JSON)
                                    .accept(MediaType.APPLICATION_JSON)
                                    .body(claims)
                                    .retrieve()
                                    .body(AuthenticationResponse.class))
                    .getJwt();

    System.out.println("jwt - " + jwt);
    return
            jwt;
}

--------------------------------------------------------------------------------------------------------

ASync client
-------------------------------------------

@EnableAsync
@Configuration
public class ASyncConfig {

    @Bean
    public ThreadPoolTaskExecutor threadPoolTaskExecutor(){
        ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();
        threadPoolTaskExecutor.setMaxPoolSize(100);
        threadPoolTaskExecutor.setThreadNamePrefix("ASync-1");
        threadPoolTaskExecutor.initialize();
        return threadPoolTaskExecutor;
    }
}

@SneakyThrows
public HeroDetailsResponse getHeroDetailsASync(HeroDetailsRequest heroDetailsRequest) {
    HeroDetailsResponse heroDetailsResponse = new HeroDetailsResponse();
    List<Hero> heroList = new ArrayList<>();
    List<CompletableFuture<Hero>> cfs = heroDetailsRequest.getHeroNames().stream().map(this::getHeroDetails).toList();
    //join all the CFs
    CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0])).join();
    //get the results from each of the CF
    for(CompletableFuture<Hero> completableFuture : cfs){
        if(completableFuture.isDone()){
            heroList.add(completableFuture.get());
        }
    }
    heroDetailsResponse.setHeroList(heroList);
    return heroDetailsResponse;
}

@Async(value = "threadPoolTaskExecutor")
private CompletableFuture<Hero> getHeroDetails(String heroName) {
    System.out.println("ASync Thread :: " + Thread.currentThread().getName());
    Hero hero = restClient2
                .get()
                .uri("/getHeroDetails/"+heroName)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .body(Hero.class);
    return CompletableFuture.completedFuture(hero);
}

External services but may experience intermittent failures or downtime
------------------------------------------------------------------------------

Retry / Circuit-Breaker

Retry is when the failure is expected to be short-lived
Circuit-Breaker is when the failure is expected to be long-lived as the connection will be broken

Spring Retry
----------------

<!-- Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<!-- AOP -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
<!-- spring-retry -->
<dependency>
    <groupId>org.springframework.retry</groupId>
    <artifactId>spring-retry</artifactId>
    <version>1.3.2</version>
</dependency>


@EnableRetry

@SneakyThrows
@Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 3))
public HeroDetailsResponse getHeroDetailsASync(HeroDetailsRequest heroDetailsRequest) {
    HeroDetailsResponse heroDetailsResponse = new HeroDetailsResponse();
    List<Hero> heroList = new ArrayList<>();
    List<CompletableFuture<Hero>> cfs = heroDetailsRequest.getHeroNames().stream().map(this::getHeroDetails).toList();
    //join all the CFs
    CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0])).join();
    //get the results from each of the CF
    for(CompletableFuture<Hero> completableFuture : cfs){
        if(completableFuture.isDone()){
            heroList.add(completableFuture.get());
        }
    }
    heroDetailsResponse.setHeroList(heroList);
    return heroDetailsResponse;
}

@Async(value = "threadPoolTaskExecutor")
private CompletableFuture<Hero> getHeroDetails(String heroName) {
    if (Objects.nonNull(RetrySynchronizationManager.getContext()) && RetrySynchronizationManager.getContext().getRetryCount() > 0) {
        System.out.println(String.format("Retry count %d for service %s", RetrySynchronizationManager.getContext().getRetryCount(), "getHeroDetails"));
    }
    Hero hero = restClient2
                .get()
                .uri("/getHeroDetails/"+heroName)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .body(Hero.class);
    return CompletableFuture.completedFuture(hero);
}

@Recover
public HeroDetailsResponse defaultGetHeroDetails(Exception exception){
    return new HeroDetailsResponse();
}

Circuit-Breaker
--------------------

<!-- Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<!-- AOP -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
<!-- Resilience -->
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot3</artifactId>
    <version>2.0.2</version>
</dependency>


resilience4j:
  circuitbreaker:
    instances:
      getHeroDetails_CB:
        register-health-indicator: true
        sliding-window-type: count_based
        sliding-window-size: 10
        failure-rate-threshold: 70 #Circuitbreaker will open if 70% of the last 10 calls failed
        slow-call-rate-threshold: 40
        slow-call-duration-threshold: 2s
        permitted-number-of-calls-in-half-open-state: 1
        max-wait-duration-in-half-open-state: 10s
        wait-duration-in-open-state: 10s
        writable-stack-trace-enabled: true
        automatic-transition-from-open-to-half-open-enabled: true


@SneakyThrows
//@Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 3))
@CircuitBreaker(name = "getHeroDetails_CB", fallbackMethod = "getDummyMethod")
public HeroDetailsResponse getHeroDetailsASync(HeroDetailsRequest heroDetailsRequest) {
    HeroDetailsResponse heroDetailsResponse = new HeroDetailsResponse();
    List<Hero> heroList = new ArrayList<>();
    List<CompletableFuture<Hero>> cfs = heroDetailsRequest.getHeroNames().stream().map(this::getHeroDetails).toList();
    //join all the CFs
    CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0])).join();
    //get the results from each of the CF
    for(CompletableFuture<Hero> completableFuture : cfs){
        if(completableFuture.isDone()){
            heroList.add(completableFuture.get());
        }
    }
    heroDetailsResponse.setHeroList(heroList);
    return heroDetailsResponse;
}

@Recover
public HeroDetailsResponse defaultGetHeroDetails(Exception exception){
    return new HeroDetailsResponse();
}

public HeroDetailsResponse getDummyMethod(Exception exception){
    System.out.println("In circuit-breaker fallback...");
    return new HeroDetailsResponse();
}

management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: always
  health:
    circuitbreakers:
      enabled: true

http://localhost:9101/actuator/health

--------------------------------------------------------------------------------------------------------

Rate-limiter
------------------

resilience4j:
  ratelimiter:
      instances:
        getHeroDetails_RL:
          limitForPeriod: 2
          limitRefreshPeriod: 1s # 2RPS
          timeoutDuration: 10s     #time to acquire permission from RateLimiter before erroring out.

@SneakyThrows
//@Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 3))
@CircuitBreaker(name = "getHeroDetails_CB", fallbackMethod = "getDummyMethod")
@RateLimiter(name = "getHeroDetails_RL")
public HeroDetailsResponse getHeroDetailsASync(HeroDetailsRequest heroDetailsRequest) {
    HeroDetailsResponse heroDetailsResponse = new HeroDetailsResponse();
    List<Hero> heroList = new ArrayList<>();
    List<CompletableFuture<Hero>> cfs = heroDetailsRequest.getHeroNames().stream().map(this::getHeroDetails).toList();
    //join all the CFs
    CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0])).join();
    //get the results from each of the CF
    for(CompletableFuture<Hero> completableFuture : cfs){
        if(completableFuture.isDone()){
            heroList.add(completableFuture.get());
        }
    }
    heroDetailsResponse.setHeroList(heroList);
    return heroDetailsResponse;
}

//429 Too Many Requests response
//Throttling allows to prioritize certain requests or users, ensuring a smoother experience for critical operations. 
   Rate limiting enforces uniform limits across all requests

--------------------------------------------------------------------------------------------------------

Latency in one service should not migrate to the whole system - check max concurrent calls
----------------------------------------------------------------------------------------------

Bulkhead pattern
---------------

resilience4j:
 bulkhead:
   instances:
     getHeroDetails_BH:
       maxConcurrentCalls: 1

@SneakyThrows
//@Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 3))
@CircuitBreaker(name = "getHeroDetails_CB", fallbackMethod = "getDummyMethod")
@RateLimiter(name = "getHeroDetails_RL")
@Bulkhead(name = "getHeroDetails_BH", fallbackMethod = "getDummyMethod")
public HeroDetailsResponse getHeroDetailsASync(HeroDetailsRequest heroDetailsRequest) {
    HeroDetailsResponse heroDetailsResponse = new HeroDetailsResponse();
    List<Hero> heroList = new ArrayList<>();
    List<CompletableFuture<Hero>> cfs = heroDetailsRequest.getHeroNames().stream().map(this::getHeroDetails).toList();
    //join all the CFs
    CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0])).join();
    //get the results from each of the CF
    for(CompletableFuture<Hero> completableFuture : cfs){
        if(completableFuture.isDone()){
            heroList.add(completableFuture.get());
        }
    }
    heroDetailsResponse.setHeroList(heroList);
    return heroDetailsResponse;
}

RestTemplate                            vs                      WebClient                           vs                          RestClient              vs                   FeignClient
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Synchronous HTTP call                                        ASynchronous HTTP call                                           Synchronous HTTP call                         Synchronous HTTP call
                                                             Fluid API                                                        Fluid API                                     Interface with @FeignClient
Servlet Stack                                                Reactive Stack                                                   Servlet Stack

--------------------------------------------------------------------------------------------------------

Class Data Sharing (CDS)
==============================
Reduce startup time and memory consumption

1.Stores snapshot of the application classes in a archived file
2.Startup, JVM can refer this archive and get the class file, improving the class-loading time

spring.context.exit-on-refresh=true

-XX:ArchiveClassesAtExit=app-cds.jsa
# On the JVM you plan to deploy to:
java -Xshare:on -XX:SharedArchiveFile=app-cds.jsa -jar myapp.jar

GraalVM native image 
========================
Compiles the Java code into a standalone executable, eliminating the need for a JVM at runtime.

----------------------------------------------------------------------------------------------------------------------

Spring Observability
===============================================================================
Observability is the ability to measure the internal state of a system only by checking its outputs (logs, traces, metrics)
define our own metrics using Micrometer
gather them using Prometheus
display them on a Grafana dashboard


		    (exposes Metrics)    (collects + makes + ships Metrics)   (scrape Metrics)         (query Prometheus)
SpringBoot ------> Actuator  ---->   Micrometer   --------------->     Prometheus     ------>    Grafana
									  (Monitoring tool)         (Observability backend)

                                 (Prometheus to scrape Micrometer logs and Micrometer metrics at a configured interval from and endpoint and display them in a Grafana dashboard)


<!-- Web -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<!-- Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<!-- Micrometer-core -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-core</artifactId>
    <scope>runtime</scope>
</dependency>
<!-- Micrometer-prometheus -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
    <scope>runtime</scope>
</dependency>
<!-- AOP, for custom timer -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>

Actuator
===========================
Exposes metrics by exposing management endpoints - CPU usage, memory usage, request rate, error rate

http://localhost:9100/actuator
//health and info are auto-enabled

/health
/info
/env
/loggers
/httptrace
/sessions
/startup
/shutdown

management:
  endpoints:
    web:
      exposure:
        include: health, prometheus, metrics, info
  endpoint:
    health:
      show-details: always
    metrics:
      enabled: true
    prometheus:
      enabled: true // Exposes metrics in a format that can be scraped by a Prometheus server.
    info:
      java:
        enabled: true
      env:
        enabled: true
  tracing:
      sampling:
        probability: 1.0


Micrometer (replaces Spring Cloud Sleuth)
========================================================
collects metrics + own metrics + exports Metrics 
configures Spring Boot applications to expose metrics in a format that Prometheus can scrape and store.

Micrometer metrics::
-----------------------
Timer                                 measuring short-duration latencies, and the frequency of such events.
Counter				                  count
Gauge	                              current value
DistributionSummary	                  total amount of all recorded events
Micrometer Observation API            lightweight library for application metrics

//Counter metric
Counter counter = Counter.builder("getMoviesOfDirector")
                        .description("a number of requests to /getMoviesOfDirector endpoint")
                        .register(meterRegistry);
counter.increment();


Prometheus
=====================================
Monitoring tool
Prometheus needs an endpoint(metrics_path) to scrape Micrometer logs and Micrometer metrics at a configured interval and display them in a Grafana dashboard

prometheus.yml
------------------
scrape_configs:
  - job_name: 'SpringBootREST3'
    metrics_path: '/actuator/prometheus'
    scrape_interval: 5s
    static_configs:
      - targets: ['host.docker.internal:9100']
        labels:
          application: 'SpringBootREST3'

Hit http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray a few times

Check in Prometheus ::
            http://localhost:9100/actuator/prometheus

            # TYPE getMoviesOfDirector_total counter
            getMoviesOfDirector_total 7.0

General check in Prometheus UI:
    http://localhost:9090/ -> prometheus_http_requests_total

How does Prometheus that is running on Docker connect to SpringBoot app that is running on localhost?
---------------------------------------------------------------------------------------------------------------
- targets: ['host.docker.internal:9050']
  host.docker.internal is a host-gateway which is a daemon process routing requests to localhost

Behind the scenes, an observation has been created for the HTTP request, which in turn gets bridged to OpenTelemetry, which reports a new trace to Zipkin.

http://localhost:9090/
- Check Status -> Targets


Grafana
======================
Observability backend
Data Visualization service -  create dashboards to visualize and analyze data

http://localhost:3000/ (admin/Kolkata@123a)

Add your first datasource
Select Prometheus
Connect to Prometheus from Grafana :
    Get Prometheus container id
    Get Prometheus IP :
        docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' cd7c5f0de3ac
    - 172.22.0.2
    Prometheus URL in Grafana :: http://172.22.0.2:9090
    - Save and test
Add new Dashboard
    Datasource - Prometheus-1
    prometheus_http_requests_total

datasources.yml
----------------------
apiVersion: 1
datasources:
  - name: Prometheus
    type: prometheus
    access: proxy
    url: http://prometheus:9090
    isDefault: true

docker-compose-yml
--------------------------
version: '3.7'

services:
  prometheus:
    image: prom/prometheus:v2.44.0
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus.yml

  grafana:
    image: grafana/grafana:9.5.2
    container_name: grafana
    ports:
      - "3000:3000"
    restart: unless-stopped
    volumes:
      - ./datasources.yml:/etc/datasources.yml
    depends_on:
      - prometheus


Running all on Docker
-------------------------
Start the application
Start Docker Desktop (starts the Docker daemon)
Update docker-compose.yml with PR-GR
Run docker-compose.yml in Git bash :: cd  D:/workspace2/SpringBootREST3/src/main/resources
                                      docker-compose up --build
Open Gitbash another window::
            docker images //prometheus and grafana images
            docker ps     // All running containers

            docker stop $(docker ps -a -q) //Stop all running containers
            docker rm -f $(docker ps -a -q) //Docker remove all containers
            docker rmi -f $(docker images -q) //Docker remove all images

Hit http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray a few times

Check in Prometheus ::
            http://localhost:9100/actuator/prometheus

            # TYPE getMoviesOfDirector_total counter
            getMoviesOfDirector_total 7.0

Check in Grafana ::
            - see above

----------------------------------------------------------------------------------------------------------------------

Spring OpenTelemetry (replaces OpenTracing)
================================================
Observability framework for application monitoring by collecting Logs, Traces and Metrics 
vendor-agnostic

OTLP
-------
OpenTelemetry Protocol is a telemetry data transfer protocol that we can leverage to export the telemetry data to an observability backend.

        		  (exposes Metrics)  (collects + makes + ships Metrics)  (LTM  :: collection and shipment)
SpringBoot ------> Actuator  ---->   Micrometer    ----------------------->   OTel Collector       ------->           Jaeger (Observability Backend)
                                    (Monitoring tool)               micrometer-tracing-bridge-otel                  opentelemetry-exporter-otlp
pom.xml
-----------
<artifactId>spring-boot-starter-parent</artifactId>
<version>3.2.7</version>

<java.version>21</java.version>
		
<dependencies>
	    <!-- Web -->
	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-starter-web</artifactId>
	</dependency>
	<!-- Actuator -->
	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-starter-actuator</artifactId>
	</dependency>
	<!-- AOP, for custom timer -->
	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-starter-aop</artifactId>
	</dependency>
	<!-- Micrometer-core -->
	<dependency>
	    <groupId>io.micrometer</groupId>
	    <artifactId>micrometer-core</artifactId>
	    <version>1.11.6</version>
	</dependency>
	<!--Micrometer-OpenTelemetry bridge-->
	<dependency>
	    <groupId>io.micrometer</groupId>
	    <artifactId>micrometer-tracing-bridge-otel</artifactId>
	</dependency>
	<!--OpenTelemetry exporter-->
	<dependency>
	    <groupId>io.opentelemetry</groupId>
	    <artifactId>opentelemetry-exporter-otlp</artifactId>
	</dependency>
	<!--Jaeger-->
	<dependency>
	    <groupId>io.opentracing.contrib</groupId>
	    <artifactId>opentracing-spring-jaeger-web-starter</artifactId>
	    <version>3.3.1</version>
	</dependency>
	<!--Jaeger-remote-sampler-->
	<dependency>
	    <groupId>io.opentelemetry</groupId>
	    <artifactId>opentelemetry-sdk-extension-jaeger-remote-sampler</artifactId>
	</dependency>
</dependencies>
<dependencyManagement>
	<dependencies>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-dependencies</artifactId>
			<version>2023.0.0</version>
			<type>pom</type>
			<scope>import</scope>
		</dependency>
	</dependencies>
</dependencyManagement>

otel-config.yml
------------------

receivers:
  otlp:
    protocols:
      grpc:
      http:

processors:
  batch:

exporters:
  logging:
    loglevel: debug
  jaeger:
    endpoint: jaeger-service:14250
    tls:
      insecure: true

service:
  pipelines:
    traces:
      receivers:  [ otlp ]
      processors: [ batch ]
      exporters:  [ logging, jaeger ]

docker-compose.yaml
--------------------------
version: '3.7'

services:
  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686" # the jaeger UI
      - "4318:4318" # the OpenTelemetry collector http
    environment:
      - COLLECTOR_OTLP_ENABLED=true


application.yaml
----------------------------
spring:
  application:
    name: SpringBootREST3
  datasource:
    url: jdbc:postgresql://localhost:5432/springbootdb
    username: postgres
    password: tiger
    driver-class-name: org.postgresql.Driver
    hikari:
      connection-timeout: 5000
      maximum-pool-size: 5
  jpa:
    show-sql: true
    properties:
      hibernate:
        format-sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
  main:
    allow-bean-definition-overriding: true


logging:
  level:
    org:
      springframework:
        security: DEBUG
  pattern:
    level: '%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]'

server:
  port: 9100

management:
  endpoints:
    web:
      exposure:
        include: ["health","prometheus","metrics","info"]
  endpoint:
    health:
      show-details: always
    metrics:
      enabled: true
    prometheus:
      enabled: true
  info:
    java:
      enabled: true
    env:
      enabled: true
  tracing:
    sampling:
      probability: 1.0
  otlp:
    tracing:
      endpoint: http://localhost:4318/v1/traces

application:
  spring:
    endpoints:
      exclude: /v3/rest/hello, /v3/rest/helloPost, /v3/rest/home, /actuator/**, /v3/rest/getMoviesOfDirector/**, /v3/rest/getMoviesByDirectorAndGenre/**


opentracing:
  jaeger:
    enabled: true

Jaeger
--------------------------

@Configuration
@ConditionalOnProperty(value = "opentracing.jaeger.enabled", havingValue = "true")
public class JaegerConfig {

    @Bean
    public JaegerTracer jaegerTracer() {
        return new io.jaegertracing.Configuration("SpringBootREST3")
                .withSampler(new io.jaegertracing.Configuration.SamplerConfiguration().withType(ConstSampler.TYPE).withParam(1))
                .withReporter(new io.jaegertracing.Configuration.ReporterConfiguration().withLogSpans(true))
                .getTracer();
    }



}

@RestController
@RequestMapping("/v3/rest")
public class NavController {

    @Autowired
    private HomeService homeService;

    @Autowired
    private MovieService movieService;

    @Autowired
    private MeterRegistry meterRegistry;

    @Autowired
    private JaegerTracer jaegerTracer;

    Logger log = LoggerFactory.getLogger(NavController.class);

    // http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray
    @GetMapping(value = "/getMoviesOfDirector/{director}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<List<Movie>> getMoviesOfDirector(
            @PathVariable("director") String director) {
        Span span = jaegerTracer.buildSpan("getMoviesOfDirector").start();
        log.info("Inside getMoviesOfDirector controller... ");

        //Counter metric
        Counter counter = Counter.builder("getMoviesOfDirector")
                                .description("a number of requests to /getMoviesOfDirector endpoint")
                                .register(meterRegistry);
        counter.increment();

        //Timer metric
        Timer.Sample timer = Timer.start(meterRegistry);
        Span getHeroDetailsSpan = jaegerTracer.buildSpan("getMoviesOfDirector-Service").asChildOf(span).start();
        List<Movie> movies = movieService.getMoviesOfDirector(director);
        getHeroDetailsSpan.finish();
        span.finish();
        timer.stop(Timer.builder("getMoviesOfDirector_Timer").register(meterRegistry));

        //Observation API
        Observation.createNotStarted("getMoviesOfDirector_Count", observationRegistry)
                .lowCardinalityKeyValue("request-uid", String.valueOf(new Random().nextInt(100)))
                .observe(() -> {
                    List<Movie> movies2 = movieService.getMoviesOfDirector(director);
                    log.debug("Counting getMoviesOfDirector");
                });
        return ResponseEntity.ok(movies);
    }

}

logback.xml
---------------------
<?xml version="1.0" encoding="UTF-8"?>
<configuration>

    <property name="APP_LOG" value="logs/app.log"/>
    <property name="logging.file.name" value="info-log" />
    <property name="logging.file.path" value="./"/>
    <property name="logging.error.file.name" value="error-log" />
    <property name="logging.error.file.path" value="./"/>

    <!-- console log appender -->
    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="INFO">
        <appender-ref ref="console"/>
    </root>

</configuration>


Running all on Docker
-------------------------
Start the application
Start Docker Desktop
Update docker-compose.yml with OT-JG
Run docker-compose.yml in Git bash :: cd  D:/workspace2/SpringBootREST3/src/main/resources
                                      docker-compose up --build
Open Gitbash another window::
            docker images //otel and jaeger images
            docker ps     // All running containers

            docker stop $(docker ps -a -q) //Stop all running containers
            docker rm -f $(docker ps -a -q) //Docker remove all containers
            docker rmi -f $(docker images -q) //Docker remove all images

Hit http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray a few times

Check in Jaeger ::
           http://localhost:16686/search


-------------------------------------------------------------------------------------------------

OpenTelemetry                            vs                                     Prometheus
===================================================================================================
Logs, Traces and Metrics                                                        Metrics
More scalable
calculates delta                                                               calculates cumulative measurements as a total
Observation API for LTM and transform them into a single language

-------------------------------------------------------------------------------------------------

Jaeger
========================================
Observability backend
Components:
            Collector—collects trace data, validates and passes to storage service  (port :16686)
            Storage —Cassandra, ElasticSearch
            Web UI— view the trace data
            Search — on trace data

           [TraceId:SpanId:ParentSpanId:Flags]

Span reported: 4c5f29d379ea625e:3d177b55c210dffb:4c5f29d379ea625e:1 - PARENT

Span reported: 4c5f29d379ea625e:c1b1e7351ce66ca9:1d134091d2c206e7:1 - getHeroDetails            - CHILD
Span reported: 4c5f29d379ea625e:1d134091d2c206e7:7c1877ceb2c65cfa:1 - getMoviesOfHero
Span reported: 4c5f29d379ea625e:7c1877ceb2c65cfa:3d177b55c210dffb:1 - getMoviesOfHero   (PARENT SPAN ID = SPAN ID OF CALLER SERVICE)


Jaeger              vs                                Grafana                       vs              Zipkin
-------------------------------------------------------------------------------------------------------------------
Performance, Scalability, Reliability
part of the CNCF(Cloud Native Computing Foundation), so deployed in Kubernetes.
can be deployed in parts
Storage - ElasticSearch, Cassandra,Kafka            Local storage