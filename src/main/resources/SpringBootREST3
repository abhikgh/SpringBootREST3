SpringBoot3 changes
===========================================================

1. 	<version>3.2.7</version>
	<java.version>21</java.version>
	<spring-cloud.version>2023.0.0</spring-cloud.version>
	<openapi.version>2.2.0</openapi.version>

2. <!--Lombok-->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.30</version>
    <scope>provided</scope>
</dependency>

3. javax.persistence -> jakarta.persistence

4. JSONB ->  @Type(JsonBinaryType.class)

5. Security ->

6. Observability -> 

7. jaxb-api -> 

	    <groupId>javax.xml.bind</groupId>
            <artifactId>jaxb-api</artifactId>			is replaced with
            
	    <groupId>jakarta.xml.bind</groupId>
            <artifactId>jakarta.xml.bind-api</artifactId>

8. Swagger -> 

	    <dependency>
            <groupId>org.springdoc</groupId>
            	<artifactId>springdoc-openapi-webmvc-core</artifactId>
            <artifactId>springdoc-openapi-starter-webmvc-api</artifactId>
            <version>${openapi.version}</version>
        </dependency>

9. Tests -> 	@MockBean 		is replaced with 

		        @Mock

ApplicationConfig
========================

@Configuration
public class ApplicationConfig {

    //TomcatProtocolHandler is responsible for handling incoming requests in a Spring Boot application
    //TomcatProtocolHandlerCustomizer configures the Executor
    //Executor is responsible for executing tasks, like handling incoming requests
    //Virtual Threads
    @Bean
    TomcatProtocolHandlerCustomizer<?> tomcatProtocolHandlerCustomizer() {
        return tomcatProtocolHandlerCustomizer -> {
            tomcatProtocolHandlerCustomizer.setExecutor(Executors.newVirtualThreadPerTaskExecutor()); //executor service that creates a new Virtual Thread for each task submitted to it
        };
    }

    // Monitoring beans
    @Bean
    ObservationRegistry observationRegistry() {
        return ObservationRegistry.create();
    }

    // To have the @Observed support we need to register this aspect
    @Bean
    ObservedAspect observedAspect(ObservationRegistry observationRegistry) {
        return new ObservedAspect(observationRegistry);
    }
}
---------------------------------------------------------------------------------------------------------
Spring Boot 3 Secured Endpoint
---------------------------------
1. pom
<!-- Web -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!-- Spring Security -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<!-- JWT -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>

<!-- jaxb -->
<dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>
    <version>2.3.0</version>
</dependency>

//2. Secured endpoint
// http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray
// Authorization
// Type     -> Bearer Token
// Token    -> eyJhbGciOiJIUzUxMiJ9...
// JWT Token is in the form of Bearer Token
@GetMapping(value = "/getMoviesOfDirector/{director}", produces = MediaType.APPLICATION_JSON_VALUE)
public ResponseEntity<List<Movie>> getMoviesOfDirector(
        @PathVariable("director") String director) {
    Span span = jaegerTracer.buildSpan("getMoviesOfDirector").start();
    log.info("Inside getMoviesOfDirector controller... ");

    //Counter metric
    Counter counter = Counter.builder("getMoviesOfDirector")
            .description("a number of requests to /getMoviesOfDirector endpoint")
            .register(meterRegistry);
    counter.increment();

    //Timer metric
    Timer.Sample timer = Timer.start(meterRegistry);
    Span getHeroDetailsSpan = jaegerTracer.buildSpan("getMoviesOfDirector-Service").asChildOf(span).start();
    List<Movie> movies = movieService.getMoviesOfDirector(director);
    getHeroDetailsSpan.finish();
    span.finish();
    timer.stop(Timer.builder("getMoviesOfDirector_Timer").register(meterRegistry));

    //Observation API
    Observation.createNotStarted("getMoviesOfDirector_Count", observationRegistry)
            .lowCardinalityKeyValue("request-uid", String.valueOf(new Random().nextInt(100)))
            .observe(() -> {
                List<Movie> movies2 = movieService.getMoviesOfDirector(director);
                log.debug("Counting getMoviesOfDirector");
            });

    return ResponseEntity.ok(movies);
}

So to hit this endpoint from Postman, first get the JWT Token from the Auth-Server and pass the JWT token as Bearer token in the endpoint

3. Authentication endpoint
================================
//http://localhost:9100/v3/rest/authenticate
/*
    {
    "userId":"eyabhikg",
    "password":"12345"
    }
 */
//var jsonData = JSON.parse(responseBody);
//pm.environment.set("SB3_BEARER_TOKEN", jsonData['jwt']);
@PostMapping("/authenticate")
public AuthenticationResponse authenticate(@RequestBody Map<String, Object> claims){

    try {
        log.info("In authenticate method...");
        authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(claims.get("userId"), claims.get("password")));
    } catch (Exception e) {
        log.error("Authentication Error.......");
        throw e;
    }

    UserDetails userDetails = userService.loadUserByUsername(String.valueOf(claims.get("userId")));
    String jwt = jwtTokenUtil.generateToken(userDetails);
    return ResponseEntity
            .status(HttpStatus.OK)
            .body(new AuthenticationResponse(userDetails.getUsername(), userDetails.getAuthorities().stream().map(String::valueOf).toList().getFirst(), jwt))
            .getBody();

}


4. JWTTokenUtil
----------------------
// generate JWT token for user
public String generateToken(UserDetails userDetails) {
    Map<String, Object> claims = new HashMap<>();

    claims.put("client_id",userDetails.getUsername());
    claims.put("client_secret","3333");
    claims.put("subject","devtest");
    claims.put("scope","user");
    claims.put("issuer","application");

    return Jwts.builder()
            .setClaims(claims)
            .setSubject(userDetails.getUsername())
            .setIssuedAt(new Date(System.currentTimeMillis()))
            .setExpiration(new Date(System.currentTimeMillis()  + expirationInMillis))
            .signWith(SignatureAlgorithm.HS512, secret)
        .compact();
}

5. SecurityConfig
----------------------

@Configuration
@EnableWebSecurity
public class SecurityConfig {

   @Value("${application.spring.endpoints.exclude}")
   private String[] applicationApisToBeExcluded;

    @Value("${service.endpoints.exclude:}")
    private String[] serviceApisToBeExcluded;

    @Autowired
    private UserService userService;

    @Autowired
    private JWTFilter jwtFilter;

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userService);
        authProvider.setPasswordEncoder(new BCryptPasswordEncoder());
        return authProvider;
    }

    private String[] allApisToBeExcluded(){
        return applicationApisToBeExcluded;

        /* return Stream.of(applicationApisToBeExcluded, serviceApisToBeExcluded)
                .flatMap(Stream::of)
                .toArray(String[]::new);*/
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {
        return httpSecurity
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(requests -> requests.requestMatchers(allApisToBeExcluded()).permitAll().anyRequest().authenticated())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }
}


6. JWT Filter
-----------------------

@Component
public class JWTFilter extends OncePerRequestFilter {

    @Autowired
    private JWTTokenUtil jwtTokenUtil;

    @Autowired
    private UserService userService;

    // Intercept each request ,extract the JWT from the Request header ,validate and put the JWT in the SecurityContext
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        try {
            //gets the Authorization header
            String bearerToken = request.getHeader("Authorization");
            if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {

                // JWT Token is in the form of Bearer Token
                // Authorization  :: Bearer dkdllslsl
                String jwtToken = bearerToken.substring(7);
                String username = jwtTokenUtil.getUsernameFromToken(jwtToken);

                if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {

                    UserDetails userDetails = userService.loadUserByUsername(username);
                    if (jwtTokenUtil.validateToken(jwtToken, userDetails)) {

                        //UsernamePasswordAuthenticationToken(Object principal, Object credentials, Collection<? extends GrantedAuthority> authorities)
                        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(
                                userDetails, null, userDetails.getAuthorities());
                        usernamePasswordAuthenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                        SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);
                    }
                }

            }
        }catch (ExpiredJwtException ex){

        }
        filterChain.doFilter(request, response);
    }


}


7. Service  (implementing UserDetailsService)
----------------------------------------------

@Service
public class UserService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private AccountRepository accountRepository;

    @Override
    public UserDetails loadUserByUsername(String userId) throws UsernameNotFoundException {
        UserMaster userMaster = userRepository.findByUserId(userId);

        if (userMaster == null) {
            System.out.println("User not found");
            throw new UsernameNotFoundException("User not found");
        }

        return
                User
                    .builder()
                    .username(userMaster.getUserId())
                    .password(userMaster.getPassword())
                    .roles(userMaster.getRoleCode())
                    .build();

    }

}

----------------------------------------------------------------------------------------------------------------------
Spring Boot 3 Secured Endpoint client
-------------------------------------------

@Configuration
public class RestClientConfig {

    @Bean(name = "restClient1")
    public RestClient restClient() {
        return RestClient
                .builder()
                .baseUrl("http://localhost:9100/v3/rest")
                .defaultHeader(HttpHeaders.CONTENT_ENCODING,"gzip")
                .defaultHeader(HttpHeaders.ACCEPT_ENCODING,"gzip")
                .build();
    }

}

@Autowired
@Qualifier("restClient1")
private RestClient restClient;

public List<Movie> getMoviesOfDirectorClient(String director) {
    HttpHeaders httpHeaders = new HttpHeaders();
    httpHeaders.set("Authorization","Bearer " + getJWTToken());
    return
            restClient
                .get()
                .uri("/getMoviesOfDirector/" + director)
                .headers(headers -> headers.addAll(httpHeaders))
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .body(new ParameterizedTypeReference<>() {});
}

private String getJWTToken() {
    Map<String, Object> claims = new HashMap<>();
    claims.put("userId","eyabhikg");
    claims.put("password", "12345");

    String jwt =
            Objects.requireNonNull(restClient
                                    .post()
                                    .uri("/authenticate")
                                    .contentType(MediaType.APPLICATION_JSON)
                                    .accept(MediaType.APPLICATION_JSON)
                                    .body(claims)
                                    .retrieve()
                                    .body(AuthenticationResponse.class))
                    .getJwt();

    System.out.println("jwt - " + jwt);
    return
            jwt;
}

--------------------------------------------------------------------------------------------------------

ASync client
-------------------------------------------

@EnableAsync
@Configuration
public class ASyncConfig {

    @Bean
    public ThreadPoolTaskExecutor threadPoolTaskExecutor(){
        ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();
        threadPoolTaskExecutor.setMaxPoolSize(100);
        threadPoolTaskExecutor.setThreadNamePrefix("ASync-1");
        threadPoolTaskExecutor.initialize();
        return threadPoolTaskExecutor;
    }
}

@SneakyThrows
public HeroDetailsResponse getHeroDetailsASync(HeroDetailsRequest heroDetailsRequest) {
    HeroDetailsResponse heroDetailsResponse = new HeroDetailsResponse();
    List<Hero> heroList = new ArrayList<>();
    List<CompletableFuture<Hero>> cfs = heroDetailsRequest.getHeroNames().stream().map(this::getHeroDetails).toList();
    //join all the CFs
    CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0])).join();
    //get the results from each of the CF
    for(CompletableFuture<Hero> completableFuture : cfs){
        if(completableFuture.isDone()){
            heroList.add(completableFuture.get());
        }
    }
    heroDetailsResponse.setHeroList(heroList);
    return heroDetailsResponse;
}

@Async(value = "threadPoolTaskExecutor")
private CompletableFuture<Hero> getHeroDetails(String heroName) {
    System.out.println("ASync Thread :: " + Thread.currentThread().getName());
    Hero hero = restClient2
                .get()
                .uri("/getHeroDetails/"+heroName)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .body(Hero.class);
    return CompletableFuture.completedFuture(hero);
}


--------------------------------------------------------------------------------------------------------

RestTemplate                            vs                      WebClient                           vs                          RestClient              vs                   FeignClient
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Synchronous HTTP call                                        ASynchronous HTTP call                                           Synchronous HTTP call                         Synchronous HTTP call
                                                             Fluid API                                                        Fluid API                                     Interface with @FeignClient
Servlet Stack                                                Reactive Stack                                                   Servlet Stack

--------------------------------------------------------------------------------------------------------

Class Data Sharing (CDS)
==============================
JVM optimization technique

Creates a snapshot of the application classes and then storing them in a archived file
During startup, JVM can refer this archive and get the class file, improving the class-loading time

spring.context.exit-on-refresh=true

-XX:ArchiveClassesAtExit=app-cds.jsa
# On the JVM you plan to deploy to:
java -Xshare:on -XX:SharedArchiveFile=app-cds.jsa -jar myapp.jar

GraalVM native image 
========================
Compiles the Java code into a standalone executable, eliminating the need for a JVM at runtime.


Micrometer
======================

<!-- Micrometer-core -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-core</artifactId>
    <scope>runtime</scope>
</dependency>
<!-- Micrometer-prometheus -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
    <scope>runtime</scope>
</dependency>
	This module enables Prometheus to scrape Micrometer logs
	define our own metrics using Micrometer
	gather them using Prometheus
	display them on a Grafana dashboard

		      (exposes Metrics)  (Tracing + metrics collector and shipment)  (scrape the Metrics)     (query Prometheus)
SpringBoot ------> Actuator  ---->   Micrometer   --------------->             Prometheus     ------>    Grafana (observability backend)
									(monitoring backend : monitoring and alerting toolkit)
                                                                                                      - OpenTelemetry, Jaeger, Zipkin
application.yaml
------------------------------
management:
  server:
    port: 9101
  endpoints:
    web:
      exposure:
        include: health, prometheus
      base-path: "/"
      path-mapping:
        prometheus: "metrics"
  metrics:
    tags:
      application: transfer-service

promotheus.yaml
--------------------------
global:
  scrape_interval: 15s # By default, scrape targets every 15 seconds.
# A scrape configuration containing exactly one endpoint to scrape:
# Here it's Prometheus itself.
scrape_configs:
  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.
  - job_name: 'prometheus'
    # Override the global default and scrape targets from this job every 5 seconds.
    scrape_interval: 5s
    static_configs:
      - targets: [ 'localhost:9090' ]
  - job_name: 'transfer-service'
    # Override the global default and scrape targets from this job every 5 seconds.
    scrape_interval: 2s
    metrics_path: /metrics
    static_configs:
      - targets: [ 'host.docker.internal:9101' ]

Metric type                             Description
------------------                  ----------------------------------------
default
--------
Thread utilization
CPU Usage
Cache utilization
Connection pool

@Autowired
private MeterRegistry meterRegistry;

// http://localhost:9050/orders/v1/getMoviesByDirectorAndGenre/Satyajit Ray/Family
@GetMapping(value = "/getMoviesByDirectorAndGenre/{director}/{genre}", produces = MediaType.APPLICATION_JSON_VALUE)
public ResponseEntity<List<Movie>> getMoviesByDirectorAndGenre(
        @PathVariable("director") String director,
        @PathVariable("genre") String genre) {

    //Counter metric
    Counter counter = Counter.builder("getMoviesByDirectorAndGenre")
            .description("a number of requests to /getMoviesByDirectorAndGenre endpoint")
            .register(meterRegistry);
    counter.increment();

    //Gauge metric
    Gauge.builder("users_count", userService::countUsers)
            .description("A current number of users in the system")
            .register(meterRegistry);

    //Timer metric
    Timer.Sample timer = Timer.start(meterRegistry);

    List<Movie> movies = movieService.getMoviesByDirectorAndGenre(director, genre);

    timer.stop(Timer.builder("getMoviesByDirectorAndGenre_Timer").register(meterRegistry));
    return ResponseEntity.ok(movies);
}

----------------------------------------------------------------------------------------------------------------------

Spring Observability
===============================================================================
Observability is the ability to measure the internal state of a system only by checking its outputs (logs, traces, metrics)
define our own metrics using Micrometer
gather them using Prometheus
display them on a Grafana dashboard


		    (exposes Metrics)           (collects Metrics + own Metrics)  			   (scrape Metrics)              (query Prometheus)
SpringBoot ------> Actuator  ---->   Micrometer   --------------->             Prometheus     ------>    Grafana
									  (Monitoring tool)		                                        (Observability backend)

                                 (Prometheus to scrape Micrometer logs and Micrometer metrics at a configured interval and display them in a Grafana dashboard)

<!-- Web -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<!-- Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<!-- Micrometer-prometheus -->
<!-- This module enables Prometheus to scrape Micrometer logs and Micrometer metrics at a configured interval and display them in a Grafana dashboard-->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
    <scope>runtime</scope>
</dependency>
<!-- AOP, for custom timer -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
<!--OpenTelemetry Tracer: Bridges the Micrometer Observation API to OpenTelemetry-->
<dependency>
  <groupId>io.micrometer</groupId>
  <artifactId>micrometer-tracing-bridge-otel</artifactId>
</dependency>
<!--Zipkin with OpenTelemetry: Reports traces to Zipkin-->
<dependency>
  <groupId>io.opentelemetry</groupId>
  <artifactId>opentelemetry-exporter-zipkin</artifactId>
</dependency>

Actuator
===========================
Exposes metrics by exposing management endpoints - CPU usage, memory usage, request rate, error rate

/health
/info
/env
/loggers
/httptrace
/sessions
/startup
/shutdown

<!-- Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

<!-- Micrometer-prometheus -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
    <scope>runtime</scope>
</dependency>

http://localhost:9050/actuator
//health and info are auto-enabled

management:
  endpoints:
    web:
      exposure:
        include: health, prometheus, metrics, info
  endpoint:
    health:
      show-details: always
    metrics:
      enabled: true
    prometheus:
      enabled: true // Exposes metrics in a format that can be scraped by a Prometheus server.
    info:
      java:
        enabled: true
      env:
        enabled: true

Micrometer
====================
Metrics facade (replaces Spring Cloud Sleuth)
collects Metrics from Actuator + own Metrics
supports Tracers like OpenTelemetry

Micrometer metrics::
-----------------------
Timer                                 measuring short-duration latencies, and the frequency of such events.
Counter				                  count
Gauge	                              current value
DistributionSummary	                  total amount of all recorded events
Micrometer Observation API            lightweight library for application metrics

@Configuration
public class ApplicationConfig {

	  // Monitoring beans
	  @Bean
	  ObservationRegistry observationRegistry() {
	    return ObservationRegistry.create();
	  }
	
	  // To have the @Observed support we need to register this aspect
	  @Bean
	  ObservedAspect observedAspect(ObservationRegistry observationRegistry) {
	    return new ObservedAspect(observationRegistry);
	  }
}

@GetMapping(value = "/hello", produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE)
public ResponseEntity<String> hello() {

    //Counter metric
    Counter counter = Counter.builder("hello")
            .description("gets number of requests to /hello endpoint")
            .register(meterRegistry);
    counter.increment();

    return ResponseEntity.status(HttpStatus.OK)
            .body("Hello World");
}

Prometheus
=====================================
Monitoring tool
Prometheus needs an endpoint(metrics_path) to scrape Micrometer logs and Micrometer metrics at a configured interval and display them in a Grafana dashboard

prometheus.yml
------------------
scrape_configs:
  - job_name: 'SpringBootREST3'
    metrics_path: '/actuator/prometheus'
    scrape_interval: 5s
    static_configs:
      - targets: ['host.docker.internal:9050']
        labels:
          application: 'SpringBootREST3'


Hit the request
    http://localhost:9100/v3/rest/hello
    and then check

Check in Prometheus ::
            http://localhost:9090/
                - prometheus_http_requests_total
                - process_uptime_seconds gauge


management:
  tracing:
    sampling:
      probability: 1.0

How does Prometheus that is running on Docker connect to SpringBoot app that is running on localhost?
---------------------------------------------------------------------------------------------------------------
- targets: ['host.docker.internal:9050']
  host.docker.internal is a host-gateway which is a daemon process routing requests to localhost

Behind the scenes, an observation has been created for the HTTP request, which in turn gets bridged to OpenTelemetry, which reports a new trace to Zipkin.

http://localhost:9090/
- Check Status -> Targets

#TYPE http_server_requests_seconds_count
#TYPE getMoviesOfDirector_time_seconds_max gauge
#TYPE getMoviesOfDirector_time_seconds_count :: gives count of calls

Grafana
======================
Observability backend
Data Visualization service -  create dashboards to visualize and analyze data
Ensure to add Prometheus as a Data Source in Grafana.
query Prometheus(datasources)
     depends_on:
          - prometheus

datasources.yml
----------------------
apiVersion: 1
datasources:
  - name: Prometheus
    type: prometheus
    access: proxy
    url: http://prometheus:9090
    isDefault: true

docker-compose-yml
--------------------------
version: '3.7'

services:
  prometheus:
    image: prom/prometheus:v2.44.0
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus.yml

  grafana:
    image: grafana/grafana:9.5.2
    container_name: grafana
    ports:
      - "3000:3000"
    restart: unless-stopped
    volumes:
      - ./datasources.yml:/etc/datasources.yml
    depends_on:
      - prometheus

http://localhost:3000/ (admin/welcome@1a)

Connect to Prometheus from Grafana
-----------------------------------------
Get Prometheus container id
docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' daca98a3c836
- 172.22.0.2
Prometheus IP in Grafana :: http://172.22.0.2:9090


Running all on Docker
-------------------------
Start the application
Start Docker Desktop
Run docker-compose.yml :: D:\workspace2\SpringBootREST3\src\main\resources>docker-compose up --build
Once done, check in Docker Desktop that prometheus and grafana images are present
Open Gitbash ::
            docker images (prometheus and grafana images)
            docker ps (All running containers, containers with prometheus and grafana images)
Hit http://localhost:9100/v3/rest/hello a few times
Check in Prometheus ::
            http://localhost:9090/
                - prometheus_http_requests_total
                - process_uptime_seconds gauge
Check in Grafana ::
            http://localhost:3000/ (admin/welcome@1a)


----------------------------------------------------------------------------------------------------------------------

OpenTelemetry
================================================
Observability framework for application monitoring by collecting Logs, Traces and Metrics (replaces OpenTracing)
vendor-agnostic

OTLP
-------
OpenTelemetry Protocol is a telemetry data transfer protocol that we can leverage to export the telemetry data to an observability backend.

        		  (exposes Metrics)  (collects Metrics + own Metrics)                           (LTM  :: collection and shipment)
SpringBoot ------> Actuator  ---->   Micrometer    ----------------------->           OTel Collector       ------->           Jaeger (Observability Backend)
                                                   micrometer-tracing-bridge-otel                  opentelemetry-exporter-otlp
pom.xml
-----------

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.2.7</version>
		<relativePath/>
	</parent>
	<groupId>com.example</groupId>
	<artifactId>SpringBootREST3</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>SpringBootREST3</name>
	<description>Demo project for Spring Boot</description>
	<properties>
		<java.version>21</java.version>
	</properties>
	<dependencies>
	            <!-- Web -->
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-web</artifactId>
                </dependency>
                <!-- Actuator -->
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-actuator</artifactId>
                </dependency>
                <!-- AOP, for custom timer -->
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-aop</artifactId>
                </dependency>
                <!-- Micrometer-core -->
                <dependency>
                    <groupId>io.micrometer</groupId>
                    <artifactId>micrometer-core</artifactId>
                    <version>1.11.6</version>
                </dependency>
                <!-- Micrometer-prometheus -->
                <dependency>
                    <groupId>io.micrometer</groupId>
                    <artifactId>micrometer-registry-prometheus</artifactId>
                    <scope>runtime</scope>
                </dependency>
                <!--Bridges the Micrometer Observation API to OpenTelemetry-->
                <dependency>
                    <groupId>io.micrometer</groupId>
                    <artifactId>micrometer-tracing-bridge-otel</artifactId>
                </dependency>
                <!--OpenTelemetry exporter-->
                <dependency>
                    <groupId>io.opentelemetry</groupId>
                    <artifactId>opentelemetry-exporter-otlp</artifactId>
                </dependency>
                <!--Jaeger-->
                <dependency>
                    <groupId>io.opentracing.contrib</groupId>
                    <artifactId>opentracing-spring-jaeger-web-starter</artifactId>
                    <version>3.3.1</version>
                </dependency>
                <!--Jaeger-remote-sampler-->
                <dependency>
                    <groupId>io.opentelemetry</groupId>
                    <artifactId>opentelemetry-sdk-extension-jaeger-remote-sampler</artifactId>
                </dependency>

	</dependencies>

	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>2023.0.0</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

otel-config.yml
------------------

receivers:
  otlp:
    protocols:
      grpc:
      http:

processors:
  batch:

exporters:
  logging:
    loglevel: debug
  jaeger:
    endpoint: jaeger-service:14250
    tls:
      insecure: true

service:
  pipelines:
    traces:
      receivers:  [ otlp ]
      processors: [ batch ]
      exporters:  [ logging, jaeger ]

docker-compose.yaml
--------------------------
version: '3.7'

services:
  collector:
    image: otel/opentelemetry-collector:0.72.0
    command: [ "--config=/etc/otel-collector-config.yml" ]
    volumes:
      - ./otel-config.yml:/etc/otel-collector-config.yml
    ports:
      - "4317:4317"
    depends_on:
      - jaeger-service

  jaeger-service:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686"
      - "14250:14250"
      - "5775:5775/udp"
      - "6831:6831/udp"
      - "6832:6832/udp"

application.yaml
----------------------------
spring:
  application:
    name: SpringBootREST3
  datasource:
    url: jdbc:postgresql://localhost:5432/springbootdb
    username: postgres
    password: tiger
    driver-class-name: org.postgresql.Driver
    hikari:
      connection-timeout: 5000
      maximum-pool-size: 5
  jpa:
    show-sql: true
    properties:
      hibernate:
        format-sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
  main:
    allow-bean-definition-overriding: true


logging:
  level:
    org:
      springframework:
        security: DEBUG
  pattern:
    level: '%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]'

server:
  port: 9100

management:
  endpoints:
    web:
      exposure:
        include: ["health","prometheus","metrics","info"]
  endpoint:
    health:
      show-details: always
    metrics:
      enabled: true
    prometheus:
      enabled: true
  info:
    java:
      enabled: true
    env:
      enabled: true
  tracing:
    sampling:
      probability: 1.0
  otlp:
    tracing:
      endpoint: http://localhost:4318/v1/traces


application:
  spring:
    endpoints:
      exclude: /v3/rest/hello, /v3/rest/helloPost, /v3/rest/home, /actuator/**, /v3/rest/getMoviesOfDirector/**, /v3/rest/getMoviesByDirectorAndGenre/**


opentracing:
  jaeger:
    enabled: true

Jaeger
--------------------------

@Configuration
@ConditionalOnProperty(value = "opentracing.jaeger.enabled", havingValue = "true")
public class JaegerConfig {

    @Bean
    public JaegerTracer jaegerTracer() {
        return new io.jaegertracing.Configuration("SpringBootREST3")
                .withSampler(new io.jaegertracing.Configuration.SamplerConfiguration().withType(ConstSampler.TYPE).withParam(1))
                .withReporter(new io.jaegertracing.Configuration.ReporterConfiguration().withLogSpans(true))
                .getTracer();
    }



}

@RestController
@RequestMapping("/v3/rest")
public class NavController {

    @Autowired
    private HomeService homeService;

    @Autowired
    private MovieService movieService;

    @Autowired
    private MeterRegistry meterRegistry;

    @Autowired
    private JaegerTracer jaegerTracer;

    Logger log = LoggerFactory.getLogger(NavController.class);

    // http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray
    @GetMapping(value = "/getMoviesOfDirector/{director}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<List<Movie>> getMoviesOfDirector(
            @PathVariable("director") String director) {
        Span span = jaegerTracer.buildSpan("getMoviesOfDirector").start();
        log.info("Inside getMoviesOfDirector controller... ");

        //Counter metric
        Counter counter = Counter.builder("getMoviesOfDirector")
                .description("a number of requests to /getMoviesOfDirector endpoint")
                .register(meterRegistry);
        counter.increment();

        //Timer metric
        Timer.Sample timer = Timer.start(meterRegistry);
        Span getHeroDetailsSpan = jaegerTracer.buildSpan("getMoviesOfDirector-Service").asChildOf(span).start();
        List<Movie> movies = movieService.getMoviesOfDirector(director);
        getHeroDetailsSpan.finish();
        span.finish();
        timer.stop(Timer.builder("getMoviesOfDirector_Timer").register(meterRegistry));

        //Observation API
        Observation.createNotStarted("getMoviesOfDirector_Count", observationRegistry)
                .lowCardinalityKeyValue("request-uid", String.valueOf(new Random().nextInt(100)))
                .observe(() -> {
                    List<Movie> movies2 = movieService.getMoviesOfDirector(director);
                    log.debug("Counting getMoviesOfDirector");
                });
        return ResponseEntity.ok(movies);
    }

    // http://localhost:9100/v3/rest/getMoviesByDirectorAndGenre/Satyajit Ray/Comedy
    @GetMapping(value = "/getMoviesByDirectorAndGenre/{director}/{genre}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<List<Movie>> getMoviesByDirectorAndGenre(
            @PathVariable("director") String director,
            @PathVariable("genre") String genre) {

        //Counter metric
        Counter counter = Counter.builder("getMoviesByDirectorAndGenre")
                .description("a number of requests to /getMoviesByDirectorAndGenre endpoint")
                .register(meterRegistry);
        counter.increment();

        //Gauge metric
        Gauge.builder("users_count", movieService::countUsers)
                .description("A current number of users in the system")
                .register(meterRegistry);

        //Timer metric
        Timer.Sample timer = Timer.start(meterRegistry);

        List<Movie> movies = movieService.findByDirectorAndGenre(director, genre);

        timer.stop(Timer.builder("getMoviesByDirectorAndGenre_Timer").register(meterRegistry));
        return ResponseEntity.ok(movies);
    }
}


Running all on Docker
-------------------------
Start the application
Start Docker Desktop
Run docker-compose.yml :: D:\workspace2\SpringBootREST3\src\main\resources>docker-compose up --build
Once done, check in Docker Desktop that Otel Collector and Jaeger images are present
Open Gitbash ::
            docker images (Otel Collector and Jaeger images)
            docker ps (All running containers, containers with Otel Collector and Jaeger image)
Hit http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray a few times
Check in Jaeger ::
           http://localhost:16686/search


-------------------------------------------------------------------------------------------------

OpenTelemetry                            vs                                     Prometheus
===============================================================================================
Logs, Traces and Metrics                                                        Metrics
More scalable
calculates delta                                                               calculates cumulative measurements as a total
Observation API for LTM and transform them into a single language

-------------------------------------------------------------------------------------------------
