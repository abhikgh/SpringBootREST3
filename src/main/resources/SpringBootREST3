SpringBoot
================
1. Java-based Spring-framework to build Spring application
   Eliminates a lot of boiler-plate code required for setting up a Spring application

2. AutoConfiguration ::  Automatically configures beans
    @SpringBootApplication = @Configuration +  @EnableAutoConfiguration  + @ComponentScan
    @Configuration : source for @Bean
    @EnableAutoConfiguration : Spring configures the application based on dependencies and libraries and sets the properties value
    @ComponentScan : Spring searches for Spring beans annotated with @Configuration, @Controller, @Component, @Service, @Repository in the package and the sub-packages and puts them in ApplicationContext
    @Bean - registering your bean in Spring Application Context
    @Autowired - Spring Application Context injects the bean as a Spring Managed Bean(SMB) dependency in another object
	    SMB - Lifecycle management , No new objects, Loose Coupling,  Easier to test
    @RestController = @Controller + @ResponseBody(return value of the method will be serialized into HTTP ResponseBody)
    @Entity - Mapping between the class and the Database table as ORM
    @Transactional - Spring intercepts the method and starts a Transaction before the method - after the method is executed - Commit/Rollback .
        The database transaction happens inside the scope of  Persistence Context.

3. Embedded Tomcat server
4. Spring datasource
    spring:
      datasource:
        url: jdbc:postgresql://localhost:5432/springbootdb
        driver-class-name: org.postgresql.Driver
        username: postgres
        password: ENC(fr05KZkgIQviKiJr2CE6kF042eGwt6QvEFjcccT3ZzU8iM4xforSPVNcul2bKApE)

5. spring-boot starer dependencies
        -makes development much easier and faster, no need to remember dependency versions
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-web</artifactId>
                </dependency>
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-data-jpa</artifactId>
                </dependency>
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-actuator</artifactId>
                </dependency>
		<dependency>
		    <groupId>org.springframework.boot</groupId>
		    <artifactId>spring-boot-starter-security</artifactId>
		</dependency>
5. Plugins
        <artifactId>spring-boot-maven-plugin</artifactId>
        <artifactId>maven-jaxb2-plugin</artifactId>
        <artifactId>jacoco-maven-plugin</artifactId>
6. Actuator

-------------------------------------------------------------------------------------------------

@Component vs @Controller / @Service / @Repository 
------------------------------------------------------------

1. All are Spring-Managed-Beans so their lifecycle will be maintained by the Spring Application Context 
2. @Component is a generic stereotype for any Spring-Managed-Bean.
@Repository is a stereotype for the persistence layer.
@Service is a stereotype for the service layer.
@Controller is a stereotype for the presentation layer (spring-MVC)
3. Meta-data :: DispatcherServlet will check for @GetMapping / @PostMapping in a class annotated with @RestController / @Controller

----------------------------------------------------------------------------------------------------------------------

SpringBoot Architectures
=================================
1.  Microservices API driven architecture - is a software development approach that breaks down an application into a collection of independent services
                              - independently developed, deployed, scaled, managed
2.  Microservices Event driven architecture
3.  Spring security architecture

-------------------------------------------------------------------------------------------------

1. Microservices API driven architecture
==================================================

OAuth2.0
----------
OAuth 2.0 is an Open Authorization Protocol that gives Clients limited access to user accounts on an HTTP service without exposing user credentials and get access to Resource

Delegating the user authentication to a AUTHENTICATION SERVER that hosts user credentials
On successful authentication AUTHENTICATION SERVER returns a JWTToken
Client takes this token to RESOURCE SERVER and after validation of the token for authentication and authorization access is granted
OAuth2.0 SSL is required for all the communications required to generate the token

	     AUTHENTICATION SERVER		  (Authentication)
	 {username, password, clientId, clientSecret, grantType, audience, scope}	            (Resource Owner Password flow)
	 {clientId, clientSecret, grantType, audience, scope}     			            (Client Credential flow)
	         |
      	 	 | {JWTToken}
      		 |		                httpHeaders.set("Authorization", "Bearer JWTToken");
User/Machine    -------> CLIENT  -------------------------------------------------------->       CLOUD DNS             ------------>         RESOURCE SERVER
			                                                                         |
			                                                                AKAMAI (CDN) (IP whitelisting)                   -> validates JWTToken
			                                                                         |                                       -> validates Role from the JWTToken
			                                                                      KONG (Api Gateway)                         -> returns the secure resource to the client
			                                                                         |
			                                                                  CLOUD ARMOUR (firewall)     <---------- CLOUD FUNCTION (policies to support that CA only accepts IPs passed through Akamai)
			                                                                         |
			                                                                    INGRESS (Load Balancer)
			                                                                        |
			                                                                    WORKLOADS (services)

			     AUTHENTICATION SERVER (private key, signature) ----------------> RESOURCE SERVER (public key, verify signature)
                                    -private key : AUTHENTICATION SERVER uses the private key to sign the JWT
                                    -public key  : RESOURCE SERVER uses the public key to verify the signature of the JWTToken (shared widely)

 Benefits :
JWT centralizes authentication & authorization by generating a single shared token that contains user and app-level information
1. CLIENT does not know user credentials - has only the JWTToken
2. Granular access to CLIENT


API Key flow 
-----------------------
Resource-server provides the API Key
Authorization : apiKey
Benefits : low overhead

2. Microservices Event driven architecture
========================================================
1. Spring's event-driven architecture

//create Event
public class OrderPlacedEvent extends ApplicationEvent {
    private final Order order;

    public OrderPlacedEvent(Object source, Order order) {
        super(source);
        this.order = order;
    }

    public Order getOrder() {
        return order;
    }
}

//publish Event
@Service
public class OrderService {

    @Autowired
    private ApplicationEventPublisher applicationEventPublisher;

    public void placeOrder(Order order) {
        // Logic to place the order


        // Publish the order placed event
        applicationEventPublisher.publishEvent(new OrderPlacedEvent(this, order));
    }
}

//Event listener
@Component
public class OrderConfirmationListener {

    @EventListener
    public void handleOrderPlacedEvent(OrderPlacedEvent event) {

        //Logic to manage inventory
        Order order = event.getOrder();

        // Logic to send order confirmation email
        Order order = event.getOrder();

        // Logic to process payment
        Order order = event.getOrder();

        // Process payment for the order
        System.out.println("Payment processed for order: " + order.getId());

        // Send email to the customer confirming the order
        System.out.println("Order confirmation email sent for order: " + order.getId());
    }
}

2. Kafka (See SpringBootKafka)

3. Spring Security Architecture
=======================================================

                UsernamePasswordAuthenticationToken (token)
                     2  ↑                       |3
                        |                       |
             1          |                       ↓
httpRequest ------> UsernamePasswordAuthenticationFilter ---->  AuthenticationManager ------> AuthenticationProvider ------> UserDetailsService (I)   >>>>>>  UserDetails
                                                                (authenticate(token))                                      (loadUserByUserName(userId))
    .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)                                                     |
                                                                                                                                | JWT Token
                                                                                                                                |
                                                                                                                                ↓
                                                                                                                        SecurityContext      -----------> returns JWT Token
                                                                                                                            (JWT Token)

AuthenticationFilter
-----------------------

<filter>
    <filter-name>springSecurityFilterChain</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>
<filter-mapping>
    <filter-name>springSecurityFilterChain</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>

        Servlet                                          ApplicationContext                         SpringSecurityFilterChains
   ----------------------                             ---------------------------------        -------------------------------------

    <filter-name>                                       <filter-name>                               SpringSecurityFilterChains 1
        springSecurityFilterChain                            springSecurityFilterChain                  -SpringSecurityFilter11
    </filter-name>                                      </filter-name>                                  -SpringSecurityFilter12
    <filter-class>                  ----------->        <filter-class>        --------->            SpringSecurityFilterChains 2
        DelegatingFilterProxy                               FilterChainProxy                            -SpringSecurityFilter21
    </filter-class>                                     </filter-class>                                 -SpringSecurityFilter22

@Bean FilterChainProxy :: is created by Spring automatically.
This FilterChainProxy contains a number of SecurityFilterChains and these SecurityFilterChains contain a number of filters.
Every request goes through this SecurityFilterChains.

 .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)


AuthenticationManager
-----------------------
authenticate(UsernamePasswordAuthenticationToken token) - delegates the request to a list of AuthenticationProviders which on successful login returns an Authentication object which is passed to the SecurityContext

UserDetailsService
-----------------------
Interface to retrieve the user’s authentication and authorization information
1 method - UserDetails loadUserByUserName(String userId);

UserDetails
-----------------------
Core class representing user details like principals, credentials, authorities

SecurityContext
-----------------------
Authentication and Authorization information of the user currently accessing the application.

SecurityContextHolder
-----------------------
Core class which holds the SecurityContext
SecurityContextHolder uses “ThreadLocal” variables to store the principal details.

ResponseEntity
-----------------------

return ResponseEntity
                    .status(HttpStatus.OK)
					.header("Custom-header", "value")
					.body(accountMaster);

return ResponseEntity
                .status(HttpStatus.OK)
				.cacheControl(CacheControl.maxAge(getCacheDuration()).noTransform().mustRevalidate())
				.header("test","test")
				.body(orderResponse);

/*
    must-revalidate :
        - Once the cache expires, get new response
        - If a response is cacheable for 10 seconds, then must-revalidate starts after 10 seconds

    no-cache :

 */

----------------------------------------------------------------------------------------------------------------------

Spring Boot Design Patterns
=======================================

1. REST (Synchronous Communication)
----------------------------------------
URI-based
Lightweight (rely on HTTP(s) which means it is format-agonistic, JSON ,XML, html can be used as the messaging format)
Stateless
Cacheable


2. API Gateway
-----------------------------------------
- Authentication
- Authorization
- Routing
- Logging
- Caching
- Transformation
- Rate-limiting (DDoS Protection) (Distributed Denial-of-Service)

Problems
- Single point of failure
- Slower

Example : Orchis APIGW , Kong GW

APIGW has different subscription plans for each consumer that dictates the allowed RPS(Request per second) and the BL (Burst Load).

3. Load Balancing
---------------------------------------
Distributes incoming requests across multiple servers to improve performance, reliability, and availability

4. Service Discovery
-----------------------------
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {

	//Eureka server :: http://localhost:8761/
	public static void main(String[] args) {
		SpringApplication.run(EurekaServerApplication.class, args);
	}
}

eureka:
  client:
    registerWithEureka: true
@SpringBootApplication
@EnableDiscoveryClient
public class SpringConversionFactorApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringConversionFactorApplication.class, args);
	}

}

@Configuration
class WebClientConfig {


    @Bean
    public WebClient webClient(){
         return WebClient
               .builder()
               .baseUrl("http://conversion-factor/eureka")
               .build();

        }

}

//call this Eureka client from another service
 return       webClient
                .get()
                .uri("http://conversion-factor/eureka/v1/getConversionFactor/" + countryCode)
                .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToMono(String.class);

5. Client-side Load Balancing
----------------------------------
SpringCloud LoadBalancer :: calling EurekaClient in a Load-Balanced manner

@Configuration
public class ServiceInstanceConfig {

    @Bean
    public ServiceInstanceListSupplier serviceInstanceListSupplier(){
        return new ServiceInstanceSupplier("conversion-factor");
    }
}

@LoadBalancerClient(name = "conversion-factor", configuration = ServiceInstanceConfig.class)
@Configuration
class WebClientConfig {


    @Bean
    public WebClient webClient(){
         return WebClient
               .builder()
               .baseUrl("http://conversion-factor/eureka")
               .build();

        }

}



@RestController
public class NavigationController {

    @Autowired
    private WebClient webClient;

    //http://localhost:8071/getConversionFactorClient/AUD
    @GetMapping(value = "/getConversionFactorClient/{countryCode}", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<String> convertCurrency(@PathVariable("countryCode") String countryCode) {

    //call the Eureka client from another service in a load-balanced manner
        return webClient
                .get()
                .uri("/v1/getConversionFactor/" + countryCode)
                .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToMono(String.class);


    }

}

6. Pub/Sub (Asynchronous Communication)
-----------------------------------------
Decouples message producers and consumers, improves scalability and flexibility.


7. Dependency Injection
-------------------------------
-Design framework by which Spring container “injects” dependent objects into other objects
-Makes loosely-coupled applications

           1.Field Injection:

            @Component
            public class MyService {

                @Autowired
                private MyRepository repository;  //does not allow final
            }

        2. Constructor Injection:

            @Component
            public class MyService {
                private final MyRepository repository;

                @Autowired
                public MyService(MyRepository repository) {
                    this.repository = repository;   //preferred :: All dependencies are provided at compile-time, improved testing
                }
            }

        3. Setter Injection :

            @Component
            public class MyService {
                private MyRepository repository;

                @Autowired
                public void setRepository(MyRepository repository) {
                    this.repository = repository;
                }
            }


8. Singleton
------------------
        -  1 instance in the ApplicationContext
        -  Spring-Managed-Beans are singleton by default
        -  Lifecycle managed by container

public class SingletonEx {

	private static volatile SingletonEx singletonEx = null;

	// prevent Object creation by Constructor
	private SingletonEx() {
		//do nothing
	}

	// prevent Object creation by Cloning
	@Override
	protected Object clone() throws CloneNotSupportedException {
		throw new CloneNotSupportedException();
	}

	// get Object instance by Double-check locking
	public static SingletonEx getInstance() {
		if (Objects.isNull(singletonEx)) {
			synchronized (SingletonEx.class) {
				if (Objects.isNull(singletonEx)) {
					singletonEx = new SingletonEx();
				}
			}
		}
		return singletonEx;
	}
}

9. Factory
---------------------------------------
 Factory will have all the objects whichever is needed at runtime will be provided

        public interface PaymentProvider {
            void acceptPayment();
        }


        @Service("GPayPayment") //service value
        public class GPayPayment implements PaymentProvider{

            @Override
            public void acceptPayment() {
                System.out.println("GPay payment...");
            }
        }

        @Service("WhatsAppPayment") //service value
        public class WhatsAppPayment implements PaymentProvider{

            @Override
            public void acceptPayment() {
                System.out.println("WhatsApp payment...");
            }
        }


        @Service
        @AllArgsConstructor
        public class PaymentFactory {
            public Map<String, PaymentProvider> paymentProviderMap;

            public PaymentProvider getPayment(String paymentProviderType) {
                return paymentProviderMap.get(paymentProviderType);
            }

        }

        @SpringBootApplication
        public class SpringBootRest2Application implements CommandLineRunner {

            @Autowired
            private PaymentFactory paymentFactory;

            public static void main(String[] args) {
                SpringApplication.run(SpringBootRest2Application.class, args);
            }

            @Override
            public void run(String... args) throws Exception {
                WhatsAppPayment whatsAppPayment = (WhatsAppPayment) paymentFactory.getPayment("WhatsAppPayment");
                whatsAppPayment.acceptPayment();    //WhatsApp payment...
                GPayPayment gPayPayment = (GPayPayment) paymentFactory.getPayment("GPayPayment");
                gPayPayment.acceptPayment();         //GPay payment...
            }
        }



10. Builder Design pattern
-------------------------------
        - @Builder
        User user = User.builder()
                        .username("john_doe")
                        .email("john@example.com")
                        .age(30)
                        .build();

11. Aspect Design pattern (Proxy/Sidecar)
------------------------------------------------
- AOP framework to apply cross-cutting concerns to modules without changing their core logic

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>

Aspect :: module for cross-cutting-concerns
JoinPoint :: method where Aspect gets plugged-in
Advice :: action taken by an Aspect at a particular Joinpoint ("before", "after", "around")
Pointcut :: expression that selects one or more JoinPoints where Advice is executed.



1. Annotation

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Logging {
}

2. Aspect

@Aspect
@Component
@Slf4j
public class LoggingAspect {

    /*
        1. @Around -> Advice
        2. aroundGovernedTransaction -> JoinPoint
	3. @annotation(Logging) -> PointCut
    */
    @Around("@annotation(Logging)")
    public Object aroundGovernedTransaction(ProceedingJoinPoint joinPoint) throws Throwable {
        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();

        //Get intercepted method details
        String methodName = methodSignature.getName();
        String className = methodSignature.getDeclaringType().getSimpleName();

        long start = System.currentTimeMillis();
        String transactionId = UUID.randomUUID().toString();
        MDC.put("transactionId", transactionId);
        beforeGoverenedTransaction(methodName, className);
        Object response = joinPoint.proceed(); //executes the joinpoint
        afterGovernedTransaction(methodName, className, start);
        return response;
    }

    private void beforeGoverenedTransaction(String methodName, String className) {
        log.info("Start :: Method {} , transactionId is {}", methodName + ":" +className, MDC.get("transactionId"));
    }

    private void afterGovernedTransaction(String methodName, String className, long start) {
        log.info("End :: Method {} , transactionId is {}, time in millis {}", methodName + ":" +className, MDC.get("transactionId"), System.currentTimeMillis() - start);
    }

}

3. @Logging
public ResponseEntity<OrderResponse> getOrder(



12. Backend for Frontend
--------------------------------------------
Separate APIGWs for separate types of client

    Clients                 BFF                 Services
    ---------           -----------             ------------

    Web                   Web API GW             Authentication / Authorization

    Mobile                Mobile API GW          Service A

    Other clients         Other API GW           Service B

-optimised
-scalable

13. Command Query Responsibility Segregation (CQRS)
---------------------------------------------------------------------------

Separates Commands(write to Database) from Queries(reading from Database) into separate services
-auditing
-scalable


14. Circuit Breaker
---------------------------------------------------------------------------


                                    Count-based / Time-based          Count-based / Time-based
                    CLOSED     ------------------>     HALF-OPEN      ------------------>       OPEN
                 ( success )                                             ( failure )
                 ( normal )                                              ( fallback )
                            <-----------------------------------------------------------
                                            (reset breaker)
<!-- Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

<!-- AOP -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>

<!-- Resilience -->
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot3</artifactId>
    <version>2.0.2</version>
</dependency>


resilience4j:
  circuitbreaker:
    instances:
      getMoviesOfDirector_CB:
        register-health-indicator: true
        sliding-window-type: count_based
        sliding-window-size: 10
        failure-rate-threshold: 70 #Circuitbreaker will open if 70% of the last 10 calls failed
        slow-call-rate-threshold: 40
        slow-call-duration-threshold: 2s
        permitted-number-of-calls-in-half-open-state: 1
        max-wait-duration-in-half-open-state: 10s
        wait-duration-in-open-state: 10s
        writable-stack-trace-enabled: true
        automatic-transition-from-open-to-half-open-enabled: true

@GetMapping(value = "/getMoviesOfDirector", produces = MediaType.APPLICATION_JSON_VALUE)
@SneakyThrows
@Logging
@CircuitBreaker(name = "getMoviesOfDirector_CB",fallbackMethod = "getDummyValue")
@RateLimiter(name = "basic")
@Bulkhead(name = "serviceA", fallbackMethod = "getDummyValue")
public List<Movie> getMoviesOfDirector(
        @RequestParam(value = "director") String director) {
    director = director.replaceAll(" ", "%20");

    //Endpoint
    String endpoint = "http://localhost:9050/orders/v1/getMoviesOfDirector/" + director;
    URI uri = new URI(endpoint);

    return restClientService.getMoviesOfDirector(uri, director);
}

public List<Movie> getDummyValue(Exception exception){
    List<Movie> list = new ArrayList<>();
    Movie movie = new Movie();
    movie.setMovieId(100);
    movie.setMovieName("someName");
    list.add(movie);
    return list;
}

Benefits
    Fail Fast
    Prevents Cascading Failures
    Improves Resilience
    Fault Tolerance

15. Rate-limiter
---------------------------------------------------------------------------

resilience4j:
  ratelimiter:
      instances:
        basic:
          limitForPeriod: 2
          limitRefreshPeriod: 1s # 2RPS
          timeoutDuration: 10s     #time to acquire permission from RateLimiter before erroring out.

@GetMapping(value = "/getMoviesOfDirector", produces = MediaType.APPLICATION_JSON_VALUE)
@SneakyThrows
@Logging
@CircuitBreaker(name = "getMoviesOfDirector_CB",fallbackMethod = "getDummyValue")
@RateLimiter(name = "basic")
@Bulkhead(name = "serviceA", fallbackMethod = "getDummyValue")
public List<Movie> getMoviesOfDirector(
        @RequestParam(value = "director") String director) {
    director = director.replaceAll(" ", "%20");

    //Endpoint
    String endpoint = "http://localhost:9050/orders/v1/getMoviesOfDirector/" + director;
    URI uri = new URI(endpoint);

    return restClientService.getMoviesOfDirector(uri, director);
}

16. Bulkhead
---------------------------------------------------------------------------
Latency in one service should not migrate to the whole system

resilience4j:
   bulkhead:
     instances:
       serviceA:
         maxConcurrentCalls: 1

@GetMapping(value = "/getMoviesOfDirector", produces = MediaType.APPLICATION_JSON_VALUE)
@SneakyThrows
@Logging
@CircuitBreaker(name = "getMoviesOfDirector_CB",fallbackMethod = "getDummyValue")
@RateLimiter(name = "basic")
@Bulkhead(name = "serviceA", fallbackMethod = "getDummyValue")
public List<Movie> getMoviesOfDirector(
        @RequestParam(value = "director") String director) {
    director = director.replaceAll(" ", "%20");

    //Endpoint
    String endpoint = "http://localhost:9050/orders/v1/getMoviesOfDirector/" + director;
    URI uri = new URI(endpoint);

    return restClientService.getMoviesOfDirector(uri, director);
}

public List<Movie> getDummyValue(Exception exception){
    List<Movie> list = new ArrayList<>();
    Movie movie = new Movie();
    movie.setMovieId(100);
    movie.setMovieName("someName");
    list.add(movie);
    return list;
}

17. Event Sourcing
---------------------------------------------------------------------------
Event logs
- auditing
- analytics


18. Strangler pattern
---------------------------------------------------------------------------
Design pattern that incrementally transforms the monolithic application to microservice by replacing a particular functionality with a new service.
Once the new functionality is ready, the old component is decommissioned.
Candidate for Test-Driven Development


19. 2-phase commit (2PC)
-----------------------------------------------
Immediate Transactions
Commit or rollback entire transaction

Phase1 : Prepare
                                   Service 1
                                    | C?  |
                                    |      | Y/N        C?
          Client   --------------> Controller   ----------->        Service 2
                                    |     |     <-----------
                                 C? |     | Y/N            Y/N
                                  Service 3

Phase2 : Commit

                         Service 1
                                  | C/R  |
                                  |      | +/-        C/R
        Client   --------------> Controller   ----------->        Service 2
                                  |     |     <-----------
                               C/R|     | +/-           +/-
                                Service 3


20. Saga
---------------------------------------------------------------------------
Data consistency in Distributed Transactions
Every transaction has a corresponding Rollback action
This design pattern splits a large transaction into a series of smaller, isolated operations.
 - Resiliency
 - Eventually consistent

CHOREOGRAPHY
----------------------

    Order service ----------> Payment service -------> Catering service  ---------> Delivery service
                <--------------------->
                <--------------------------------------------->
                <-------------------------------------------------------------------------->


ORCHESTRATION
----------------------

        Order service               Payment service       Catering service      Delivery service
            \   \ (4)           /         /               /               /       /           /
             \   \           /         /            /               /       /           /
              \   \         /         /         /           /           /           /
               Orchestrator

Controller  ----> processBooking (DB)             processPayment (DB)             (a+b) ? Confirm booking : Cancel booking
                        |                       /       |                       /
                O   R   C   H   E   S   T   R   A   T   O   R   (Kafka Listener)


Controller \    processBooking (DB)             processPayment (DB)             (a+b) ? Confirm booking : Cancel booking
            \            |        \               /       |                       /
                O   R   C   H   E   S   T   R   A   T   O   R   (Kafka Listener)

-------------------------------------------------------------------------------------------------

Security in Architecture
==========================================

RESTT APIs are protected by OAuth2.0 Authentication protocol by JWT token with Client Credentials flow
sonar / GHAS -  Code scanning for security vulnerabilities, secret scanning, Dependency review
trivy : image scan for security vulnerabilities + dependency updates
Renovate :  automates dependency management 
GCP Security Command center : for Threats and vulnerabilities
AKAMAI (IP whitelisting)  
KONG (Api Gateway)     
CLOUD ARMOUR (firewall) <- CLOUD FUNCTION (WAF rules to support that CA only accepts IPs passed through Akamai)
@JsonIgnoreProperties(ignoreUnknown = true)
Pen test - API penetration testing is a security testing method that simulates hacker attacks to evaluate the security of an API

-------------------------------------------------------------------------------------------------

Anti-Patterns in Spring Boot
===========================================

1. Choose Constructor Injection over Field and Setter Injection
2. Avoid 1 Controller if too many endpoints
3. Constants should be in class, not in Interface
4. Don’t integrate Spring to Core Business Logic

---------------------------------------------------------------------------------------------------------------------------

Tools
--------------
JMeter: For load testing and establishing basic throughput numbers
Micrometer + Prometheus + Grafana: For real-time monitoring and visualization
JProfiler: For deep-dive analysis of hotspots in the code

---------------------------------------------------------------------------------------------------------------------------

Microservice Optimizations  (for heavy traffic)
=====================================================

1. Load Balancer
2. Rate Limiting
3. Circuit Breaker
4. Clustering (group multiple servers into a cluster - so that if 1 server fails other can process the request)
5. Horizontal pod auto-scaling :: adding more servers

6.@JsonInclude(JsonInclude.Include.NON_NULL)
  @JsonIgnoreProperties(ignoreUnknown = true)
7. Reactive Programming (Mono / Flux)
8. ASync
9. Caching
10. Streaming

11. Indexing
12. Native query
13. Batch Processing
14. DTO projection
15. Lazy Loading
16. Hikari CP Optimisation
17. Avoid N+1
   
-------------------------------------------------------------------------------------------------

Key Challenges in High-Traffic Systems
===========================================================

Scalability:
Latency :
Fault Tolerance: handling partial failures.
Data Consistency:

Horizontal Scaling vs Vertical Scaling
-----------------------------------------------

Horizontal scaling :: adding more servers
	AutoScaling happens depending on the Pod - Resource metrics - like CPU usage, memory usage, request count
	--- HPA (Horizontal Pod Autoscaler) ---
	kubectl autoscale deployment endpoints --cpu-percent=50 --min=1 --max=10
Vertical Scaling   :: adding more resources to existing server , like more CPU, RAM, Network, Storage


------------------------------------------------------------------------------------------------------------------------

SpringBoot3 changes
===========================================================

1. 	<version>3.2.7</version>
	<java.version>21</java.version>
	<spring-cloud.version>2023.0.0</spring-cloud.version>
	<openapi.version>2.2.0</openapi.version>

2. <!--Lombok-->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.30</version>
    <scope>provided</scope>
</dependency>

3. javax.persistence -> jakarta.persistence

4. JSONB ->  @Type(JsonBinaryType.class)

5. Security ->

6. Observability -> 

7. jaxb-api -> 

	    <groupId>javax.xml.bind</groupId>
            <artifactId>jaxb-api</artifactId>			is replaced with
            
	    <groupId>jakarta.xml.bind</groupId>
            <artifactId>jakarta.xml.bind-api</artifactId>

8. Swagger -> 

	    <dependency>
            <groupId>org.springdoc</groupId>
            	<artifactId>springdoc-openapi-webmvc-core</artifactId>
            <artifactId>springdoc-openapi-starter-webmvc-api</artifactId>
            <version>${openapi.version}</version>
        </dependency>

9. Tests -> 	@MockBean 		is replaced with 

		        @Mock

ApplicationConfig
========================

@Configuration
public class ApplicationConfig {

    //TomcatProtocolHandler is responsible for handling incoming requests in a Spring Boot application
    //TomcatProtocolHandlerCustomizer configures the Executor
    //Executor is responsible for executing tasks, like handling incoming requests
    //Virtual Threads
    @Bean
    TomcatProtocolHandlerCustomizer<?> tomcatProtocolHandlerCustomizer() {
        return tomcatProtocolHandlerCustomizer -> {
            tomcatProtocolHandlerCustomizer.setExecutor(Executors.newVirtualThreadPerTaskExecutor()); //executor service that creates a new Virtual Thread for each task submitted to it
        };
    }

    // Monitoring beans
    @Bean
    ObservationRegistry observationRegistry() {
        return ObservationRegistry.create();
    }

    // To have the @Observed support we need to register this aspect
    @Bean
    ObservedAspect observedAspect(ObservationRegistry observationRegistry) {
        return new ObservedAspect(observationRegistry);
    }
}
---------------------------------------------------------------------------------------------------------
Spring Boot 3 Secured Endpoint
---------------------------------
1. pom
<!-- Web -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!-- Spring Security -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<!-- JWT -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>

<!-- jaxb -->
<dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>
    <version>2.3.0</version>
</dependency>

//2. Secured endpoint
// http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray
// Authorization
// Type     -> Bearer Token
// Token    -> eyJhbGciOiJIUzUxMiJ9...
// JWT Token is in the form of Bearer Token
@GetMapping(value = "/getMoviesOfDirector/{director}", produces = MediaType.APPLICATION_JSON_VALUE)
public ResponseEntity<List<Movie>> getMoviesOfDirector(
        @PathVariable("director") String director) {
    Span span = jaegerTracer.buildSpan("getMoviesOfDirector").start();
    log.info("Inside getMoviesOfDirector controller... ");

    //Counter metric
    Counter counter = Counter.builder("getMoviesOfDirector")
            .description("a number of requests to /getMoviesOfDirector endpoint")
            .register(meterRegistry);
    counter.increment();

    //Timer metric
    Timer.Sample timer = Timer.start(meterRegistry);
    Span getHeroDetailsSpan = jaegerTracer.buildSpan("getMoviesOfDirector-Service").asChildOf(span).start();
    List<Movie> movies = movieService.getMoviesOfDirector(director);
    getHeroDetailsSpan.finish();
    span.finish();
    timer.stop(Timer.builder("getMoviesOfDirector_Timer").register(meterRegistry));

    //Observation API
    Observation.createNotStarted("getMoviesOfDirector_Count", observationRegistry)
            .lowCardinalityKeyValue("request-uid", String.valueOf(new Random().nextInt(100)))
            .observe(() -> {
                List<Movie> movies2 = movieService.getMoviesOfDirector(director);
                log.debug("Counting getMoviesOfDirector");
            });

    return ResponseEntity.ok(movies);
}

So to hit this endpoint from Postman, first get the JWT Token from the Auth-Server and pass the JWT token as Bearer token in the endpoint

3. Authentication endpoint
================================
//http://localhost:9100/v3/rest/authenticate
/*
    {
    "userId":"eyabhikg",
    "password":"12345"
    }
 */
//var jsonData = JSON.parse(responseBody);
//pm.environment.set("SB3_BEARER_TOKEN", jsonData['jwt']);
@PostMapping("/authenticate")
public AuthenticationResponse authenticate(@RequestBody Map<String, Object> claims){

    try {
        log.info("In authenticate method...");
        authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(claims.get("userId"), claims.get("password")));
    } catch (Exception e) {
        log.error("Authentication Error.......");
        throw new OrderException("101", "Invalid username or password", HttpStatus.BAD_REQUEST);
    }

    UserDetails userDetails = userService.loadUserByUsername(String.valueOf(claims.get("userId")));
    String jwt = jwtTokenUtil.generateToken(userDetails);
    return ResponseEntity
            .status(HttpStatus.OK)
            .body(new AuthenticationResponse(userDetails.getUsername(), userDetails.getAuthorities().stream().map(String::valueOf).toList().getFirst(), jwt))
            .getBody();

}


4. JWTTokenUtil
----------------------
// generate JWT token for user
public String generateToken(UserDetails userDetails) {
    Map<String, Object> claims = new HashMap<>();

    claims.put("client_id",userDetails.getUsername());
    claims.put("client_secret","3333");
    claims.put("subject","devtest");
    claims.put("scope","user");
    claims.put("issuer","application");

    return Jwts.builder()
            .setClaims(claims)
            .setSubject(userDetails.getUsername())
            .setIssuedAt(new Date(System.currentTimeMillis()))
            .setExpiration(new Date(System.currentTimeMillis()  + expirationInMillis))
            .signWith(SignatureAlgorithm.HS512, secret)
        .compact();
}

5. SecurityConfig
----------------------

@Configuration
@EnableWebSecurity
public class SecurityConfig {

   @Value("${application.spring.endpoints.exclude}")
   private String[] applicationApisToBeExcluded;

    @Value("${service.endpoints.exclude:}")
    private String[] serviceApisToBeExcluded;

    @Autowired
    private UserService userService;

    @Autowired
    private JWTFilter jwtFilter;

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userService);
        authProvider.setPasswordEncoder(new BCryptPasswordEncoder());
        return authProvider;
    }

    private String[] allApisToBeExcluded(){
        return applicationApisToBeExcluded;

        /* return Stream.of(applicationApisToBeExcluded, serviceApisToBeExcluded)
                .flatMap(Stream::of)
                .toArray(String[]::new);*/
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {
        return httpSecurity
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(requests -> requests.requestMatchers(allApisToBeExcluded()).permitAll().anyRequest().authenticated())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }
}


6. JWT Filter
-----------------------

@Component
public class JWTFilter extends OncePerRequestFilter {

    @Autowired
    private JWTTokenUtil jwtTokenUtil;

    @Autowired
    private UserService userService;

    // Intercept each request ,extract the JWT from the Request header ,validate and put the JWT in the SecurityContext
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        try {
            //gets the Authorization header
            String bearerToken = request.getHeader("Authorization");
            if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {

                // JWT Token is in the form of Bearer Token
                // Authorization  :: Bearer dkdllslsl
                String jwtToken = bearerToken.substring(7);
                String username = jwtTokenUtil.getUsernameFromToken(jwtToken);

                if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {

                    UserDetails userDetails = userService.loadUserByUsername(username);
                    if (jwtTokenUtil.validateToken(jwtToken, userDetails)) {

                        //UsernamePasswordAuthenticationToken(Object principal, Object credentials, Collection<? extends GrantedAuthority> authorities)
                        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(
                                userDetails, null, userDetails.getAuthorities());
                        usernamePasswordAuthenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                        SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);
                    }
                }

            }
        }catch (ExpiredJwtException ex){

        }
        filterChain.doFilter(request, response);
    }


}


7. Service  (implementing UserDetailsService)
----------------------------------------------

@Service
public class UserService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private AccountRepository accountRepository;

    @Override
    public UserDetails loadUserByUsername(String userId) throws UsernameNotFoundException {
        UserMaster userMaster = userRepository.findByUserId(userId);

        if (userMaster == null) {
            System.out.println("User not found");
            throw new UsernameNotFoundException("User not found");
        }

        return
                User
                    .builder()
                    .username(userMaster.getUserId())
                    .password(userMaster.getPassword())
                    .roles(userMaster.getRoleCode())
                    .build();

    }

}

----------------------------------------------------------------------------------------------------------------------
Spring Boot 3 Secured Endpoint client
-------------------------------------------

@Configuration
public class RestClientConfig {

    @Bean(name = "restClient1")
    public RestClient restClient() {
        return RestClient
                .builder()
                .baseUrl("http://localhost:9100/v3/rest")
                .defaultHeader(HttpHeaders.CONTENT_ENCODING,"gzip")
                .defaultHeader(HttpHeaders.ACCEPT_ENCODING,"gzip")
                .build();
    }

}

@Autowired
@Qualifier("restClient1")
private RestClient restClient;

public List<Movie> getMoviesOfDirectorClient(String director) {
    HttpHeaders httpHeaders = new HttpHeaders();
    httpHeaders.set("Authorization","Bearer " + getJWTToken());
    return
            restClient
                .get()
                .uri("/getMoviesOfDirector/" + director)
                .headers(headers -> headers.addAll(httpHeaders))
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .body(new ParameterizedTypeReference<>() {});
}

private String getJWTToken() {
    Map<String, Object> claims = new HashMap<>();
    claims.put("userId","eyabhikg");
    claims.put("password", "12345");

    String jwt =
            Objects.requireNonNull(restClient
                                    .post()
                                    .uri("/authenticate")
                                    .contentType(MediaType.APPLICATION_JSON)
                                    .accept(MediaType.APPLICATION_JSON)
                                    .body(claims)
                                    .retrieve()
                                    .body(AuthenticationResponse.class))
                    .getJwt();

    System.out.println("jwt - " + jwt);
    return jwt;
}

--------------------------------------------------------------------------------------------------------

ASync client
-------------------------------------------

@EnableAsync
@Configuration
public class ASyncConfig {

    @Bean
    public ThreadPoolTaskExecutor threadPoolTaskExecutor(){
        ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();
        threadPoolTaskExecutor.setMaxPoolSize(100);
        threadPoolTaskExecutor.setThreadNamePrefix("ASync-1");
        threadPoolTaskExecutor.initialize();
        return threadPoolTaskExecutor;
    }
}

@SneakyThrows
public HeroDetailsResponse getHeroDetailsASync(HeroDetailsRequest heroDetailsRequest) {
    HeroDetailsResponse heroDetailsResponse = new HeroDetailsResponse();
    List<Hero> heroList = new ArrayList<>();
    List<CompletableFuture<Hero>> cfs = heroDetailsRequest.getHeroNames().stream().map(this::getHeroDetails).toList();
    //join all the CFs
    CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0])).join();
    //get the results from each of the CF
    for(CompletableFuture<Hero> completableFuture : cfs){
        if(completableFuture.isDone()){
            heroList.add(completableFuture.get());
        }
    }
    heroDetailsResponse.setHeroList(heroList);
    return heroDetailsResponse;
}

@Async(value = "threadPoolTaskExecutor")
private CompletableFuture<Hero> getHeroDetails(String heroName) {
    System.out.println("ASync Thread :: " + Thread.currentThread().getName());
    Hero hero = restClient2
                .get()
                .uri("/getHeroDetails/"+heroName)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .body(Hero.class);
    return CompletableFuture.completedFuture(hero);
}

External services but may experience intermittent failures or downtime
------------------------------------------------------------------------------

Retry / Circuit-Breaker

Retry is when the failure is expected to be short-lived
Circuit-Breaker is when the failure is expected to be long-lived as the connection will be broken

---------------------------------------------------------------------------------------------------

Spring Retry
======================

<!-- Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<!-- AOP -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
<!-- spring-retry -->
<dependency>
    <groupId>org.springframework.retry</groupId>
    <artifactId>spring-retry</artifactId>
    <version>1.3.2</version>
</dependency>


@EnableRetry

@SneakyThrows
@Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 3))
public HeroDetailsResponse getHeroDetailsASync(HeroDetailsRequest heroDetailsRequest) {
    HeroDetailsResponse heroDetailsResponse = new HeroDetailsResponse();
    List<Hero> heroList = new ArrayList<>();
    List<CompletableFuture<Hero>> cfs = heroDetailsRequest.getHeroNames().stream().map(this::getHeroDetails).toList();
    //join all the CFs
    CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0])).join();
    //get the results from each of the CF
    for(CompletableFuture<Hero> completableFuture : cfs){
        if(completableFuture.isDone()){
            heroList.add(completableFuture.get());
        }
    }
    heroDetailsResponse.setHeroList(heroList);
    return heroDetailsResponse;
}

@Async(value = "threadPoolTaskExecutor")
private CompletableFuture<Hero> getHeroDetails(String heroName) {
    if (Objects.nonNull(RetrySynchronizationManager.getContext()) && RetrySynchronizationManager.getContext().getRetryCount() > 0) {
        System.out.println(String.format("Retry count %d for service %s", RetrySynchronizationManager.getContext().getRetryCount(), "getHeroDetails"));
    }
    Hero hero = restClient2
                .get()
                .uri("/getHeroDetails/"+heroName)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .body(Hero.class);
    return CompletableFuture.completedFuture(hero);
}

@Recover
public HeroDetailsResponse defaultGetHeroDetails(Exception exception){
    return new HeroDetailsResponse();
}

---------------------------------------------------------------------------------------------------

Circuit-Breaker
--------------------

<!-- Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<!-- AOP -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
<!-- Resilience -->
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot3</artifactId>
    <version>2.0.2</version>
</dependency>


resilience4j:
  circuitbreaker:
    instances:
      getHeroDetails_CB:
        register-health-indicator: true
        sliding-window-type: count_based
        sliding-window-size: 10
        failure-rate-threshold: 70 #Circuitbreaker will open if 70% of the last 10 calls failed
        slow-call-rate-threshold: 40
        slow-call-duration-threshold: 2s
        permitted-number-of-calls-in-half-open-state: 1
        max-wait-duration-in-half-open-state: 10s
        wait-duration-in-open-state: 10s
        writable-stack-trace-enabled: true
        automatic-transition-from-open-to-half-open-enabled: true


@SneakyThrows
//@Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 3))
@CircuitBreaker(name = "getHeroDetails_CB", fallbackMethod = "getDummyMethod")
public HeroDetailsResponse getHeroDetailsASync(HeroDetailsRequest heroDetailsRequest) {
    HeroDetailsResponse heroDetailsResponse = new HeroDetailsResponse();
    List<Hero> heroList = new ArrayList<>();
    List<CompletableFuture<Hero>> cfs = heroDetailsRequest.getHeroNames().stream().map(this::getHeroDetails).toList();
    //join all the CFs
    CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0])).join();
    //get the results from each of the CF
    for(CompletableFuture<Hero> completableFuture : cfs){
        if(completableFuture.isDone()){
            heroList.add(completableFuture.get());
        }
    }
    heroDetailsResponse.setHeroList(heroList);
    return heroDetailsResponse;
}

@Recover
public HeroDetailsResponse defaultGetHeroDetails(Exception exception){
    return new HeroDetailsResponse();
}

public HeroDetailsResponse getDummyMethod(Exception exception){
    System.out.println("In circuit-breaker fallback...");
    return new HeroDetailsResponse();
}

management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: always
  health:
    circuitbreakers:
      enabled: true

http://localhost:9101/actuator/health

--------------------------------------------------------------------------------------------------------
Exception Handler
---------------------

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(OrderException.class)
    public ResponseEntity<ErrorResponse> handleOrderException(OrderException oe) {
        ErrorResponse errorResponse = new ErrorResponse(oe.getErrorCode(), oe.getErrorMessage(), oe.getHttpStatus());
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(errorResponse);
    }

    @ExceptionHandler(SPEException.class)
    public ResponseEntity<ErrorCodeProperties> handleSPEException(SPEException speException) {
        ErrorCodeProperties errorCodeProperties = new ErrorCodeProperties(speException.getGroup(),
                                                                          speException.getType(),
                                                                          speException.getMessage(),
                                                                          speException.getInfoMessage(),
                                                                          speException.getHttpStatus());
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(errorCodeProperties);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleMethodArgumentNotValidException(MethodArgumentNotValidException me) {
        String errorMessage = "Error in object '%s', error in field '%s', error is '%s'";
        FieldError fieldError = me.getBindingResult().getFieldError();
        errorMessage = String.format(errorMessage, fieldError.getObjectName(), fieldError.getField(), fieldError.getDefaultMessage());
        ErrorResponse errorResponse = new ErrorResponse("101", errorMessage, HttpStatus.BAD_REQUEST);
        return ResponseEntity
                .badRequest()
                .body(errorResponse);
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorResponse> handleDataIntegrityViolationException(DataIntegrityViolationException de){
        String errorMessage  = de.getMostSpecificCause().getMessage();
        ErrorResponse errorResponse = new ErrorResponse("401", errorMessage, HttpStatus.BAD_REQUEST);
        return ResponseEntity
                .badRequest()
                .body(errorResponse);
    }

}

@SpringBootApplication
@EncryptablePropertySource("classpath:errorMessages_en.properties")
public class SpringBootRest3Application {

	public static void main(String[] args) {
		SpringApplication.run(SpringBootRest3Application.class, args);
	}

}

error.message.validation.itemMismatch = Item does not match
error.message.validation.itemTypeMismatch = Item Type does not match
error.message.dataConnection.itemAndItemTypeMismatch = Item and Item type mismatch

error.infomessage.validation.itemMismatch = Item does not match for %1s
error.infomessage.validation.itemTypeMismatch = Item Type does not match for %1s
error.infomessage.dataConnection.itemAndItemTypeMismatch = Item and Item type mismatch for %1s:%2s



@Configuration
@ConfigurationProperties(prefix = "error.message")
@Data
@Validated
public class ErrorMessageProperties {

    @Valid
    private final ErrorMessageProperties.Validation validation = new ErrorMessageProperties.Validation();

    @Valid
    private final ErrorMessageProperties.DataConnection dataConnection = new ErrorMessageProperties.DataConnection();

    @Data
    public static class Validation {
        @NotNull
        private String itemMismatch;
        @NotNull
        private String itemTypeMismatch;
    }

    @Data
    public static class DataConnection {
        @NotNull
        private String itemAndItemTypeMismatch;

    }
}


@Configuration
@ConfigurationProperties(prefix = "error.infomessage")
@Data
public class ErrorInfoMessageProperties {

    @Valid
    private final ErrorInfoMessageProperties.Validation validation = new ErrorInfoMessageProperties.Validation();

    @Valid
    private final ErrorInfoMessageProperties.DataConnection dataConnection = new ErrorInfoMessageProperties.DataConnection();

    @Data
    public static class Validation {
        @NotNull
        private String itemMismatch;
        @NotNull
        private String itemTypeMismatch;
    }

    @Data
    public static class DataConnection {
        @NotNull
        private String itemAndItemTypeMismatch;
    }
}



@Component
public class ErrorProperties {

    private final Map<ErrorCode, ErrorCodeProperties> errorPropertiesMap;

    public ErrorProperties(ErrorMessageProperties errorMessageProperties,
                           ErrorInfoMessageProperties errorInfoMessageProperties) {

        errorPropertiesMap = new EnumMap<>(ErrorCode.class);

        errorPropertiesMap.put(ErrorCode.INVALID_ITEM,
                new ErrorCodeProperties(Group.CONFIGURATION_ERROR,
                        Type.CART_VALIDATION_ERROR,
                        errorMessageProperties.getValidation().getItemMismatch(),
                        errorInfoMessageProperties.getValidation().getItemMismatch(),
                        HttpStatus.BAD_REQUEST));

        errorPropertiesMap.put(ErrorCode.INVALID_ITEM_TYPE,
                new ErrorCodeProperties(Group.CONFIGURATION_ERROR,
                        Type.CART_VALIDATION_ERROR,
                        errorMessageProperties.getValidation().getItemTypeMismatch(),
                        errorInfoMessageProperties.getValidation().getItemTypeMismatch(),
                        HttpStatus.BAD_REQUEST));

        errorPropertiesMap.put(ErrorCode.INVALID_ITEM_ITEM_TYPE_MISMATCH,
                new ErrorCodeProperties(Group.CONFIGURATION_ERROR,
                        Type.CART_VALIDATION_ERROR,
                        errorMessageProperties.getDataConnection().getItemAndItemTypeMismatch(),
                        errorInfoMessageProperties.getDataConnection().getItemAndItemTypeMismatch(),
                        HttpStatus.BAD_REQUEST));
    }

    public enum ErrorCode {
        INVALID_ITEM,
        INVALID_ITEM_TYPE,
        INVALID_ITEM_ITEM_TYPE_MISMATCH
    }

    public enum Group {
        CONFIGURATION_ERROR
    }

    public enum Type {
        CART_VALIDATION_ERROR
    }

    public void throwSPEException(ErrorProperties.ErrorCode errorCode, List<String> errorInfo) {
        ErrorCodeProperties errorCodeProperties = errorPropertiesMap.get(errorCode);
        throw new SPEException(errorCodeProperties.getGroup(),
                            errorCodeProperties.getType(),
                            errorCodeProperties.getMessage(),
                            CollectionUtils.isEmpty(errorInfo)? errorCodeProperties.getInfoMessage(): String.format(errorCodeProperties.getInfoMessage(), errorInfo),
                            errorCodeProperties.getHttpStatus());
    }

}

if(!orderServiceUtil.allowedItems.contains(item)) {
    errorProperties.throwSPEException(ErrorProperties.ErrorCode.INVALID_ITEM, List.of(item));
}

--------------------------------------------------------------------------------------------------------


Rate-limiter
------------------

resilience4j:
  ratelimiter:
      instances:
        getHeroDetails_RL:
          limitForPeriod: 2
          limitRefreshPeriod: 1s # 2RPS
          timeoutDuration: 10s     #time to acquire permission from RateLimiter before erroring out.

@SneakyThrows
//@Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 3))
@CircuitBreaker(name = "getHeroDetails_CB", fallbackMethod = "getDummyMethod")
@RateLimiter(name = "getHeroDetails_RL")
public HeroDetailsResponse getHeroDetailsASync(HeroDetailsRequest heroDetailsRequest) {
    HeroDetailsResponse heroDetailsResponse = new HeroDetailsResponse();
    List<Hero> heroList = new ArrayList<>();
    List<CompletableFuture<Hero>> cfs = heroDetailsRequest.getHeroNames().stream().map(this::getHeroDetails).toList();
    //join all the CFs
    CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0])).join();
    //get the results from each of the CF
    for(CompletableFuture<Hero> completableFuture : cfs){
        if(completableFuture.isDone()){
            heroList.add(completableFuture.get());
        }
    }
    heroDetailsResponse.setHeroList(heroList);
    return heroDetailsResponse;
}

//429 Too Many Requests response
//Throttling allows to prioritize certain requests or users, ensuring a smoother experience for critical operations. 
   Rate limiting enforces uniform limits across all requests

--------------------------------------------------------------------------------------------------------

Latency in one service should not migrate to the whole system - check max concurrent calls
----------------------------------------------------------------------------------------------

Bulkhead pattern
---------------

resilience4j:
 bulkhead:
   instances:
     getHeroDetails_BH:
       maxConcurrentCalls: 1

@SneakyThrows
//@Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 3))
@CircuitBreaker(name = "getHeroDetails_CB", fallbackMethod = "getDummyMethod")
@RateLimiter(name = "getHeroDetails_RL")
@Bulkhead(name = "getHeroDetails_BH", fallbackMethod = "getDummyMethod")
public HeroDetailsResponse getHeroDetailsASync(HeroDetailsRequest heroDetailsRequest) {
    HeroDetailsResponse heroDetailsResponse = new HeroDetailsResponse();
    List<Hero> heroList = new ArrayList<>();
    List<CompletableFuture<Hero>> cfs = heroDetailsRequest.getHeroNames().stream().map(this::getHeroDetails).toList();
    //join all the CFs
    CompletableFuture.allOf(cfs.toArray(new CompletableFuture[0])).join();
    //get the results from each of the CF
    for(CompletableFuture<Hero> completableFuture : cfs){
        if(completableFuture.isDone()){
            heroList.add(completableFuture.get());
        }
    }
    heroDetailsResponse.setHeroList(heroList);
    return heroDetailsResponse;
}

--------------------------------------------------------------------------------------------------------

Class Data Sharing (CDS)
==============================
Reduce startup time and memory consumption

1.Stores snapshot of the application classes in a archived file
2.Startup, JVM can refer this archive and get the class file, improving the class-loading time

spring.context.exit-on-refresh=true

-XX:ArchiveClassesAtExit=app-cds.jsa
# On the JVM you plan to deploy to:
java -Xshare:on -XX:SharedArchiveFile=app-cds.jsa -jar myapp.jar

GraalVM native image 
========================
Spring Ahead-of-Time Processor compiles the Java code into a standalone executable,  eliminating the need for a JVM at runtime.
<plugin>
 <groupId>org.graalvm.buildtools</groupId>
 <artifactId>native-maven-plugin</artifactId>
</plugin>

mvn -Pnative spring-boot:build-image    ---> Docker image

----------------------------------------------------------------------------------------------------------------------

Spring Observability
===============================================================================
Observability is the ability to measure the internal state of a system only by checking its outputs (logs, traces, metrics)
define our own metrics using Micrometer
gather them using Prometheus
display them on a Grafana dashboard


		    (exposes Metrics)    (collects + makes + ships Metrics)   (scrape Metrics)         (query Prometheus)
SpringBoot ------> Actuator  ---->   Micrometer   --------------->     Prometheus     ------>    Grafana
									  (Monitoring tool)         (Observability backend)

                                 (Prometheus to scrape Micrometer logs and Micrometer metrics at a configured interval from and endpoint and display them in a Grafana dashboard)


<!-- Web -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<!-- Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<!-- Micrometer-core -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-core</artifactId>
    <scope>runtime</scope>
</dependency>
<!-- Micrometer-prometheus -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
    <scope>runtime</scope>
</dependency>
<!-- AOP, for custom timer -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>

Actuator
===========================
Exposes metrics by exposing management endpoints - CPU usage, memory usage, request rate, error rate

<!-- Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

http://localhost:9100/actuator
//health and info are auto-enabled

/health
/info
/metrics
/sessions

/env
/loggers
/httptrace

/startup
/shutdown

management:
  endpoints:
    web:
      exposure:
        include: health, prometheus, metrics, info
  endpoint:
    health:
      show-details: always
    metrics:
      enabled: true
    prometheus:
      enabled: true // Exposes metrics in a format that can be scraped by a Prometheus server.
    info:
      java:
        enabled: true
      env:
        enabled: true
  tracing:
      sampling:
        probability: 1.0


Micrometer (replaces Spring Cloud Sleuth)
========================================================
collects metrics + own metrics + exports Metrics 
configures Spring Boot applications to expose metrics in a format that Prometheus can scrape and store.

Micrometer metrics::
-----------------------
Timer                                 measuring short-duration latencies, and the frequency of such events.
Counter				                  count
Gauge	                              current value
DistributionSummary	                  total amount of all recorded events
Micrometer Observation API            lightweight library for application metrics

//Counter metric
Counter counter = Counter.builder("getMoviesOfDirector")
                        .description("a number of requests to /getMoviesOfDirector endpoint")
                        .register(meterRegistry);
counter.increment();


Prometheus
=====================================
Monitoring tool
Prometheus needs an endpoint(metrics_path) to scrape Micrometer logs and Micrometer metrics at a configured interval and display them in a Grafana dashboard

prometheus.yml
------------------
scrape_configs:
  - job_name: 'SpringBootREST3'
    metrics_path: '/actuator/prometheus'
    scrape_interval: 5s
    static_configs:
      - targets: ['host.docker.internal:9100']
        labels:
          application: 'SpringBootREST3'

Hit http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray a few times

Check in Prometheus ::
            http://localhost:9100/actuator/prometheus

            # TYPE getMoviesOfDirector_total counter
            getMoviesOfDirector_total 7.0

General check in Prometheus UI:
    http://localhost:9090/ -> prometheus_http_requests_total

How does Prometheus that is running on Docker connect to SpringBoot app that is running on localhost?
---------------------------------------------------------------------------------------------------------------
- targets: ['host.docker.internal:9050']
  host.docker.internal is a host-gateway which is a daemon process routing requests to localhost

Behind the scenes, an observation has been created for the HTTP request, which in turn gets bridged to OpenTelemetry, which reports a new trace to Zipkin.

http://localhost:9090/
- Check Status -> Targets


Grafana
======================
Observability backend
Data Visualization service -  create dashboards to visualize and analyze data

http://localhost:3000/ (admin/Kolkata@123a)

Add your first datasource
Select Prometheus
Connect to Prometheus from Grafana :
    Get Prometheus container id
    Get Prometheus IP :
        docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' cd7c5f0de3ac
    - 172.22.0.2
    Prometheus URL in Grafana :: http://172.22.0.2:9090
    - Save and test
Add new Dashboard
    Datasource - Prometheus-1
    prometheus_http_requests_total

datasources.yml
----------------------
apiVersion: 1
datasources:
  - name: Prometheus
    type: prometheus
    access: proxy
    url: http://prometheus:9090
    isDefault: true

docker-compose-yml
--------------------------
version: '3.7'

services:
  prometheus:
    image: prom/prometheus:v2.44.0
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus.yml

  grafana:
    image: grafana/grafana:9.5.2
    container_name: grafana
    ports:
      - "3000:3000"
    restart: unless-stopped
    volumes:
      - ./datasources.yml:/etc/datasources.yml
    depends_on:
      - prometheus


Running all on Docker
-------------------------
Start the application
Start Docker Desktop (starts the Docker daemon)
Update docker-compose.yml with PR-GR
Run docker-compose.yml in Git bash :: cd  D:/workspace2/SpringBootREST3/src/main/resources
                                      docker-compose up --build
Open Gitbash another window::
            docker images //prometheus and grafana images
            docker ps     // All running containers

            docker stop $(docker ps -a -q) //Stop all running containers
            docker rm -f $(docker ps -a -q) //Docker remove all containers
            docker rmi -f $(docker images -q) //Docker remove all images

Hit http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray a few times

Check in Prometheus ::
            http://localhost:9100/actuator/prometheus

            # TYPE getMoviesOfDirector_total counter
            getMoviesOfDirector_total 7.0

Check in Grafana ::
            - see above

----------------------------------------------------------------------------------------------------------------------

Spring OpenTelemetry (replaces OpenTracing)
================================================
Observability framework for application monitoring by collecting Logs, Traces and Metrics 
vendor-agnostic

OTLP
-------
OpenTelemetry Protocol is a telemetry data transfer protocol that we can leverage to export the telemetry data to an observability backend.

        		  (exposes Metrics)  (collects + makes + ships Metrics)  (LTM  :: collection and shipment)
SpringBoot ------> Actuator  ---->   Micrometer    ----------------------->   OTel Collector       ------->           Jaeger (Observability Backend)
                                    (Monitoring tool)               micrometer-tracing-bridge-otel                  opentelemetry-exporter-otlp
pom.xml
-----------
<artifactId>spring-boot-starter-parent</artifactId>
<version>3.2.7</version>

<java.version>21</java.version>
		
<dependencies>
	    <!-- Web -->
	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-starter-web</artifactId>
	</dependency>
	<!-- Actuator -->
	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-starter-actuator</artifactId>
	</dependency>
	<!-- AOP, for custom timer -->
	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-starter-aop</artifactId>
	</dependency>
	<!-- Micrometer-core -->
	<dependency>
	    <groupId>io.micrometer</groupId>
	    <artifactId>micrometer-core</artifactId>
	    <version>1.11.6</version>
	</dependency>
	<!--Micrometer-OpenTelemetry bridge-->
	<dependency>
	    <groupId>io.micrometer</groupId>
	    <artifactId>micrometer-tracing-bridge-otel</artifactId>
	</dependency>
	<!--OpenTelemetry exporter-->
	<dependency>
	    <groupId>io.opentelemetry</groupId>
	    <artifactId>opentelemetry-exporter-otlp</artifactId>
	</dependency>
	<!--Jaeger-->
	<dependency>
	    <groupId>io.opentracing.contrib</groupId>
	    <artifactId>opentracing-spring-jaeger-web-starter</artifactId>
	    <version>3.3.1</version>
	</dependency>
	<!--Jaeger-remote-sampler-->
	<dependency>
	    <groupId>io.opentelemetry</groupId>
	    <artifactId>opentelemetry-sdk-extension-jaeger-remote-sampler</artifactId>
	</dependency>
</dependencies>
<dependencyManagement>
	<dependencies>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-dependencies</artifactId>
			<version>2023.0.0</version>
			<type>pom</type>
			<scope>import</scope>
		</dependency>
	</dependencies>
</dependencyManagement>

otel-config.yml
------------------

receivers:
  otlp:
    protocols:
      grpc:
      http:

processors:
  batch:

exporters:
  logging:
    loglevel: debug
  jaeger:
    endpoint: jaeger-service:14250
    tls:
      insecure: true

service:
  pipelines:
    traces:
      receivers:  [ otlp ]
      processors: [ batch ]
      exporters:  [ logging, jaeger ]

docker-compose.yaml
--------------------------
version: '3.7'

services:
  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686" # the jaeger UI
      - "4318:4318" # the OpenTelemetry collector http
    environment:
      - COLLECTOR_OTLP_ENABLED=true


application.yaml
----------------------------
spring:
  application:
    name: SpringBootREST3
  datasource:
    url: jdbc:postgresql://localhost:5432/springbootdb
    username: postgres
    password: tiger
    driver-class-name: org.postgresql.Driver
    hikari:
      connection-timeout: 5000
      maximum-pool-size: 5
  jpa:
    show-sql: true
    properties:
      hibernate:
        format-sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
  main:
    allow-bean-definition-overriding: true


logging:
  level:
    org:
      springframework:
        security: DEBUG
  pattern:
    level: '%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]'

server:
  port: 9100

management:
  endpoints:
    web:
      exposure:
        include: ["health","prometheus","metrics","info"]
  endpoint:
    health:
      show-details: always
    metrics:
      enabled: true
    prometheus:
      enabled: true
  info:
    java:
      enabled: true
    env:
      enabled: true
  tracing:
    sampling:
      probability: 1.0
  otlp:
    tracing:
      endpoint: http://localhost:4318/v1/traces

application:
  spring:
    endpoints:
      exclude: /v3/rest/hello, /v3/rest/helloPost, /v3/rest/home, /actuator/**, /v3/rest/getMoviesOfDirector/**, /v3/rest/getMoviesByDirectorAndGenre/**


opentracing:
  jaeger:
    enabled: true

Jaeger
--------------------------

@Configuration
@ConditionalOnProperty(value = "opentracing.jaeger.enabled", havingValue = "true")
public class JaegerConfig {

    @Bean
    public JaegerTracer jaegerTracer() {
        return new io.jaegertracing.Configuration("SpringBootREST3")
                .withSampler(new io.jaegertracing.Configuration.SamplerConfiguration().withType(ConstSampler.TYPE).withParam(1))
                .withReporter(new io.jaegertracing.Configuration.ReporterConfiguration().withLogSpans(true))
                .getTracer();
    }



}

@RestController
@RequestMapping("/v3/rest")
public class NavController {

    @Autowired
    private HomeService homeService;

    @Autowired
    private MovieService movieService;

    @Autowired
    private MeterRegistry meterRegistry;

    @Autowired
    private JaegerTracer jaegerTracer;

    Logger log = LoggerFactory.getLogger(NavController.class);

    // http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray
    @GetMapping(value = "/getMoviesOfDirector/{director}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<List<Movie>> getMoviesOfDirector(
            @PathVariable("director") String director) {
        Span span = jaegerTracer.buildSpan("getMoviesOfDirector").start();
        log.info("Inside getMoviesOfDirector controller... ");

        //Counter metric
        Counter counter = Counter.builder("getMoviesOfDirector")
                                .description("a number of requests to /getMoviesOfDirector endpoint")
                                .register(meterRegistry);
        counter.increment();

        //Timer metric
        Timer.Sample timer = Timer.start(meterRegistry);
        Span getHeroDetailsSpan = jaegerTracer.buildSpan("getMoviesOfDirector-Service").asChildOf(span).start();
        List<Movie> movies = movieService.getMoviesOfDirector(director);
        getHeroDetailsSpan.finish();
        span.finish();
        timer.stop(Timer.builder("getMoviesOfDirector_Timer").register(meterRegistry));

        //Observation API
        Observation.createNotStarted("getMoviesOfDirector_Count", observationRegistry)
                .lowCardinalityKeyValue("request-uid", String.valueOf(new Random().nextInt(100)))
                .observe(() -> {
                    List<Movie> movies2 = movieService.getMoviesOfDirector(director);
                    log.debug("Counting getMoviesOfDirector");
                });
        return ResponseEntity.ok(movies);
    }

}

logback.xml
---------------------
<?xml version="1.0" encoding="UTF-8"?>
<configuration>

    <property name="APP_LOG" value="logs/app.log"/>
    <property name="logging.file.name" value="info-log" />
    <property name="logging.file.path" value="./"/>
    <property name="logging.error.file.name" value="error-log" />
    <property name="logging.error.file.path" value="./"/>

    <!-- console log appender -->
    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="INFO">
        <appender-ref ref="console"/>
    </root>

</configuration>


Running all on Docker
-------------------------
Start the application
Start Docker Desktop
Update docker-compose.yml with OT-JG
Run docker-compose.yml in Git bash :: cd  D:/workspace2/SpringBootREST3/src/main/resources
                                      docker-compose up --build
Open Gitbash another window::
            docker images //otel and jaeger images
            docker ps     // All running containers

            docker stop $(docker ps -a -q) //Stop all running containers
            docker rm -f $(docker ps -a -q) //Docker remove all containers
            docker rmi -f $(docker images -q) //Docker remove all images

Hit http://localhost:9100/v3/rest/getMoviesOfDirector/Satyajit Ray a few times

Check in Jaeger ::
           http://localhost:16686/search


-------------------------------------------------------------------------------------------------

OpenTelemetry                            vs                                     Prometheus
===================================================================================================
Logs, Traces and Metrics                                                        Metrics
More scalable
calculates delta                                                               calculates cumulative measurements as a total
Observation API for LTM and transform them into a single language

-------------------------------------------------------------------------------------------------

Jaeger
========================================
Observability backend
Components:
            Collector—collects trace data, validates and passes to storage service  (port :16686)
            Storage —Cassandra, ElasticSearch
            Web UI— view the trace data
            Search — on trace data

           [TraceId:SpanId:ParentSpanId:Flags]

Span reported: 4c5f29d379ea625e:3d177b55c210dffb:4c5f29d379ea625e:1 - PARENT

Span reported: 4c5f29d379ea625e:c1b1e7351ce66ca9:1d134091d2c206e7:1 - getHeroDetails            - CHILD
Span reported: 4c5f29d379ea625e:1d134091d2c206e7:7c1877ceb2c65cfa:1 - getMoviesOfHero
Span reported: 4c5f29d379ea625e:7c1877ceb2c65cfa:3d177b55c210dffb:1 - getMoviesOfHero   (PARENT SPAN ID = SPAN ID OF CALLER SERVICE)


Jaeger              vs                                Grafana                       vs              Zipkin
-------------------------------------------------------------------------------------------------------------------
Performance, Scalability, Reliability
part of the CNCF(Cloud Native Computing Foundation), so deployed in Kubernetes.
can be deployed in parts
Storage - ElasticSearch, Cassandra,Kafka            Local storage

------------------------------------------------------------------------------------------------------------------------------

OpenAPI Specification (OAS) { previously Swagger specification)
===========================================================================
REST API documentation specification for SpringBoot projects

<!--spring-boot-starter-validation -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
<!--Open API -->
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.2.0</version>
</dependency>
(Remove springfox-swagger2 and springfox-swagger-ui dependencies)

@AllArgsConstructor
@Getter
@Setter
@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonIgnoreProperties(ignoreUnknown = true)
public class Person {

    @JsonProperty
    @NotBlank
    @Size(min = 5, message = "First name must have at-least 5 chars")
    @Schema(description = "First name", example = "John")
    private String firstName;

    @JsonProperty
    @Schema(description = "Last name", example = "Doe")
    private String lastName;
}

@PostMapping(value = "/helloPost", produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE)
@ApiResponses({
        @ApiResponse(responseCode = "200", description = "Ok", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Person.class))),
        @ApiResponse(responseCode = "400", description = "Bad Request", content = @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class)))
})
public ResponseEntity<String> helloPost(@Valid @RequestBody Person person) {
    return ResponseEntity.status(HttpStatus.OK)
            .body(person.getFirstName().concat("----").concat(person.getLastName()));
}

http://localhost:9100/v3/api-docs (JSON)
http://localhost:9100/v3/api-docs.yaml (YAML)
Paste the yaml in Swagger Editor

@RestControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    @ExceptionHandler(OrderException.class)
    public ResponseEntity<ErrorResponse> handleOrderException(OrderException oe){
        ErrorResponse errorResponse = new ErrorResponse(oe.getErrorCode(), oe.getErrorMessage(), oe.getHttpStatus());
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(errorResponse);
    }

    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException exception, HttpHeaders headers, HttpStatusCode status, WebRequest request) {

        String errorMessage = "Error in object '%s', error in field '%s', error is '%s'";
        FieldError fieldError = exception.getBindingResult().getFieldError();
        errorMessage = String.format(errorMessage, fieldError.getObjectName(), fieldError.getField(), fieldError.getDefaultMessage());
        ErrorResponse errorResponse = new ErrorResponse("101", errorMessage, HttpStatus.BAD_REQUEST);
        return ResponseEntity
                .badRequest()
                .body(errorResponse);
    }
}

@Getter
@Setter
@AllArgsConstructor
public class ErrorResponse {

	@Schema(example = "101")
	private String errorCode;
	@Schema(example = "Error in object 'person', error in field 'firstName', error is 'First name must have at-least 5 chars'")
	private String errorMessage;
	@Schema(example = "BAD_REQUEST")
	private HttpStatus httpStatus;

}

------------------------------------------------------------------------------------------------------------------------------

Inserting data with ModelMapper
--------------------------------

<dependency>
    <groupId>org.modelmapper.extensions</groupId>
    <artifactId>modelmapper-spring</artifactId>
    <version>3.0.0</version>
</dependency>

CREATE TABLE MOVIE_NEW (
    movie_id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    movie_name VARCHAR(250) NOT NULL unique,
    director VARCHAR(250) NOT NULL,
    genre VARCHAR(250) NOT NULL,
	hero VARCHAR(250) NOT NULL,
	year VARCHAR(250) NOT NULL,
	national_award boolean NOT NULL
);


@Entity
@Table(name = "MOVIE_NEW")
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class MovieNew {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "movie_Id")
    private Integer movieId;

    @Column(name = "movie_Name")
    private String movieName;

}

@Repository
public interface MovieNewRepository extends JpaRepository<MovieNew, Integer> {
}

// http://localhost:9100/v3/rest/addMovie
@PostMapping(value = "/addMovie", produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE)
public MovieNew addMovie(@RequestBody MovieModel movieModel){
    ModelMapper modelMapper = new ModelMapper();
    modelMapper.getConfiguration().setDeepCopyEnabled(Boolean.TRUE);
    modelMapper.getConfiguration().setAmbiguityIgnored(Boolean.TRUE);
    modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT);

    MovieNew movieNew = modelMapper.map(movieModel, MovieNew.class);
    return movieService.addMovie(movieNew);

}


@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(OrderException.class)
    public ResponseEntity<ErrorResponse> handleOrderException(OrderException oe) {
        ErrorResponse errorResponse = new ErrorResponse(oe.getErrorCode(), oe.getErrorMessage(), oe.getHttpStatus());
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(errorResponse);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleMethodArgumentNotValidException(MethodArgumentNotValidException me) {
        String errorMessage = "Error in object '%s', error in field '%s', error is '%s'";
        FieldError fieldError = me.getBindingResult().getFieldError();
        errorMessage = String.format(errorMessage, fieldError.getObjectName(), fieldError.getField(), fieldError.getDefaultMessage());
        ErrorResponse errorResponse = new ErrorResponse("101", errorMessage, HttpStatus.BAD_REQUEST);
        return ResponseEntity
                .badRequest()
                .body(errorResponse);
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorResponse> handleDataIntegrityViolationException(DataIntegrityViolationException de){
        String errorMessage  = de.getMostSpecificCause().getMessage();
        ErrorResponse errorResponse = new ErrorResponse("401", errorMessage, HttpStatus.BAD_REQUEST);
        return ResponseEntity
                .badRequest()
                .body(errorResponse);
    }

}

//http://localhost:9100/v3/rest/addMovie
{
    "movieName": "Choto Boro boro 2",
    "director": "HAtim Tai",
    "genre": "HeheHaha",
    "hero": "Faltu",
    "year": "1999",
    "nationalAward": false
}

------------------------------------------------------------------------------------------------------------------------------

HTTP Headers
===============

Headers in HTTP Requests
------------------------------
Host : Server host and port to which the request is sent (80-http, 443-https)
User-Agent :  string that lets servers identify the application, operating system, vendor, and/or version of the requesting client
Accept : Client tells server the type of content client expects
Content-type : Client tell Server the request content type
Accept-Language : language settings for a user
Accept-Encoding : encoding algorithm
Cookie :: The main purpose of Session and Cookie is to make up for the stateless nature of HTTP.
          The server can use Session to store some operation records of the client during the same session.
          Session is stored on the server side, and sessionId will be stored in the Cookie of the client.
          How to determine whether it is the same session? Server sends Set-Cookie: JSESSIONID=XXX
                                                           Client further calls the Server with the same Cookie and session-id
          Disadvantage of Session : Server Load balancing will invalidate the session
          Session                                           vs                                  Token
          ------------------------------------------------------------------------------------------------------
          Connected to the machine(browser)                                         Connected to the user
                                                                                    Less space - no need to save session information
                                                                                    3rd party integration to send only Tokens

Referer : referring pages / where resources are kept
Authorization :
    // Bearer
    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

    // Basic
    Authorization: Basic base64(username:password)

    // API Key
    Authorization: ApiKey your-api-key

Headers in HTTP Response
---------------------------
Cache Control : (Cache-Control: max-age=3600, public)
Content-type : Server tell Client the response content type
Content Disposition : attachment , inline / download
Content-Length
Location : redirection
Set-Cookie : cookie gets set in Browser (Set-Cookie: sessionId=38afes7a8)

------------------------------------------------------------------------------------------------------------------------------

Caffeine
=====================
- 1st-level caching / In-memory caching (Data is stored in a single machine)

<!--Caffeine cache-->
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-cache</artifactId>
</dependency>

<dependency>
	<groupId>com.github.ben-manes.caffeine</groupId>
	<artifactId>caffeine</artifactId>
</dependency>

@Configuration
@EnableCaching
public class CaffeineConfig {

    public static final String HELLO_WORLD_CACHE = "helloWorldCache";
     public static final String BU_CACHE = "buCache";

    @Bean(name = "caffeine")
    public @NonNull Caffeine<Object, Object> caffeine(){
        return Caffeine
                .newBuilder()
                .initialCapacity(100)
                .maximumSize(2000)
                .expireAfterWrite(1, TimeUnit.HOURS);
    }

    @Bean
    public CaffeineCacheManager caffeineCacheManager(@Qualifier("caffeine") Caffeine caffeine) {
        CaffeineCacheManager caffeineCacheManager = new CaffeineCacheManager();
        caffeineCacheManager.setCaffeine(caffeine);
        caffeineCacheManager.setAllowNullValues(false);
        caffeineCacheManager.setCacheNames(List.of(HELLO_WORLD_CACHE, BU_CACHE));
        return caffeineCacheManager;
    }

}

Service
------------------
@Cacheable(key = "#buCode.concat('-').concat(#buType).concat('-').concat(#countryCode)", cacheManager = "caffeineCacheManager", cacheNames = CaffeineConfig.BU_CACHE, unless = "#result==null")
public Bucode getBuCode(String buCode, String buType, String countryCode) {
    //This method call will by default try to retrieve from the Caffeine cache based on the key, if not found will go into the method and will set by default
    System.out.println("Checking in Redis...");
    String key = buCode.concat("-").concat(buType).concat("-").concat(countryCode);
    Bucode bucode = (Bucode) buCodeRedisTemplate.opsForValue().get(key);
    System.out.println("Value in Redis :: " + bucode);
    if (Objects.isNull(bucode)) {
        System.out.println("Going to DB...");
        bucode = buRepository.findByBuCodeAndBuTypeAndCountryCode(buCode, buType, countryCode);

        //set in Redis
        buCodeRedisTemplate.opsForValue().set(key, bucode);
    }
    return bucode;
}

Service (Option 2)
---------------------

@Autowired
private CaffeineCacheManager caffeineCacheManager;

Cache.ValueWrapper valueWrapper = caffeineCacheManager.getCache(CaffeineConfig.HELLO_WORLD_CACHE).get(redisKey);
List<Movie> movies = (List<Movie>) Optional.ofNullable(valueWrapper).map(Cache.ValueWrapper::get).orElse(null);

---------------------------------------------------------------------------------------------

Redis
===============

- Distributed caching (Data is stored across multiple servers - for faster access and more data)
- High Availability
- Scalability: Redis can handle millions of concurrent connections, making it ideal for distributed systems

<!--Redis-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

<!--Apache commons, for Redis -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>

Run Redis
================
Run RedisServer.bat -> start "" E:\Softwares\Redis-x64-3.2.100\redis-server.exe
RedisInsight

monitor Cache Metrics
=============================
/actuator/metrics/cache.gets
/actuator/metrics/cache.puts
/actuator/metrics/cache.evictions
/actuator/metrics/cache.removals

spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=
spring.redis.timeout=60000
spring.redis.lettuce.pool.max-active=8
spring.redis.lettuce.pool.max-idle=8
spring.redis.lettuce.pool.max-wait=-1
spring.redis.lettuce.pool.min-idle=0

@Configuration
@EnableCaching
@EnableConfigurationProperties(RedisProperties.class)
public class RedisConfig {

    @Bean(name = "moviesCachedRedisTemplate")
    public RedisTemplate moviesCachedRedisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<String, Object>();
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }

}


Service
----------

@Autowired
@Qualifier("moviesCachedRedisTemplate")
private RedisTemplate redisTemplate;


// check in 1st Level cache (Caffeine), else check in 2nd Level cache (Redis)
// if not found hit service and put in cache
Cache.ValueWrapper valueWrapper = caffeineCacheManager.getCache(CaffeineConfig.HELLO_WORLD_CACHE).get(redisKey);
List<Movie> movies = (List<Movie>) Optional.ofNullable(valueWrapper).map(Cache.ValueWrapper::get).orElse(null);

if (CollectionUtils.isEmpty(movies)) {
    movies = (List<Movie>) redisTemplate.opsForValue().get(redisKey);
    log.info("Redis :: {}, transactionId  {} , movies {} ", "getMovieDetails", MDC.get("transactionId"), movies);

    if (CollectionUtils.isEmpty(movies)) {
        movies = restTemplate.exchange(uri, HttpMethod.GET, null, new ParameterizedTypeReference<List<Movie>>() {
        }).getBody();

        log.info("Service :: {}, transactionId  {} , movies {} ", "getMovieDetails", MDC.get("transactionId"), movies);

        //put in Caffeine - 1st level Cache
        caffeineCacheManager.getCache(CaffeineConfig.HELLO_WORLD_CACHE).put(redisKey, movies);

        //put in Redis - 2nd level Cache
        redisTemplate.opsForValue().set(redisKey, movies, Duration.ofMinutes(cacheItemExpireInMinutes));

	    //multiGet
	    //List<String> cacheKeys = getCacheKeys();
        //List<String> responseItems = redisTemplate.multiGet(cacheKeys);


    } else {
        caffeineCacheManager.getCache(CaffeineConfig.HELLO_WORLD_CACHE).put(redisKey, movies);
    }

}

---------------------------------------------------------------------------------------------

Handling Duplicate Requests
------------------------------
Idempotent key in header
Token-Based Request Validation

---------------------------------------------------------------------------------------------

CORS (Cross-Origin Resource Sharing)
========================================
@CrossOrigin
Allows API to share resources with Browser


CSRF (Cross-Site Request Forgery)
===================================================================
If a user is logged into a website (e.g., a banking site), an attacker can create a malicious page
that tricks the user’s browser into sending requests to that site.

CSRF protection - CSRF token to be shared between client and server

httpSecurity
        .csrf().disable() //disable for APIs as it is stateless or JWT authentication

XSS (Cross-Site Scripting)
===============================
Implement malicious code in user's website
When the malicious code is processed, it can fetch any data.
Javascript-based
more dangerous

---------------------------------------------------------------------------------------------------------------------------

mvcMatcher vs antMatcher
================================

mvcMatcher is more secure than an antMatcher. As an example:

.antMatchers(HttpMethod.POST, "/orders/v1/getOrder2").permitAll()
.mvcMatchers(HttpMethod.POST, "/orders/v1/getOrder2/**").permitAll()

Secured Spring Application
===============================

Object :  @Autowired /  @Bean
Variable :  No global variable
Jaxb2Marshaller
DataSource and Hikari
JWT
APIGW

@AllArgsConstructor                                   vs                                  @RequiredArgsConstructor
============================================================================================================================
constructor for all fields                                                               constructor for final fields


Import java class into Spring container
===========================================

public class A {
}

@Import(A.class)
@Configuration
public class TestConfiguration {

}

class {

    @Autowired
    private A a;
}

Encoding vs Encryption
===========================================

Encoding    :: Text + algorithm = Cipher-Text
Encryption  :: Text + key + algorithm = Cipher-Text

Symmetric Encryption                                            vs                                      Asymmetric Encryption
---------------------------------------------------------------------------------------------------------------------------------------
Single key is used for encryption and decryption                                    Two different keys are used — Private Key and Public Key
- AES (Advanced Encryption Standard) , DES (Data Encryption Standard)               -RSA


Pen test
==============
API penetration testing is a security testing method that simulates hacker attacks to evaluate the security of an API
- BurpSuite

GHAS / SonarQube
=====================
Static code analysis tool

Disaster recovery
========================
Terraform - IaaC -> define your infrastructure, so it can be recreated quickly in case of disaster
Auto-Scaling
Failover
Multi-region

        Hot Failover: Backup systems run simultaneously with the primary systems. Failover happens automatically and almost instantaneously.
        Cold Failover: Backup systems remain offline and only come online when a failure occurs. The recovery process takes time as services and systems need to be started manually.
        Warm Failover: Backup systems are running with minimal services enabled, and they are prepared to take over quickly with some manual intervention.

Performance Testing
====================
Gatling / JMeter


A/B Testing
==================
compares 2 versions to check which version is more performant/appeals more

Trivy
======
Image Scanning for vulnerabilities

Blackduck
==========
BlackDuck -> Image Scanning for vulnerabilities + compliance +  code-quality


---------------------------------------------------------------------------------------------------------------------------------------

Gatling
======================

Gatling : Performance test by simulation
Compared to JMeter : Gatling is faster, lightweight, and provides more detailed and colorful reports

simulation service :: E:\Softwares\gatling-charts-highcharts-bundle-3.9.5\user-files\simulations\GatlingSimulations.java

Run gatling :: E:\Softwares\gatling-charts-highcharts-bundle-3.9.5\bin\gatling.bat

Results :: E:\Softwares\gatling-charts-highcharts-bundle-3.9.5\results

<dependency>
    <groupId>io.gatling</groupId>
    <artifactId>gatling-core</artifactId>
    <version>3.9.3</version>
</dependency>
<!-- https://mvnrepository.com/artifact/io.gatling.highcharts/gatling-charts-highcharts -->
<dependency>
    <groupId>io.gatling.highcharts</groupId>
    <artifactId>gatling-charts-highcharts</artifactId>
    <version>3.9.3</version>
</dependency>
<!-- https://mvnrepository.com/artifact/io.gatling/gatling-maven-plugin -->
<dependency>
    <groupId>io.gatling</groupId>
    <artifactId>gatling-maven-plugin</artifactId>
    <version>4.3.1</version>
</dependency>

Gatling Simulation
------------------------------

package com.example.SpringBootREST2.service;

import static io.gatling.javaapi.core.CoreDsl.*;
import static io.gatling.javaapi.http.HttpDsl.*;

import io.gatling.javaapi.core.*;
import io.gatling.javaapi.http.*;

public class GatlingSimulation extends Simulation {

    HttpProtocolBuilder httpProtocol =
        http.baseUrl("http://localhost:9050")
            .acceptHeader("text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
            .acceptLanguageHeader("en-US,en;q=0.5")
            .acceptEncodingHeader("gzip, deflate")
            .userAgentHeader(
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:16.0) Gecko/20100101 Firefox/16.0"
            );

    ChainBuilder read = exec(http("Read Spring Rest Controller").get("/orders/v1/getMoviesOfDirector/Satyajit Ray"));
    ScenarioBuilder users = scenario("Users Read").exec(read);

    {
        setUp(
            users.injectOpen(
                atOnceUsers(1),
                nothingFor(2),
                atOnceUsers(4),
                rampUsers(50).during(10),
                constantUsersPerSec(20.0).during(20),
                constantUsersPerSec(30.0).during(30)
            )
        ).protocols(httpProtocol);
    }
}

----------------------------------------------------------------------------------------------------------------------

SonarQube
==============

Static code analysis tool
 - Code quality
 - Code complexity
 - Code duplications
 - Code coverage
 - Code smells
 - Detects bugs and vulnerabilities

 - Project status - passed / failed
 Can integrate with build tools like Maven, Gradle and with CI Tools like Jenkins, Github Actions

<!-- JaCoCo -->
<dependency>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.8</version>
</dependency>

 JaCoCo allows you to configure rules that can be verified during the build process, stopping it if these rules are not met.
 JaCoCo will give the unit test coverage

Run Sonar
------------------
E:\Softwares\sonarqube-10.2.1.78527\conf\sonar.properties
        sonar.jdbc.username=postgres
        sonar.jdbc.password=postgres

E:\Softwares\sonarqube-10.2.1.78527\bin\windows-x86-64\StartSonar.bat
http://localhost:9000

D:\workspace2\SpringBootREST2 >
mvn clean verify sonar:sonar -Dsonar.projectKey=SpringBootREST2 -Dsonar.projectName='SpringBootREST2' -Dsonar.host.url=http://localhost:9000 -Dsonar.token=sqp_5b83985ddb470a1350f16fc2363daefbde691605

----------------------------------------------------------------------------------------------------------------------

GitHub Advanced Security
============================

Code scanning
Secret scanning
Dependency review


----------------------------------------------------------------------------------------------------------------------

@Conditional
--------------------------
1.@ConditionalOnProperty

@Configuration
@ConditionalOnProperty(value = "opentracing.jaeger.enabled", havingValue = "true", matchIfMissing = true)
public class JaegerConfig {
}
//matchIfMissing = true : assume condition is true when property is absent

2.@ConditionalOnBean

@Bean
@ConditionalOnBean(DataSource.class)
public ExampleService exampleService(DataSource dataSource) {
    return new ExampleService(dataSource);
}

3.@ConditionalOnMissingBean

@Bean
@ConditionalOnMissingBean(ExampleService.class)
public ExampleService defaultExampleService() {
    return new DefaultExampleService();
}

4.@Conditional

@Component
@Conditional(SomeCondition.class)
public class MyComponent {
  // ... your component code here
}

public class SomeCondition implements Condition {

  @Override
  public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    //return true/false
  }
}

----------------------------------------------------------------------------------------------------------------------

RestTemplate                            vs                      WebClient                           vs                          RestClient              vs                   FeignClient
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Synchronous HTTP call (Spring Web)                           ASynchronous HTTP call  (Spring WebFlux)                        Synchronous HTTP call                         Synchronous HTTP call
                                                             Fluid API                                                        Fluid API                                     Interface with @FeignClient
Servlet Stack                                                Reactive Stack                                                   Reactive Stack
Synchronous, Blocking I/O                                    Event-driven, non-blocking programming which communicates over asynchronous data streams
                                                             High-concurrency scenarios
Servlet -> Thread model                                      Servlet->Thread Pool model
 - Finite number of Servlet-threads                             - Every request comes with a Handler function and call-back function
 - Each Servlet-thread creates a Worker-thread                  - Servlet-thread delegates the request to a thread-pool
    for DB/IO/MQ and waits for the Worker-thread to complete    - 1 thread from Thread pool delegates the request to its Handler function
                                                                - When the Handler function is complete, 1 thread from Thread-pool takes the response and passes it to the call-back function
                                                             Backpressure to stabilise the flow of asynchronous data streams



Client-side Load Balancing                  vs                                         Server-side Load-balancing
----------------------------------------------------------------------------------------------------------------------
Spring Cloud Load Balancer	                                                             Single point of failure
EurekaServer                                                                             INGRESS


Object-Oriented Programming             vs              Functional Programming             vs              Reactive Programming
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Objects and Classes - which mimic real world entities and their behavior.
Encapsulation, Inheritance, Polymorphism, and Abstraction (EIPA)
Encapsulation :: Data and data accessors are in a single class so hiding the internal state of the object from outside
Code perspective : State-change and verbose

                                                       Data transformation
                                                       Immutability, Transparency, Higher-order functions, Recursion (ITHR)
                                                       FP uses Immutability to ensure that data cannot be modified after it is created,
                                                             Transparency to ensure that a function will always produce the same outputs given the same inputs
                                                             Higher-order functions to accept 1/more functions as input and/or return a function as output
                                                             Recursion for iteration
                                                       Code perspective : No state-change and compact


                                                                                                Event-driven, non-blocking programming which communicates over asynchronous data streams
                                                                                                pub-sub mode
                                                                                                High-concurrency scenarios


Proxy                                      vs                               Reverse Proxy
-------------------------------------------------------------------------------------------------------------

Client -> Proxy -> Internet -> Server
        - IP masking (Client anonimity)
        - Logging
        - Caching
        - Encryption
        - Load Balancing

                                                                        Client -> Internet  -> Reverse Proxy -> Server
										- Logging
										- Caching
										- Routing
										- Load Balancing
										- Rate-limiting (DDoS Protection) (Distributed Denial-of-Service)

									API Gws are reverse proxy


 Request timeout            vs          Read timeout            vs              Connection timeout
 -----------------------------------------------------------------------------------------------------------
 time for the request to come back with a response (time to resolve the hostname + open the TCP connection + perform the TLS handshake etc)
                                        time to read data                   time to open the TCP connection


---------------------------------------------------------------------------------------------------------------------------

DDos (Distributed Denial of Service) attack
------------------------------------------------------

A distributed denial-of-service (DDoS) attack is a malicious attempt to disrupt the normal traffic of a targeted server, service or network
by overwhelming the target or its surrounding infrastructure with a flood of Internet traffic.

Spring Bean scopes
--------------------------
1. singleton ::    1 instance in SpringApplicationContext
2. prototype ::    1 instance in every call
3. request ::      1 instance in request
4. session ::      1 instance in session
5. application ::  1 instance in appliocation(ServletContext)
6. websocket ::    1 instance in WebSocket

---------------------------------------------------------------------------------------------------------------------------

Logging
==================
SLF4J (Simple Logging Facade for Java) logging abstraction + Logback (implementation)

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-logging</artifactId>
</dependency>

logging:
  level:
    root: INFO
    com.example.yourpackage: DEBUG
    org.springframework.web: ERROR
    org.hibernate.type.descriptor.sql: TRACE
  file:
    path:

logback-spring.xml
------------------
<?xml version="1.0" encoding="UTF-8"?>
<configuration>

    <property name="APP_LOG" value="logs/app.log"/>
    <property name="logging.file.name" value="info-log" />
    <property name="logging.file.path" value="./"/>
    <property name="logging.error.file.name" value="error-log" />
    <property name="logging.error.file.path" value="./"/>

    <!-- console log appender -->
    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%-5p [%d{ISO8601}] [%t] %F:%L - %msg%n</pattern>
            <!--  <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern> -->
        </encoder>
    </appender>

    <!-- Normal log appender -->
    <appender name="NORMAL_FILE" class="ch.qos.logback.core.FileAppender">
        <file>${logging.file.path}/${logging.file.name}</file>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- rolling log appender -->
    <appender name="FILE-ROLLING" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${APP_LOG}</file>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>logs/archived/app.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <!-- each archived file, size max 10MB -->
            <maxFileSize>10MB</maxFileSize>
            <!-- total size of all archive files, if total size > 20GB,
				it will delete old archived file -->
            <totalSizeCap>20GB</totalSizeCap>
            <!-- 60 days to keep -->
            <maxHistory>60</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d %p %c{1.} [%t] %m%n</pattern>
        </encoder>
    </appender>

    <!-- Error log appender -->
    <appender name="ERROR_FILE" class="ch.qos.logback.core.FileAppender">
        <file>${logging.error.file.path}/${logging.error.file.name}</file>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="INFO">
        <appender-ref ref="FILE-ROLLING"/>
        <appender-ref ref="console"/>
        <appender-ref ref="NORMAL_FILE"/>
        <appender-ref ref="ERROR_FILE"/>
    </root>

</configuration>

Logger
-----------
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

private final Logger logger = LoggerFactory.getLogger(NavigationController.class);

logger.info("In getMoviesByDirectorAndGenreAndNationalAward :: {}, {}, {}", director, genre, nationalAward);
2024-04-05 20:10:46,906 INFO com.example.SpringBootREST2.controller.NavigationController [http-nio-9050-exec-2] In getMoviesByDirectorAndGenreAndNationalAward :: Satyajit Ray, Family, true

loggedIn:
  user: Logged-in user is %s
System.out.println("property2 : " + String.format(environment.getProperty("loggedIn.user"), "user1"));

Logging levels
-----------------------
TRACE > DEBUG > INFO > WARN > ERROR > FATAL

Logging patterns
-----------------------
1. Simple logging - date, log-level,message
   logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%p] %m%n
   2025-01-23 10:20:00 [INFO] Application started

2. JSON logging

<!-- JSON Logging -->
<dependency>
    <groupId>net.logstash.logback</groupId>
    <artifactId>logstash-logback-encoder</artifactId>
    <version>5.2</version>
</dependency>

<!-- console log appender -->
       <appender name="jsonConsole" class="ch.qos.logback.core.ConsoleAppender">
           <encoder class ="net.logstash.logback.encoder.LogstashEncoder">
               <!-- append fields into logstash log by MDC-->
               <includeMdcKeyName>x-flow-id</includeMdcKeyName>
               <includeMdcKeyName>month</includeMdcKeyName>
               <includeMdcKeyName>parmRequestSource</includeMdcKeyName>
	       <pattern>
			logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%X{userId}] %-5level %logger{36} - %msg%n
		</pattern>
           </encoder>
       </appender>

    <root level="INFO">
        <appender-ref ref="jsonConsole"/>
    </root>

private final Logger logger = LoggerFactory.getLogger(NavigationController.class);

String requestJSON = objectMapper.writeValueAsString(orderRequestForm);
MDC.put("month", month);
MDC.put("parmRequestSource", parmRequestSource);
MDC.put("x-flow-id", UUID.randomUUID().toString());
logger.info(requestJSON);

{
	"@timestamp": "2024-09-21T11:49:09.875+05:30",
	"@version": "1",
	"message": "{\r\n  \"orderId\" : 100,\r\n  \"location\" : \"Kolkata\",\r\n  \"invoiceType\" : 2,\r\n  \"orderItems\" : [ {\r\n    \"itemId\" : 1001,\r\n    \"itemName\" : \"iPhoneX\",\r\n    \"quantity\" : 2\r\n  }, {\r\n    \"itemId\" : 1002,\r\n    \"itemName\" : \"iPad\",\r\n    \"quantity\" : 2\r\n  }, {\r\n    \"itemId\" : 1003,\r\n    \"itemName\" : \"LED TV\",\r\n    \"quantity\" : 2\r\n  } ]\r\n}",
	"logger_name": "com.example.SpringBootREST2.controller.NavigationController",
	"thread_name": "http-nio-9050-exec-3",
	"level": "INFO",
	"level_value": 20000,
	"month": "Feb",
	"parmRequestSource": "web",
	"x-flow-id": "8f73e973-c37a-4236-855d-ad25dcb5c1a1"
}

3. Rolling File logging

<configuration>
    <appender name="ROLLING" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>7</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

<root level="info">
        <appender-ref ref="ROLLING"/>
    </root>
</configuration>

MDC (Mapped Diagnostic Context)
====================================
- To transfer value within service

JSON Masking
============================
File fileUnmasked = new File("src/main/resources/Input.json");
JsonNode jsonNode = objectMapper.readTree(fileUnmasked);

String fieldsToMask = "subOrgTxt,personId";
String[] listFieldsToMask = fieldsToMask.split(",");

for (String fieldToMask : listFieldsToMask) {
    if (Objects.nonNull(jsonNode.findValue(fieldToMask))) {
	for (JsonNode parent : jsonNode.findParents(fieldToMask)) {
	    Optional.ofNullable(parent).ifPresent(parentNode -> ((ObjectNode) parentNode).put(fieldToMask, "XXXXXX"));
	}
    }
}

Logging best practices
============================
1. Use SLF4J
2. Use logging levels 
   TRACE > DEBUG > INFO > WARN > ERROR > FATAL
3. Log masking
	

------------------------------------------------------------------------------------------------------------

JSON Schema Validation
========================
jakarta.validation(prev: javax.validation)
<dependency>
    <groupId>jakarta.validation</groupId>
    <artifactId>jakarta.validation-api</artifactId>
    <version>3.0.2</version>
</dependency>

Controller :: public ResponseEntity<ServiceForm> serviceForm(@Valid @RequestBody ServiceForm serviceForm){


@Getter
@Setter
@ToString
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonIgnoreProperties(ignoreUnknown = true)
@JsonPropertyOrder({
        "orderId",
        "location",
        "invoiceType",
        "orderItems"
})
public class ServiceForm implements Serializable {

    //@NotNull - Integer
    //@NotBlank - String
    //@NotEmpty - List

    //@Nonnull - preventing null-related issues at the development stage, doesn’t trigger any runtime validation
    @JsonProperty(value = "orderId")
    @Schema(description = "orderID of the request", example = "12") //will be mapped to Swagger doc
    @NotNull(message = "Order Id should not be not null")
    @Digits(integer = 3,fraction = 0,message = "Invalid Order ID") //can be both +ve or -ve
    @Valid
    private Integer orderId;

    @JsonProperty(value = "location")
    @Schema(description = "Location of the request", example = "ANT")
    @NotBlank(message = "Location is required")
    @Size(min = 2, max = 20)
    @Valid
    private String location;

    @JsonProperty(value = "invoiceType")
    @Schema(description = "invoiceType of the request", example = "22")
    @NotNull(message = "Invoice type should not be not null") //for Integer
    @Positive(message = "Invoice type should not be negative")
    @Max(900)
    @Min(2)
    private Integer invoiceType;

    @JsonProperty(value = "orderItems")
    @ArraySchema(schema = @Schema(description = "item nos of the request", implementation = OrderItem.class, example = "[{itemId:1001, itemName:iphoneX, quantity:2}, {itemId:1002, itemName:ipad, quantity:2}]"))
    @NotEmpty(message = "Order Items cannot be empty") //for List
    private List<OrderItem> orderItems = new ArrayList<OrderItem>();

    @JsonProperty(value = "itemNos")
    @ArraySchema(arraySchema = @Schema(description = "item nos of the request", example = "[\"1234567890\",\"99989990\"]"))
    @NotEmpty(message = "Item nos cannot be empty")  //for Set
    private Set<@Pattern(regexp = "^\\d{8,10}$", message = "Invalid item no... valid item nos are between 8 to 10 digits") String> itemNos = new HashSet<>();

    @JsonProperty(value = "customerType")
    @Schema(description = "customerType of the request", example = "Business")
    private CustomerType customerType;

    @JsonProperty(value = "validForDate")
    @Schema(description = "validForDate of the request", example = "2012-03-20T21:22:33Z", pattern = "yyyy-MM-dd'T'HH:mm:ss'Z'")
    @ValidDate
    private String validForDate;

    @JsonProperty(value = "invoiceDate")
    @Schema(description = "invoiceDate of the request", example = "2012-03-20", pattern = "yyyy-MM-dd")
    @Pattern(regexp = "^\\d{4}-\\d{2}-\\d{2}$")
    @NotBlank(message = "Invoice date is required")
    private String invoiceDate;

    @Getter
    @Setter
    @AllArgsConstructor
    @NoArgsConstructor
    public static class OrderItem {
        @JsonProperty(value = "itemId")
        private int itemId;
        @JsonProperty(value = "itemName")
        private String itemName;
        @JsonProperty(value = "quantity")
        private int quantity;
    }

}

public enum CustomerType {

    Private("Private"),
    Business("Business");

    private final String value;
    CustomerType(String value){
        this.value = value;
    }

}

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = DateValidator.class)
public @interface ValidDate {
    String message() default "Invalid validForDate";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}


public class DateValidator implements ConstraintValidator<ValidDate, String> {

    @Override
    public void initialize(ValidDate constraintAnnotation) {
        ConstraintValidator.super.initialize(constraintAnnotation);
    }

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return false;
        } else {

            Pattern pattern = Pattern.compile("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$");
            Matcher matcher = pattern.matcher(value);
            if (matcher.matches()) {
                SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
                simpleDateFormat.setLenient(false);
                try {
                    simpleDateFormat.parse(value);
                    return true;
                } catch (Exception e) {
                    return false;
                }
            } else {
                return false;
            }
        }
    }
}


@RestControllerAdvice
public class OrderExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleMethodArgumentNotValidException(MethodArgumentNotValidException me) {
        String errorMessage = "Error in object '%s', error in field '%s', error is '%s'";
        FieldError fieldError = me.getBindingResult().getFieldError();
        errorMessage = String.format(errorMessage, fieldError.getObjectName(), fieldError.getField(), fieldError.getDefaultMessage());
        ErrorResponse errorResponse = new ErrorResponse("101", errorMessage, HttpStatus.BAD_REQUEST);
        return ResponseEntity
                .badRequest()
                .body(errorResponse);
    }

}
------------------------------------------------------------------------------------------------------------------------

To route all requests through this path :
server.servlet.context-path=/my-project

------------------------------------------------------------------------------------------------------------------------

RestTemplate
======================

<!-- Web  (for RestTemplate)  -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!-- Spring WS-Core  (for WsConfigurationSupport, by @EnableWs)  -->
<dependency>
    <groupId>org.springframework.ws</groupId>
    <artifactId>spring-ws-core</artifactId>
</dependency>

<!-- spring-retry -->
<dependency>
    <groupId>org.springframework.retry</groupId>
    <artifactId>spring-retry</artifactId>
    <version>1.3.2</version>
</dependency>

<!-- HTTPClient (for Retry Template, not used in v2 )-->
<dependency>
    <groupId>org.apache.httpcomponents</groupId>
    <artifactId>httpclient</artifactId>
</dependency>

@Configuration
@EnableWs
public class RestConfig {

	@Value("${rest.timeOut:10000}")
	private long timeOut;

	@Value("${rest.backOffPeriod}")
	private long backOffPeriod;

	@Value("${rest.maxAttempts}")
	private int maxAttempts;

	@Bean
	@Scope(value = "prototype")
	public RestTemplate restTemplate(RestTemplateBuilder restTemplateBuilder){
		return restTemplateBuilder
				.setConnectTimeout(Duration.ofMillis(timeOut))
				.setReadTimeout(Duration.ofMillis(timeOut))
				.build();
	}

	@Bean
    public ObjectMapper objectMapper() {
        return JsonMapper
                .builder()
                .enable(SerializationFeature.INDENT_OUTPUT)
                .enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)
                .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
                .configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false)
                .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
                .configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true)
                .serializationInclusion(JsonInclude.Include.NON_NULL)
                .build();
    }

	@Bean
	public ModelMapper modelMapper(){
		ModelMapper modelMapper = new ModelMapper();
		modelMapper.getConfiguration().setDeepCopyEnabled(Boolean.TRUE);
		modelMapper.getConfiguration().setAmbiguityIgnored(Boolean.TRUE);
		modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT);
		return modelMapper;
	}

}

---------------------------------------------------------------------------------------------

RestTemplate
======================

HttpHeaders httpHeaders = new HttpHeaders();
httpHeaders.set(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);
httpHeaders.set("Authorization", "Basic YWJoaWtnaDp3ZWxjb21lQDFh");
httpHeaders.set("Actor", "MicroService");

HttpEntity<String> httpEntity = new HttpEntity<>(httpHeaders);
HttpEntity<String> httpEntity = new HttpEntity<>(requestJson, httpHeaders);

ResponseEntity<T> = restTemplate.exchange(uri, HttpMethod, httpEntity, OrderResponse.class)
ResponseEntity<T> = restTemplate.exchange(uri, HttpMethod, httpEntity, new ParameterizedTypeReference<List<Movie>>(){})
ResponseEntity<T> = restTemplate.exchange(endpoint, HttpMethod, httpEntity, OrderResponse.class, Map<String, ?> uriVariables)
ResponseEntity<T> = restTemplate.exchange(endpoint, HttpMethod, httpEntity, OrderResponse.class, Object... uriVariables)
ResponseEntity<T> = restTemplate.exchange(endpoint, HttpMethod, httpEntity, new ParameterizedTypeReference<List<Movie>>(){}, Map<String, ?> uriVariables)
ResponseEntity<T> = restTemplate.exchange(endpoint, HttpMethod, httpEntity, new ParameterizedTypeReference<List<Movie>>(){}, Object... uriVariables)

    T = restTemplate.getForObject(uri, Movie.class)
    T = restTemplate.getForObject(endpoint, Movie.class, Object... uriVariables)
    T = restTemplate.getForObject(endpoint, Movie.class, Map<String, ?> uriVariables)

    ResponseEntity<T> = restTemplate.getForEntity(uri, Movie.class)
    ResponseEntity<T> = restTemplate.getForEntity(endpoint, Movie.class, Object... uriVariables)
    ResponseEntity<T> = restTemplate.getForEntity(endpoint, Movie.class, Map<String, ?> uriVariables)

    T = restTemplate.postForObject(uri, httpEntity, OrderResponse.class);
    T = restTemplate.postForObject(endpoint, httpEntity, OrderResponse.class, Object... uriVariables)
    T = restTemplate.postForObject(endpoint, httpEntity, OrderResponse.class, Map<String, ?> uriVariables)


---------------------------------------------------------------------------------------------

RestTemplate Client call with Spring Retry
===============================================
<!-- spring-retry -->
<dependency>
    <groupId>org.springframework.retry</groupId>
    <artifactId>spring-retry</artifactId>
    <version>1.3.2</version>
</dependency>

@EnableRetry

@Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 2000, multiplier = 2))
//it will retry after 2s, 4s, 8s
public OrderResponse callOrderService(String month, String parmRequestSource, String parmAudienceType, String requestJson) {

    //caller :: POST : http://localhost:9050/orders/v1/getOrder/{month}?parmRequestSource={parmRequestSource}&parmAudienceType={parmAudienceType}

    String endPoint = "http://localhost:9050/orders/v1/getOrder/{month}";

    //URI
    Map<String, String> pathVariablesMap = new HashMap<>();
    pathVariablesMap.put("month", month);

    URI uri = UriComponentsBuilder
            .fromUriString(endPoint)
            .queryParam("parmRequestSource", parmRequestSource)
            .queryParam("parmAudienceType", parmAudienceType)
            .buildAndExpand(pathVariablesMap)
            .encode()
            .toUri();

    //HttpHeaders
    HttpHeaders httpHeaders = new HttpHeaders();
    httpHeaders.set(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);
    httpHeaders.set("Authorization", "Basic YWJoaWtnaDp3ZWxjb21lQDFh");
    httpHeaders.set("Actor", "MicroService");

    //HttpEntity
    HttpEntity<String> httpEntity = new HttpEntity<>(requestJson, httpHeaders);



    if (Objects.nonNull(RetrySynchronizationManager.getContext()) && RetrySynchronizationManager.getContext().getRetryCount() > 0) {
        log.info("Retry count {} for service {}", RetrySynchronizationManager.getContext().getRetryCount(), "callOrderService");
    }

    return restTemplate.exchange(uri, HttpMethod.POST, httpEntity, OrderResponse.class).getBody();

}

@Recover
private OrderResponse recover(Exception exception) {
    System.out.println("In recover method...");
    throw new RuntimeException(exception);
}

---------------------------------------------------------------------------------------------
RestTemplate Client call
=============================================

public List<Movie> getMoviesByDirectorAndGenreAndNationalAward(String director, String genre, boolean nationalAward) {

    //caller : GET : http://localhost:9050/orders/v1/getMoviesByDirectorAndGenreAndNationalAward/Satyajit Ray/Family?nationalAward=true

    String endPoint = "http://localhost:9050/orders/v1/getMoviesByDirectorAndGenreAndNationalAward/{director}/{genre}";

    Map<String, String> pathVariablesMap = new HashMap<>();
    pathVariablesMap.put("director", director);
    pathVariablesMap.put("genre", genre);

    URI uri = UriComponentsBuilder
            .fromUriString(endPoint)
            .queryParam("nationalAward", nationalAward)
            .buildAndExpand(pathVariablesMap)
            .encode()
            .toUri();

    System.out.println(uri);

    return restTemplate.exchange(uri, HttpMethod.GET, null, new ParameterizedTypeReference<List<Movie>>() {}).getBody();

}

--------------------------------------------------------------------------------------------
RestTemplate Client call with no parameters
=============================================
String endPoint = "http://localhost:9050/orders/v1/auth";

URI uri = UriComponentsBuilder
        .fromUriString(endPoint)
        .build()
        .encode()
        .toUri();

HttpHeaders httpHeaders = new HttpHeaders();
httpHeaders.set(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);

Map<String, Object> claims = new HashMap<>();
claims.put("userId","eyabhikg");
claims.put("password","12345");

HttpEntity httpEntity = new HttpEntity<>(claims, httpHeaders);

AuthenticationResponse authenticationResponse = restTemplate.exchange(uri, HttpMethod.POST, httpEntity, AuthenticationResponse.class).getBody();

---------------------------------------------------------------------------------------------

RestClient
===============================================

<version>3.2.5</version>
<java.version>21</java.version>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

@Configuration
public class RestClientConfig {

    @Bean(name = "restClient1")
    public RestClient restClient() {
        return RestClient
                .builder()
                .baseUrl("http://localhost:9100/v3/rest")
                .defaultHeader("Content-Type", MediaType.APPLICATION_JSON_VALUE)
                .defaultHeader(HttpHeaders.CONTENT_ENCODING,"gzip")
                .defaultHeader(HttpHeaders.ACCEPT_ENCODING,"gzip")
                .build();
    }

}

@Autowired
@Qualifier("restClient1")
private RestClient restClient;

public List<Movie> getMoviesOfDirectorClient(String director) {
    HttpHeaders httpHeaders = new HttpHeaders();
    httpHeaders.set("Authorization","Bearer " + getJWTToken());
    return
            restClient
                .get()
                .uri("/getMoviesOfDirector/" + director)
                .headers(headers -> headers.addAll(httpHeaders))
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .body(new ParameterizedTypeReference<>() {});
}

public Employee getEmployeeById(Integer employeeId) {
        return restClient
                .get()
                .uri("/getEmployeeById/" + employeeId)
                .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .body(Employee.class);
    }

private String getJWTToken() {
    Map<String, Object> claims = new HashMap<>();
    claims.put("userId","eyabhikg");
    claims.put("password", "12345");

    String jwt =
            Objects.requireNonNull(restClient
                                        .post()
                                        .uri("/authenticate")
                                        .contentType(MediaType.APPLICATION_JSON)
                                        .accept(MediaType.APPLICATION_JSON)
                                        .body(claims)
                                        .retrieve()
                                        .body(AuthenticationResponse.class))
                                    .getJwt();

    System.out.println("jwt - " + jwt);
    return jwt;
}

---------------------------------------------------------------------------------------------

WebClient
==============

@Configuration
class WebClientConfig {

    @Bean
    public WebClient webClient(){
         return WebClient
               .builder()
               .baseUrl("http://localhost:9898/rx")
               .build();

    }

}

@Autowired
private WebClient webClient;

 return
                webClient
                .get()
                .uri("/getEmployees")
                .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToMono(String.class);

---------------------------------------------------------------------------------------------


@ConfigurationProperties, @EnableConfigurationProperties, @EncryptablePropertySources
=========================================================================================

Read properties (using ConfigurationProperties)
-----------------------------------------------------------

statistics:
  gather: Yes
  platforms: Linux | Windows | FreeBSD | SunOS | Mac | AIX
  browsers: Firefox | Netscape | Opera | Safari | Gecko | MSIE
  systems : API | MicroServices | BlockChain

@Configuration
@ConfigurationProperties(prefix = "statistics")
@Getter
@Setter
public class StatisticsConfig {

	private String gather;
	private String platforms;
	private String browsers;
	private String systems;

}

@Autowired
private StatisticsConfig statisticsConfig;

System.out.println(statisticsConfig.getGather());
System.out.println(statisticsConfig.getPlatforms());
System.out.println(statisticsConfig.getBrowsers());
System.out.println(statisticsConfig.getSystems());


Read properties as list (using ConfigurationProperties)
-----------------------------------------------------------

order2:
  statuses:
    pending
    success
    failed

@Configuration
@ConfigurationProperties(prefix = "order2")
@Getter
@Setter
public class PropsListConfig {
    private List<String> statuses;
}

@Autowired
private PropsListConfig propsListConfig;

System.out.println(propsListConfig.getStatuses().get(0));

Read properties as map (using ConfigurationProperties)
-----------------------------------------------------------

application:
  applicationMap:
    306: this is a test
    3061: this is second test

@Configuration
@ConfigurationProperties(prefix = "application")
@Getter
@Setter
public class ApplicationMapConfig {

    private Map<String, String> applicationMap = new HashMap<>();

}

@Autowired
private ApplicationMapConfig applicationMapConfig;

String value1 = applicationMapConfig.getApplicationMap().get("306");


Get individual property from Environment
------------------------------------------

@Autowired
private Environment environment;

System.out.println("~~~~~~~~~~~~~~~From environment ~~~~~~~~~~~~~~~~~~~~~~~~~~");
System.out.println("property1 : " + environment.getProperty("spring.application.name"));
System.out.println("property2 : " + String.format(environment.getProperty("loggedIn.user"), "user1"));


reading property from pom
--------------------------------
spring:
  application:
    name: @project.name@


default values
----------------------
//default = empty String
//@Value("${topic:}")

//default = null
//@Value("${topic:#{null}}")

//default = some value
@Value("${topic:abc}")

private String topic;

@EnableConfigurationProperties(class)
---------------------------------------

spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=
spring.redis.timeout=60000
spring.redis.lettuce.pool.max-active=8
spring.redis.lettuce.pool.max-idle=8
spring.redis.lettuce.pool.max-wait=-1
spring.redis.lettuce.pool.min-idle=0

@ConfigurationProperties(prefix = "spring.redis")
public class RedisProperties {

    private int database;
    private java.lang.String url;
    private java.lang.String host;
    private java.lang.String username;
    private java.lang.String password;
    private int port;
    private boolean ssl;
    private java.time.Duration timeout;
    private java.time.Duration connectTimeout;
    private java.lang.String clientName;
}

@Configuration
@EnableCaching
@EnableConfigurationProperties(RedisProperties.class)
public class RedisConfig {

    @Bean(name = "moviesCachedRedisTemplate")
    public RedisTemplate<String,Object> moviesCachedRedisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<String, Object>();
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }

}

EncryptablePropertySource
-----------------------------------

infoMessages_en.properties
------------------------
encrypt:
  value1: ENC(36zNhYsNLf7Od6yxC1gZXmYBB7RKubDW40DVUsVyhh3cakuV/2O73JUdZ6oTCvY2)
  value2: ENC(4uU+ljpDIlbBkTuFj5IpMKz4fZhLO7oG6BV8TSVQmf5Axt2RvrExItNfje/w+w7A)

jasypt:
  encryptor:
    password: masterpassword

@EncryptablePropertySource("classpath:infoMessages_en.properties")

@Value("${encrypt.value1}")
private String encryptValue1; //scott

---------------------------------------------------------------------------------------------

ELK
============
Elasticsearch - Logstash - Kibana
Centralized logging, log search, log analysis

SpringBoot ------>   Logstash   ----------------------------->  Elasticsearch   ----------> Kibana
                  (-> Input Plugin      -> Output Plugin)

Logstash: accepts data from multiple sources and sends processed data to ElasticSearch
Elasticsearch : distributed search engine that stores indexed data
Kibana : web-ui for data search and analysis

---------------------------------------------------------------------------------------------

Health check
-----------------

@Autowired
private HealthEndpoint healthEndpoint;

@Scheduled(fixedRate = 20000, initialDelay = 1000)
public void healthCheck(){
    logger.info("Liveness status :: {} ", healthEndpoint.health().getStatus());
}

@Scheduled(fixedRateString = "${healthCheck.rate}", initialDelay = 1000)
public void healthCheck() {
    logger.info("Liveness status :: {} ", healthEndpoint.health().getStatus());
}


{
	"@timestamp": "2024-08-29T22:31:00.785+05:30",
	"@version": "1",
	"message": "Liveness status :: UP ",
	"logger_name": "com.example.SpringRESTClient2.controller.ClientController",
	"thread_name": "scheduling-1",
	"level": "INFO",
	"level_value": 20000
}

---------------------------------------------------------------------------------------------

WsConfigurationSupport (imported by @EnableWs)
=================================================

<dependency>
    <groupId>org.springframework.ws</groupId>
    <artifactId>spring-ws-core</artifactId>
</dependency>


WsConfigurerAdapter (imported by @EnableWs)
=================================================

<dependency>
    <groupId>org.springframework.ws</groupId>
    <artifactId>spring-ws-core</artifactId>
</dependency>

WebMvcConfigurer (I)
=======================
for interceptors

------------------------------------------------------------------------------------------

Spring Profiles
======================

spring.profiles.active=dev  -- will run application-dev.properties
property in application.properties will be overridden by application-dev.properties

------------------------------------------------------------------------------------------

Spring Cloud
=======================
Spring Cloud is a family of libraries that integrates common patterns in the Spring application.

Spring Cloud EurekaServer
Spring Cloud EurekaClient
Spring Cloud LoadBalancer
Spring Cloud Gateway

EurekaServer
===================================
service registration and discovery service

<version>3.2.7</version>
<version>2023.0.0</version>

<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.2.7</version>
    <relativePath />
</parent>

<!-- Eureka server -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>

eureka:
   client:
      registerWithEureka: false
      fetchRegistry: false

@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {

	//Eureka server :: http://localhost:8761/
	public static void main(String[] args) {
		SpringApplication.run(EurekaServerApplication.class, args);
	}
}

EurekaClient
============================
SpringConversionFactor

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>

spring:
  application:
    name: conversion-factor
eureka:
  client:
    registerWithEureka: true
    serviceUrl:
      defaultZone: http://localhost:8761/eureka

@SpringBootApplication
@EnableDiscoveryClient
public class SpringConversionFactorApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringConversionFactorApplication.class, args);
	}

}

http://localhost:8061/eureka/v1/addConversionFactor
{
    "countryCode": "AUD",
    "conversionFactor": "1.41"
}
http://localhost:8062/eureka/v1/updateConversionFactor
{
    "countryCode": "AUD",
    "conversionFactor": "1.42"
}
http://localhost:8061/eureka/v1/getConversionFactor/AUD
http://localhost:8062/eureka/v1/getConversionFactor/AUD

Run SpringBootConversionFactor in IntelliJ on port 8061
AND
[Run SpringBootConversionFactor in Eclipse on port 8062 OR
 D:\workspace2\SpringConversionFactor>java -jar -Dserver.port=8062 target/SpringConversionFactor-0.0.2-SNAPSHOT.jar]
Check in Eureka 2 instances are running
Run SpringBootConversionClient from Postman (8061/8062) and check requests are going to both IntelliJ and Eclipse

Client (calling EurekaClient in a Load-Balanced manner)
===================================================================================
SpringConversionFactorFeignClient

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
    <version>4.0.1</version>
</dependency>

@Configuration
public class ServiceInstanceConfig {

    @Bean
    public ServiceInstanceListSupplier serviceInstanceListSupplier(){
        return new ServiceInstanceSupplier("conversion-factor");
    }
}

@LoadBalancerClient(name = "conversion-factor", configuration = ServiceInstanceConfig.class)
@Configuration
class WebClientConfig {

    @LoadBalanced
    @Bean
    public WebClient webClient(){
         return WebClient
               .builder()
               .baseUrl("http://conversion-factor/eureka")
               .build();

        }

}

@RestController
public class NavigationController {

    @Autowired
    private WebClient webclient;

    //http://localhost:8071/getConversionFactorClient/AUD
    @GetMapping(value = "/getConversionFactorClient/{countryCode}", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<String> convertCurrency(@PathVariable("countryCode") String countryCode) {

        return webclient
                .get()
                .uri("/v1/getConversionFactor/" + countryCode)
                .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToMono(String.class);

    }

}

Spring Cloud Gateway
=======================

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

spring:
  application:
    name: conversion-factor
  cloud:
    gateway:
      routes:
        - id: baeldung_route
          uri: http://baeldung.com
          predicates:
            - Path=/baeldung/
        - id: test_route
          uri: http://baeldung.com
          predicates:
            - Path=/test/

http://localhost:8061/actuator/gateway/routes/baeldung_route
{
  "predicate": "Paths: [/baeldung/], match trailing slash: true",
  "route_id": "baeldung_route",
  "filters": [],
  "uri": "http://baeldung.com:80",
  "order": 0
}
http://localhost:8061/baeldung/ -> https://www.baeldung.com/baeldung/


http://localhost:8061/actuator/gateway/routes/test_route
{
  "predicate": "Paths: [/test/], match trailing slash: true",
  "route_id": "test_route",
  "filters": [],
  "uri": "http://baeldung.com:80",
  "order": 0
}
http://localhost:8061/test/ ->  https://www.baeldung.com/test/

------------------------------------------------------------------------------------------

Spring Cloud Config Server
=============================

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-config-server</artifactId>
</dependency>

<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.1.5</version>
    <relativePath/>
</parent>

<properties>
    <java.version>21</java.version>
    <spring-cloud.version>2022.0.3</spring-cloud.version>
</properties>


@RefreshScope
@EnableConfigServer
@SpringBootApplication
public class SpringBootCloudConfigApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBootCloudConfigApplication.class, args);
    }

}

//Create Git repo

/*
 * $ git init
 *
 * $ git add .
 *
 * $ git commit -m "initial commit"
 */

D:\workspace2\configRepo\production>git init
D:\workspace2\configRepo\production>git add .
D:\workspace2\configRepo\production>git commit -m "aa"


application.yml
-------------------
spring:
  application:
    name: SpringBootCloudConfig
  cloud:
    config:
      server:
        git:
          uri: D:\\workspace2\\configRepo\\production
          default-label: master # now default branch name of GitHub is "main", but Spring Cloud Config still looks for "master" as a label name

http://localhost:8888/SpringBootCloudConfigClient/development
    {"name":"SpringBootCloudConfigClient","profiles":["development"],"label":null,"version":"e74117163b5a0891486a02293c78856f8da5a5cd","state":null,"propertySources":[{"name":"D:\\\\workspace2\\\\configRepo\\\\production/SpringBootCloudConfigClient.yml","source":{"ibm.mq.queueManager":"ABHIKTESTQM","ibm.mq.channel":"CLOUD.ADMIN.SVRCONN","ibm.mq.connName":"abhiktestqm-ff9e.qm.eu-gb.mq.appdomain.cloud(32503)","ibm.mq.user":"ghosha24","ibm.mq.password":"pceI1ObgLP4EzuDWfkPJG7z09WOeD1zh7KX_oV59R1hx","ibm.mq.timeout":60000,"ibm.mq.maxAttempts":3,"ibm.mq.receiveTimeout":5000,"ibm.mq.userAuthentication":true,"ibm.mq.transportType":1,"ibm.mq.appRequestQueue":"APP.REQUEST.Q","ibm.mq.appResponseQueue":"APP.RESPONSE.Q","test.data":"this is NEW PROD data","spring.password":"p0Fhr1SxkogmSZGid8hkuQ==","jasypt.encryptor.password":"Sdmjsj23#2"}}]}
http://localhost:8888/SpringBootCloudConfigClient/production
    {"name":"SpringBootCloudConfigClient","profiles":["production"],"label":null,"version":"e74117163b5a0891486a02293c78856f8da5a5cd","state":null,"propertySources":[{"name":"D:\\\\workspace2\\\\configRepo\\\\production/SpringBootCloudConfigClient.yml","source":{"ibm.mq.queueManager":"ABHIKTESTQM","ibm.mq.channel":"CLOUD.ADMIN.SVRCONN","ibm.mq.connName":"abhiktestqm-ff9e.qm.eu-gb.mq.appdomain.cloud(32503)","ibm.mq.user":"ghosha24","ibm.mq.password":"pceI1ObgLP4EzuDWfkPJG7z09WOeD1zh7KX_oV59R1hx","ibm.mq.timeout":60000,"ibm.mq.maxAttempts":3,"ibm.mq.receiveTimeout":5000,"ibm.mq.userAuthentication":true,"ibm.mq.transportType":1,"ibm.mq.appRequestQueue":"APP.REQUEST.Q","ibm.mq.appResponseQueue":"APP.RESPONSE.Q","test.data":"this is NEW PROD data","spring.password":"p0Fhr1SxkogmSZGid8hkuQ==","jasypt.encryptor.password":"Sdmjsj23#2"}}]}


Config Client
==================

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-config</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bootstrap</artifactId>
</dependency>



<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

bootstrap.yml
--------------

spring:
  application:
    name: SpringBootJPA4 # maps to the property file name in git
  cloud:
    config:
      url: http://localhost:8888  # the config server url

------------------------------------------------------------------------------------------------------------

Spring Cloud Sleuth + Zipkin :: Distributed Tracing service
=================================================================

Spring Cloud Sleuth  :: Distributed Tracing service :: logs are printed in the following format − [TraceId:SpanId:ParentSpanId:Flags]

Zipkin :: Storing and Visualizing of Spring Cloud Sleuth logs 
            Collector — collects traces from application (port :9411)
            Storage   — MySQL / MongoDB/ Cassandra
            Web UI    — visualize trace data
            Search    — on trace data

Client
--------
Span reported: ef0ffd1475991d16:c09a39b05c45cd71:ef0ffd1475991d16:1 - GET
                                                 /
Span reported: ef0ffd1475991d16:ef0ffd1475991d16:0:1 - getMovieDetails

Service
----------
Span reported: ef0ffd1475991d16:6dd6c4bf98adad39:c09a39b05c45cd71:1 - getMovieDetails


Add Spring Cloud Sleuth and Zipkin dependency and Spring Cloud dependency management in pom of SpringREST2 and SpringRESTClient3

        <!--Spring Cloud Sleuth -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-sleuth</artifactId>
        </dependency>

         <!-- Zipkin -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-zipkin</artifactId>
            <version>2.2.8.RELEASE</version>
        </dependency>

         <dependencyManagement>
                 <dependencies>
                     <dependency>
                         <groupId>org.springframework.cloud</groupId>
                         <artifactId>spring-cloud-dependencies</artifactId>
                         <version>2021.0.0</version>
                         <type>pom</type>
                         <scope>import</scope>
                     </dependency>
                 </dependencies>
         </dependencyManagement>


            Run Zipkin
            -------------------
            E:\Softwares> java -jar zipkin-server-2.12.9-exec.jar
            OR
            Start Docker Desktop
            gitbash > docker run -d -p 9411:9411 openzipkin/zipkin

http://localhost:9411/zipkin/

--------------------------------------------------------------------------------------------------

Reactive Programming
========================

Event-driven, non-blocking programming which communicates over asynchronous data streams
High-concurrency scenarios
Spring WebFlux (Spring Reactive Web Framework)
ASynchronous HTTP call
Fluent API
Servlet->Thread Pool model
Backpressure to stabilise the flow of asynchronous data streams
R2DBC - allows you to work with SQL databases with a Reactive non-blocking API.

Why Reactive Programming?
-----------------------------
1. Non-blocking I/O - scaling
2. Servlet->Thread Pool model -  a small number of threads can serve large no of requests
        - Every request comes with a Handler function and call-back function
        - Servlet-thread delegates the request to a thread-pool
        - 1 thread from Thread pool delegates the request to its Handler function
        - When the Handler function is complete, 1 thread from Thread-pool takes the response and passes it to the call-back function
3. Improves Latency


Mono and Flux
--------------------
In Spring WebFlux, Mono and Flux are ASync publishers

Mono: Mono is a Publisher that returns 0 or 1 async components

public class UserService {
    public Mono<User> getUserById(String userId) {
        // Simulating a user lookup
        if ("123".equals(userId)) {
            return Mono.just(new User("123", "John Doe"));
        } else {
            return Mono.empty();  // Returns an empty Mono if user not found
        }
    }
}

Mono.just(value)
Mono.empty()
Mono.error(exception)

Flux: Flux is a Publisher that returns 0…N async components

public class UserService {
    public Flux<User> getAllUsers() {
        return Flux.just(
                new User("123", "John Doe"),
                new User("456", "Jane Smith"),
                new User("789", "Robert Brown")
        );
    }
}

Flux.just(value1, value2, ...)
Flux.empty()
Flux.fromIterable(iterable)
Flux.range(start, count)

public Mono<Employee> getEmployeeById(Integer id) {
    return springBootReactiveRepository.findById(id);
}

public Flux<Employee> getEmployees() {
    return springBootReactiveRepository.findAll();
}

public Mono<Book> getBookDetails(Integer id){
    return bookRepository.findById(id);
}

public Mono<Employee> changeEmployeeFirstNameToUpperCase(Integer id) {
    return springBootReactiveRepository.findById(id)
            .map(employee -> {
                employee.setFirstName(employee.getFirstName().toUpperCase(Locale.ENGLISH));
                return employee;
            }).flatMap(employee -> springBootReactiveRepository.save(employee));
}


R2DBC
---------------
Reactive Relational Database Connectivity
R2DBC allows you to work with SQL databases with a Reactive non-blocking API.

<!--R2DBC -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-r2dbc</artifactId>
</dependency>

<!--R2DBC Postgresql-->
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>r2dbc-postgresql</artifactId>
    <scope>runtime</scope>
</dependency>

@Repository
@EnableR2dbcRepositories
public interface SpringBootReactiveRepository extends ReactiveCrudRepository<Employee, Integer> {

}


Spring Webflux
-----------------------
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>


@Configuration
public class ReactiveConfig {

    @Value("${connectionTimeout}")
    private Integer connectionTimeout;

    @Value("${requestTimeout}")
    private Integer requestTimeout;

    @Value("${readTimeout}")
    private Integer readTimeout;

    @Bean
    public WebClient webClient(){
       HttpClient httpClient =
                HttpClient.create()
                        .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, connectionTimeout)
                        .responseTimeout(Duration.ofMillis(requestTimeout))
                        .doOnConnected(connection -> connection.addHandlerLast(new ReadTimeoutHandler(readTimeout)));

        return WebClient
               .builder()
               .baseUrl("http://localhost:9898/rx")
                .clientConnector(new ReactorClientHttpConnector(httpClient))
               .build();
    }
}

public Mono<Book> getBookDetails(Integer id){
        return webClient
                .get()
                .uri("/getBookDetails/"+id)
                .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .onStatus(HttpStatus::isError, response -> Mono.error(new RuntimeException("Exception :: " + response)))
                .bodyToMono(Book.class)
                .retryWhen(Retry.backoff(3, Duration.ofSeconds(1)))
                .onErrorResume(error -> Mono.just(new Book()));
}

public Flux<Employee> getEmployeesAsync() {
        return webClient
                .get()
                .uri("/getEmployees")
                .header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToFlux(Employee.class);
    }

--- Mono to Flux---
public Flux<Order> getOrdersForUser(String userId) {
    return userService.getUserById(userId)  // Returns a Mono<User>
            .flatMapMany(user -> orderRepository.findByUserId(user.getId()));  // Returns a Flux<Order>
}


Backpressure
-------------------------
Backpressure is the ability of the Subscriber to report to the Publisher that it is emitting events at a higher rate
 than the Subscriber can consume.
For Spring Webflux , Backpressure is inbuilt - How ?
When Mono/Flux emits events, it does not directly send it to the Subscriber -
it waits for the Subscriber to send a signal as to how much data it can consume - and then sends that data.


Non-Reactive style
------------------------------------

@RestController
public class NonReactiveController {

    @GetMapping("/nonreactive")
    public ResponseEntity<String> getNonReactive() {
       return ResponseEntity
                      .status(HttpStatus.OK)
                			.body("Hello from Non-Reactive!");
    }
}

Reactive style
------------------------------------

@RestController
public class ReactiveController {

    @GetMapping("/reactive")
    public Mono<ResponseEntity<String>> getReactive() {
        return Mono.just(ResponseEntity
                                       .status(HttpStatus.OK)
                                       .body("Hello from Reactive!"));
    }
}

------------------------------------------------------------------------------------------------------------

SpringBoot Proxy
=========================
Proxy is a middleman that provides extra functionality like logging, validation, routing etc
Proxy can be achieved in 2 ways : Interceptor / Proxy service
	- for Interceptor all requests will be intercepted, for proxy service only those service calls will be proxied

Spring Interceptor
========================
http request -------> Filter ---------> DispatcherServlet  ------------- > HandlerInterceptor  ----------> Controller/Handler

                      Filter                                                                Interceptor
                      -------------                                                         -------------
                      Authentication                                                        Authorization
                      Logging and auditing                                                  Cross-cutting concerns
                      Image and data compression
                      Any functionality we want to be decoupled from Spring MVC

preHandle() – Executed before the target handler is called
postHandle() – Executed after the target handler but before DispatcherServlet
afterCompletion() – Callback after completion of request

@Configuration
public class RestConfig implements WebMvcConfigurer {

    //add the Interceptor in the Spring container
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new RequestInterceptor());
    }

}


@Component
public class RequestInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        if (StringUtils.isNotBlank(request.getHeader("test")))
            System.out.println("Hello :: " + request.getHeader("test"));

        MDC.put("test", "hello");
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
    }
}

Proxy Service
====================
http request -------> Filter ---------> DispatcherServlet  ------------- >   ----------> Controller/Handler  --------> proxy service -----------> Service


------------------------------------------------------------------------------------------------------------

Filter
=================
Filter is a component of the web that is executed by the Servlet for each incoming HTTP request and for each HTTP response
intercepts the request and checks the request
implement javax.servlet.Filter interface
ex: OncePerRequestFilter

init(FilterConfig config)
doFilter(HttpServletRequest request,HttpServletResponse response, FilterChain chain)
destroy()

Servlet
=============
It is a Java class that is used to extend the capabilities of servers that host applications accessed by means of a request-response programming model.
javax.servlet and javax.servlet.http packages provide interfaces and classes for writing servlets

init()
service()
destroy()

ServletContainer
======================
Servlets run in a ServletContainer which handles the networking side(parsing, connection handling) - Tomcat
The three main components of a ServletContainer are the Filter, Servlet, Interceptor and Listener

------------------------------------------------------------------------------------------------------------

Request Compression with GZip
====================================
Zips the JSON response from server so lesser bandwidth and lesser latency
(P) - CPU Overhead

server:
  port: 9050
  compression:
    enabled: true
    min-response-size: 2048 #This will compress responses larger than 2KB for the specified MIME types.
    mime-types: application/json,application/xml

------------------------------------------------------------------------------------------------------------

Dependent service
===================================
- Exists as a jar dependency in pom of Deployed microservices.
- All properties of dependents will come from kube.deploy.yml of some deployed services.

Change in Java code  ->  Merge, Build, Deploy
Change in kube.deploy.yml   -> Merge, Deploy

Suppose A has B as dependency and there is a change in B.
Then build B - for local testing - take the snapshot version of B and put the snapshot version jar in A’s pom.
Also check A ->External libraries -> B -> changed code

------------------------------------------------------------------------------------------------------------

Docker commands
=======================

>wsl --update

Build Image
-------------------
dockerfile > docker build . -t voting-app
dockerfile > docker build . -t springbootdockercompose.jar --no-cache

Run Image
-------------
docker run -d --name jaeger-ui -p 16686:16686 -p 6831:6831/udp jaegertracing/all-in-one:1.9
docker run -d --name=redis redis
docker run -d --name=db -e POSTGRES_PASSWORD=postgres postgres:9.4
docker run -d -p 9798:9798 app.jar

All images
-------------------
docker images

Running containers
----------------------------
docker ps

All docker containers
----------------------
docker ps -a

Docker-compose
--------------------
docker-compose.yml > docker-compose up --build

Port mapping establishes communication between host machine and Docker Container.

System info
----------------------
docker system info

Export image
----------------------
docker save -o <exported_name>.tar <container-name>

Check version
-----------------
docker –v

Stopping a running container
----------------------------------
docker stop <container_id>
OR
docker kill <container_id>

Deleting  container
----------------------------
docker rm <container_id>

Stopping all running containers
----------------------------------
docker stop $(docker ps -a -q)

Remove all containers
----------------------------
docker rm -f $(docker ps -a -q)

Remove image
-------------------
docker rmi -f <image_id>

Remove all images
-----------------------
docker rmi -f $(docker images -q)

Go inside a running container
----------------------------------------
docker exec -it <container_id> bash
docker exec -it <container_id> sh

Inspect container
------------------------
docker inspect <container_id>

Remove all stopped containers, unused networks, build caches, and dangling images
------------------------------------------------------------------------------------
docker system prune -a

Log of a Container
-------------------------
docker logs 8e9613f44ab6

------------------------------------------------------------------------------------------------------------

Loosely Coupled         vs.                                                      Tightly Coupled
--------------------------------------------------------------------------------------------------------------
Interface                                                                        Class
Dependency injection                                                             Dependency instantiation
Testing - mocks - easier                                                         Testing - instantiate - harder
Scalable

// User service that depends on the notification interface
class UserService {
    private NotificationService notificationService;

    public UserService(NotificationService notificationService) {
        this.notificationService = notificationService; // Dependency injection
    }

    public void notifyUser(String message) {
        notificationService.sendNotification(message);
    }
}
                                                                                class NotificationService {
                                                                                    private EmailService emailService = new EmailService(); // Direct dependency

                                                                                    public void notifyUser(String message) {
                                                                                        emailService.sendEmail(message);
                                                                                    }
                                                                                }

------------------------------------------------------------------------------------------------------------------------------------------

Circular dependency
------------------------------

@Service
public class UserService {
    
   private final RetryService retryService;

   public UserService(@Lazy RetryService retryService) {  //Used @Lazy here
        this.retryService = retryService;
    }
}

@Service
public class RetryService {

    private final UserService userService;
    
   public RetryService(UserService userService) {
        userService = userService;
    }
}



------------------------------------------------------------------------------------------------------------------------------------------

