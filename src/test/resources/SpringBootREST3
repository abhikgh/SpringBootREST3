
SpringBoot3 changes
===========================================================

1. 	<version>3.2.7</version>
	<java.version>21</java.version>
	<spring-cloud.version>2022.0.4</spring-cloud.version>
	<openapi.version>2.2.0</openapi.version>

2. <!--Lombok-->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.30</version>
    <scope>provided</scope>
</dependency>

3. javax.persistence -> jakarta.persistence

4. JSONB ->  @Type(JsonBinaryType.class)

5. Security ->
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private static final String[] AUTH_WHITELIST = {
            "/v3/rest/hello", "/v3/rest/helloPost"
    };

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {
      return   httpSecurity
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(auth -> auth.requestMatchers(AUTH_WHITELIST).permitAll()
                                                    .anyRequest().authenticated())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .build();
    }
}

6. Observability -> 
	Micrometer replaces Spring Cloud Sleuth 

	<artifactId>opentracing-jeager-integration</artifactId>  is replaced with
	<artifactId>util-observability</artifactId>

7. jaxb-api -> 

	    <groupId>javax.xml.bind</groupId>
            <artifactId>jaxb-api</artifactId>			is replaced with
            
	    <groupId>jakarta.xml.bind</groupId>
            <artifactId>jakarta.xml.bind-api</artifactId>

8. Swagger -> 

	<dependency>
            <groupId>org.springdoc</groupId>
            	<artifactId>springdoc-openapi-webmvc-core</artifactId>
            <artifactId>springdoc-openapi-starter-webmvc-api</artifactId>
            <version>${openapi.version}</version>
        </dependency>

9. Tests -> 	@MockBean 		is replaced with 

		        @Mock

ApplicationConfig
========================
@Configuration
public class ApplicationConfig {

    //Tomcat Protocol Handler is responsible for handling incoming requests in a Spring Boot application
    //TomcatProtocolHandlerCustomizer configures the Executor
    //Executor is responsible for executing tasks, like handling incoming requests.
    @Bean
    TomcatProtocolHandlerCustomizer<?> tomcatProtocolHandlerCustomizer() {
        return protocolHandler -> {
            protocolHandler.setExecutor(Executors.newVirtualThreadPerTaskExecutor());
        };
    }
}

SecurityConfig
=======================

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private static final String[] AUTH_WHITELIST = {
            "/v3/rest/hello", "/v3/rest/helloPost", "/v3/rest/home"
    };

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {
        return httpSecurity
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(auth -> auth.requestMatchers(AUTH_WHITELIST).permitAll()
                        .anyRequest().authenticated())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .build();
    }
}

Gatling
======================

Gatling : Load testing tool that can be used to simulate user behavior and test the performance of Spring Boot applications under different loads
Compared to JMeter : Gatling is faster, lightweight, and provides more detailed and colorful reports

simulation service :: E:\Softwares\gatling-charts-highcharts-bundle-3.9.5\user-files\simulations\GatlingSimulation.java

Run gatling :: E:\Softwares\gatling-charts-highcharts-bundle-3.9.5\bin\gatling.bat

Results :: E:\Softwares\gatling-charts-highcharts-bundle-3.9.5\results

<dependency>
    <groupId>io.gatling</groupId>
    <artifactId>gatling-core</artifactId>
    <version>3.9.3</version>
</dependency>
<!-- https://mvnrepository.com/artifact/io.gatling.highcharts/gatling-charts-highcharts -->
<dependency>
    <groupId>io.gatling.highcharts</groupId>
    <artifactId>gatling-charts-highcharts</artifactId>
    <version>3.9.3</version>
</dependency>
<!-- https://mvnrepository.com/artifact/io.gatling/gatling-maven-plugin -->
<dependency>
    <groupId>io.gatling</groupId>
    <artifactId>gatling-maven-plugin</artifactId>
    <version>4.3.1</version>
</dependency>


Class Data Sharing (CDS)
==============================
JVM optimization technique

Creates a snapshot of the application classes and then storing them in a shared archived file
During startup, JVM can reference this archive, dramatically speeding up the class loading process.

spring.context.exit-on-refresh=true
-XX:ArchiveClassesAtExit=app-cds.jsa
# On the JVM you plan to deploy to:
java -Xshare:on -XX:SharedArchiveFile=app-cds.jsa -jar myapp.jar

GraalVM native image 
========================
Compiles the Java code into a standalone executable, eliminating the need for a JVM at runtime.


Micrometer
======================

<!-- Micrometer-core -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-core</artifactId>
    <scope>runtime</scope>
</dependency>
<!-- Micrometer-prometheus -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
    <scope>runtime</scope>
</dependency>
	This module enables Prometheus to scrape Micrometer logs
	define our own metrics using Micrometer
	gather them using Prometheus
	display them on a Grafana dashboard

		      (exposes Metrics)  (Tracing + metrics collector and shipment)  (scrape the Metrics)     (query Prometheus)
SpringBoot ------> Actuator  ---->   Micrometer   --------------->             Prometheus     ------>    Grafana (observability backend)
									(monitoring backend : monitoring and alerting toolkit)
                                                                                                      - OpenTelemetry, Jaeger, Zipkin
application.yaml
------------------------------
management:
  server:
    port: 9101
  endpoints:
    web:
      exposure:
        include: health, prometheus
      base-path: "/"
      path-mapping:
        prometheus: "metrics"
  metrics:
    tags:
      application: transfer-service

promotheus.yaml
--------------------------
global:
  scrape_interval: 15s # By default, scrape targets every 15 seconds.
# A scrape configuration containing exactly one endpoint to scrape:
# Here it's Prometheus itself.
scrape_configs:
  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.
  - job_name: 'prometheus'
    # Override the global default and scrape targets from this job every 5 seconds.
    scrape_interval: 5s
    static_configs:
      - targets: [ 'localhost:9090' ]
  - job_name: 'transfer-service'
    # Override the global default and scrape targets from this job every 5 seconds.
    scrape_interval: 2s
    metrics_path: /metrics
    static_configs:
      - targets: [ 'host.docker.internal:9101' ]

Metric type                             Description
------------------                  ----------------------------------------
default
--------
Thread utilization
CPU Usage
Cache utilization
Connection pool

@Autowired
private MeterRegistry meterRegistry;

// http://localhost:9050/orders/v1/getMoviesByDirectorAndGenre/Satyajit Ray/Family
@GetMapping(value = "/getMoviesByDirectorAndGenre/{director}/{genre}", produces = MediaType.APPLICATION_JSON_VALUE)
public ResponseEntity<List<Movie>> getMoviesByDirectorAndGenre(
        @PathVariable("director") String director,
        @PathVariable("genre") String genre) {

    //Counter metric
    Counter counter = Counter.builder("getMoviesByDirectorAndGenre")
            .description("a number of requests to /getMoviesByDirectorAndGenre endpoint")
            .register(meterRegistry);
    counter.increment();

    //Gauge metric
    Gauge.builder("users_count", userService::countUsers)
            .description("A current number of users in the system")
            .register(meterRegistry);

    //Timer metric
    Timer.Sample timer = Timer.start(meterRegistry);

    List<Movie> movies = movieService.getMoviesByDirectorAndGenre(director, genre);

    timer.stop(Timer.builder("getMoviesByDirectorAndGenre_Timer").register(meterRegistry));
    return ResponseEntity.ok(movies);
}

----------------------------------------------------------------------------------------------------------------------

Spring Observability (builds on Micrometer, formerly Spring Cloud Sleuth)
===============================================================================
Observability is the ability to measure the internal state of a system only by checking its outputs (logs, traces, metrics)
It’s more for efficiently recording application metrics with Micrometer and implementing tracing through providers like OpenTelemetry

Micrometer
====================
vendor-neutral application metrics facade which replaces Spring Cloud Sleuth
Timer                                 measuring short-duration latencies, and the frequency of such events.
Counter				      count
Gauge	                              current value
DistributionSummary	              total amount of all recorded events
Observation API
	ObservationRegistry observationRegistry = ObservationRegistry.create();
	Observation observation = Observation.createNotStarted("sample", observationRegistry);
	observation.observe(() -> {
	    // ... the observed action
	});
        
	//data-collecting code is implemented as an ObservationHandler. 
	//This handler gets notified about the Observation‘s lifecycle events, and therefore provides callback methods.
	 public class SimpleLoggingHandler implements ObservationHandler<Observation.Context> {

	    private static final Logger log = LoggerFactory.getLogger(SimpleLoggingHandler.class);
	
	    @Override
	    public boolean supportsContext(Observation.Context context) {
	        return true;
	    }
	
	    @Override
	    public void onStart(Observation.Context context) {
	        log.info("Starting");
	    }
	
	    @Override
	    public void onScopeOpened(Observation.Context context) {
	        log.info("Scope opened");
	    }
	
	    @Override
	    public void onScopeClosed(Observation.Context context) {
	        log.info("Scope closed");
	    }
	
	    @Override
	    public void onStop(Observation.Context context) {
	        log.info("Stopping");
	    }
	
	    @Override
	    public void onError(Observation.Context context) {
	        log.info("Error");
	    }
	}

	observationRegistry
	  .observationConfig()
	  .observationHandler(new SimpleLoggingHandler());

	observationRegistry
	  .observationConfig()
	  .observationHandler(new ObservationTextPublisher(System.out::println));

	MeterRegistry meterRegistry = new SimpleMeterRegistry();
	observationRegistry
	  .observationConfig()
	  .observationHandler(new DefaultMeterObservationHandler(meterRegistry));



Prometheus
=====================================
Monitoring and Alerting service

Prometheus needs an endpoint from which it can scrape the metrics data at a configured interval.

<!-- Web -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<!-- Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<!-- Micrometer-prometheus -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
    <scope>runtime</scope>
</dependency>
<!-- AOP, for custom timer -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
(we need AOP because Micrometer timer is based on AspectJ)

management:
  endpoints:
    web:
      exposure:
        include: ["health","prometheus","metrics","info"]

//Counter metric
Counter counter = Counter.builder("getMoviesByDirectorAndGenre")
        .description("a number of requests to /getMoviesByDirectorAndGenre endpoint")
        .register(meterRegistry);
counter.increment();


@Bean
public TimedAspect timedAspect(MeterRegistry meterRegistry){
    return new TimedAspect(meterRegistry);
}

@Timed(value = "getMoviesOfDirector.time")
@GetMapping(value = "/getMoviesOfDirector/{director}", produces = MediaType.APPLICATION_JSON_VALUE)

Hit the request
Check http://localhost:9050/actuator/prometheus for getMoviesOfDirector


prometheus.yml
----------------------
    scrape_configs:
      - job_name: 'SpringBootREST2'
        metrics_path: '/actuator/prometheus'
        scrape_interval: 5s
        static_configs:
          - targets: ['host.docker.internal:9050']
            labels:
              application: 'SpringBootREST2'


docker-compose.yml
----------------------
version: '3.7'

services:
  prometheus:
    image: prom/prometheus:v2.44.0
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
    restart: always
``
D:\workspace2\SpringBootREST2\src\main\resources > docker-compose up

http://localhost:9090/
- Check Status -> Targets

#TYPE http_server_requests_seconds_count
#TYPE getMoviesOfDirector_time_seconds_max gauge
#TYPE getMoviesOfDirector_time_seconds_count :: gives count of calls


How does Prometheus that is running on Docker connect to SpringBoot app that is running on localhost?
---------------------------------------------------------------------------------------------------------------
- targets: ['host.docker.internal:9050']
  host.docker.internal is a host-gateway which is a daemon process routing requests to localhost


Grafana
======================

Data Visualization service
Ensure to add Prometheus as a Data Source in Grafana.
query Prometheus(datasources)
     depends_on:
          - prometheus

datasources.yml
----------------------
apiVersion: 1
datasources:
  - name: Prometheus
    type: prometheus
    access: proxy
    url: http://prometheus:9090
    isDefault: true

docker-compose-yml
--------------------------
grafana:
    image: grafana/grafana:9.5.2
    container_name: grafana
    ports:
      - "3000:3000"
    restart: unless-stopped
    volumes:
      - ./grafana/datasources.yml:/etc/grafana/datasources.yml
    depends_on:
      - prometheus

http://localhost:3000/ (admin/welcome@1a)

Connect to Prometheus from Grafana
-----------------------------------------
Get Prometheus container id
docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' daca98a3c836
- 172.22.0.2
Prometheus IP in Grafana :: http://172.22.0.2:9090
